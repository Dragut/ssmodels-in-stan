// Code generated by Stan version 2.10

#include <stan/model/model_header.hpp>

namespace model_linear_trend_ar2_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
to_symmetric_matrix(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        current_statement_begin__ = 14;
        return stan::math::promote_scalar<fun_return_scalar_t__>(multiply(0.5,add(x,transpose(x))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct to_symmetric_matrix_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& x, std::ostream* pstream__) const {
        return to_symmetric_matrix(x, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
to_matrix_colwise(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& v,
                      const int& m,
                      const int& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  res(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(n));
            (void) res;  // dummy to suppress unused var warning
            stan::math::initialize(res, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 27;
            for (int j = 1; j <= n; ++j) {
                current_statement_begin__ = 28;
                for (int i = 1; i <= m; ++i) {
                    current_statement_begin__ = 29;
                    stan::math::assign(get_base1_lhs(res,i,j,"res",1), get_base1(v,(((j - 1) * m) + m),"v",1));
                }
            }
            current_statement_begin__ = 32;
            return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct to_matrix_colwise_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& v,
                      const int& m,
                      const int& n, std::ostream* pstream__) const {
        return to_matrix_colwise(v, m, n, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
to_matrix_rowwise(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& v,
                      const int& m,
                      const int& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  res(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(n));
            (void) res;  // dummy to suppress unused var warning
            stan::math::initialize(res, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 46;
            for (int i = 1; i <= n; ++i) {
                current_statement_begin__ = 47;
                for (int j = 1; j <= m; ++j) {
                    current_statement_begin__ = 48;
                    stan::math::assign(get_base1_lhs(res,i,j,"res",1), get_base1(v,(((i - 1) * n) + n),"v",1));
                }
            }
            current_statement_begin__ = 51;
            return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct to_matrix_rowwise_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& v,
                      const int& m,
                      const int& n, std::ostream* pstream__) const {
        return to_matrix_rowwise(v, m, n, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
to_vector_colwise(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  res(static_cast<Eigen::VectorXd::Index>(num_elements(x)));
            (void) res;  // dummy to suppress unused var warning
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            stan::math::initialize(res, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 65;
            stan::math::assign(n, rows(x));
            current_statement_begin__ = 66;
            stan::math::assign(m, cols(x));
            current_statement_begin__ = 67;
            for (int i = 1; i <= n; ++i) {
                current_statement_begin__ = 68;
                for (int j = 1; j <= m; ++j) {
                    current_statement_begin__ = 69;
                    stan::math::assign(get_base1_lhs(res,((n * (j - 1)) + i),"res",1), get_base1(x,i,j,"x",1));
                }
            }
            current_statement_begin__ = 72;
            return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct to_vector_colwise_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& x, std::ostream* pstream__) const {
        return to_vector_colwise(x, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
to_vector_rowwise(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  res(static_cast<Eigen::VectorXd::Index>(num_elements(x)));
            (void) res;  // dummy to suppress unused var warning
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            stan::math::initialize(res, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 86;
            stan::math::assign(n, rows(x));
            current_statement_begin__ = 87;
            stan::math::assign(m, cols(x));
            current_statement_begin__ = 88;
            for (int i = 1; i <= rows(x); ++i) {
                current_statement_begin__ = 89;
                for (int j = 1; j <= cols(x); ++j) {
                    current_statement_begin__ = 90;
                    stan::math::assign(get_base1_lhs(res,(((i - 1) * m) + j),"res",1), get_base1(x,i,j,"x",1));
                }
            }
            current_statement_begin__ = 93;
            return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct to_vector_rowwise_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& x, std::ostream* pstream__) const {
        return to_vector_rowwise(x, pstream__);
    }
};

inline
int
symmat_size(const int& n, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            int sz(0);
            (void) sz;  // dummy to suppress unused var warning
            current_statement_begin__ = 110;
            stan::math::assign(sz, 0);
            current_statement_begin__ = 111;
            for (int i = 1; i <= n; ++i) {
                current_statement_begin__ = 112;
                stan::math::assign(sz, (sz + i));
            }
            current_statement_begin__ = 114;
            return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct symmat_size_functor__ {
        inline
    int
    operator()(const int& n, std::ostream* pstream__) const {
        return symmat_size(n, pstream__);
    }
};

inline
int
find_symmat_dim(const int& n, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            int i(0);
            (void) i;  // dummy to suppress unused var warning
            int remainder(0);
            (void) remainder;  // dummy to suppress unused var warning
            current_statement_begin__ = 131;
            stan::math::assign(i, 0);
            current_statement_begin__ = 132;
            while (as_bool(logical_gt(n,0))) {
                current_statement_begin__ = 133;
                stan::math::assign(i, (i + 1));
                current_statement_begin__ = 134;
                stan::math::assign(remainder, (remainder - i));
            }
            current_statement_begin__ = 136;
            return stan::math::promote_scalar<fun_return_scalar_t__>(i);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct find_symmat_dim_functor__ {
        inline
    int
    operator()(const int& n, std::ostream* pstream__) const {
        return find_symmat_dim(n, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
vector_to_symmat(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                     const int& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  m(static_cast<Eigen::VectorXd::Index>(n),static_cast<Eigen::VectorXd::Index>(n));
            (void) m;  // dummy to suppress unused var warning
            int k(0);
            (void) k;  // dummy to suppress unused var warning
            stan::math::initialize(m, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 150;
            stan::math::assign(k, 1);
            current_statement_begin__ = 151;
            for (int j = 1; j <= n; ++j) {
                current_statement_begin__ = 152;
                for (int i = 1; i <= j; ++i) {
                    current_statement_begin__ = 153;
                    stan::math::assign(get_base1_lhs(m,i,j,"m",1), get_base1(x,k,"x",1));
                    current_statement_begin__ = 154;
                    if (as_bool(logical_neq(i,j))) {
                        current_statement_begin__ = 155;
                        stan::math::assign(get_base1_lhs(m,j,i,"m",1), get_base1(m,i,j,"m",1));
                    }
                    current_statement_begin__ = 157;
                    stan::math::assign(k, (k + 1));
                }
            }
            current_statement_begin__ = 160;
            return stan::math::promote_scalar<fun_return_scalar_t__>(m);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct vector_to_symmat_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                     const int& n, std::ostream* pstream__) const {
        return vector_to_symmat(x, n, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
symmat_to_vector(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  v(static_cast<Eigen::VectorXd::Index>(symmat_size(rows(x), pstream__)));
            (void) v;  // dummy to suppress unused var warning
            int k(0);
            (void) k;  // dummy to suppress unused var warning
            stan::math::initialize(v, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 174;
            stan::math::assign(k, 1);
            current_statement_begin__ = 177;
            for (int j = 1; j <= rows(x); ++j) {
                current_statement_begin__ = 178;
                for (int i = 1; i <= j; ++i) {
                    current_statement_begin__ = 179;
                    stan::math::assign(get_base1_lhs(v,k,"v",1), get_base1(x,i,j,"x",1));
                    current_statement_begin__ = 180;
                    stan::math::assign(k, (k + 1));
                }
            }
            current_statement_begin__ = 183;
            return stan::math::promote_scalar<fun_return_scalar_t__>(v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct symmat_to_vector_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& x, std::ostream* pstream__) const {
        return symmat_to_vector(x, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,1>
ssm_filter_update_a(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& a,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,1>& c,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& T,
                        const Eigen::Matrix<T3__, Eigen::Dynamic,1>& v,
                        const Eigen::Matrix<T4__, Eigen::Dynamic,Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  a_new(static_cast<Eigen::VectorXd::Index>(num_elements(a)));
            (void) a_new;  // dummy to suppress unused var warning
            stan::math::initialize(a_new, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 211;
            stan::math::assign(a_new, add(add(multiply(T,a),multiply(K,v)),c));
            current_statement_begin__ = 212;
            return stan::math::promote_scalar<fun_return_scalar_t__>(a_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_update_a_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& a,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,1>& c,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& T,
                        const Eigen::Matrix<T3__, Eigen::Dynamic,1>& v,
                        const Eigen::Matrix<T4__, Eigen::Dynamic,Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_filter_update_a(a, c, T, v, K, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
ssm_filter_update_P(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& P,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& T,
                        const Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic>& RQR,
                        const Eigen::Matrix<T4__, Eigen::Dynamic,Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  P_new(static_cast<Eigen::VectorXd::Index>(rows(P)),static_cast<Eigen::VectorXd::Index>(cols(P)));
            (void) P_new;  // dummy to suppress unused var warning
            stan::math::initialize(P_new, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 234;
            stan::math::assign(P_new, to_symmetric_matrix(add(multiply(multiply(T,P),transpose(subtract(T,multiply(K,Z)))),RQR), pstream__));
            current_statement_begin__ = 235;
            return stan::math::promote_scalar<fun_return_scalar_t__>(P_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_update_P_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& P,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& T,
                        const Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic>& RQR,
                        const Eigen::Matrix<T4__, Eigen::Dynamic,Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_filter_update_P(P, Z, T, RQR, K, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,1>
ssm_filter_update_v(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& y,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,1>& a,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,1>& d,
                        const Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic>& Z, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  v(static_cast<Eigen::VectorXd::Index>(num_elements(y)));
            (void) v;  // dummy to suppress unused var warning
            stan::math::initialize(v, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 256;
            stan::math::assign(v, subtract(subtract(y,multiply(Z,a)),d));
            current_statement_begin__ = 257;
            return stan::math::promote_scalar<fun_return_scalar_t__>(v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_update_v_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& y,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,1>& a,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,1>& d,
                        const Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic>& Z, std::ostream* pstream__) const {
        return ssm_filter_update_v(y, a, d, Z, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic,Eigen::Dynamic>
ssm_filter_update_F(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& P,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& H, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  F(static_cast<Eigen::VectorXd::Index>(rows(H)),static_cast<Eigen::VectorXd::Index>(cols(H)));
            (void) F;  // dummy to suppress unused var warning
            stan::math::initialize(F, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 276;
            stan::math::assign(F, add(quad_form(P,transpose(Z)),H));
            current_statement_begin__ = 277;
            return stan::math::promote_scalar<fun_return_scalar_t__>(F);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_update_F_functor__ {
    template <typename T0__, typename T1__, typename T2__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& P,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& H, std::ostream* pstream__) const {
        return ssm_filter_update_F(P, Z, H, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic,Eigen::Dynamic>
ssm_filter_update_Finv(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& P,
                           const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                           const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& H, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Finv(static_cast<Eigen::VectorXd::Index>(rows(H)),static_cast<Eigen::VectorXd::Index>(cols(H)));
            (void) Finv;  // dummy to suppress unused var warning
            stan::math::initialize(Finv, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 293;
            stan::math::assign(Finv, inverse(ssm_filter_update_F(P,Z,H, pstream__)));
            current_statement_begin__ = 294;
            return stan::math::promote_scalar<fun_return_scalar_t__>(Finv);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_update_Finv_functor__ {
    template <typename T0__, typename T1__, typename T2__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& P,
                           const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                           const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& H, std::ostream* pstream__) const {
        return ssm_filter_update_Finv(P, Z, H, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,Eigen::Dynamic>
ssm_filter_update_K(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& P,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& T,
                        const Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic>& Finv, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  K(static_cast<Eigen::VectorXd::Index>(cols(Z)),static_cast<Eigen::VectorXd::Index>(rows(Z)));
            (void) K;  // dummy to suppress unused var warning
            stan::math::initialize(K, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 314;
            stan::math::assign(K, multiply(multiply(multiply(T,P),transpose(Z)),Finv));
            current_statement_begin__ = 315;
            return stan::math::promote_scalar<fun_return_scalar_t__>(K);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_update_K_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& P,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& T,
                        const Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic>& Finv, std::ostream* pstream__) const {
        return ssm_filter_update_K(P, Z, T, Finv, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic,Eigen::Dynamic>
ssm_filter_update_L(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& T,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  L(static_cast<Eigen::VectorXd::Index>(rows(T)),static_cast<Eigen::VectorXd::Index>(cols(T)));
            (void) L;  // dummy to suppress unused var warning
            stan::math::initialize(L, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 333;
            stan::math::assign(L, subtract(T,multiply(K,Z)));
            current_statement_begin__ = 334;
            return stan::math::promote_scalar<fun_return_scalar_t__>(L);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_update_L_functor__ {
    template <typename T0__, typename T1__, typename T2__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& T,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_filter_update_L(Z, T, K, pstream__);
    }
};

template <typename T0__, typename T1__>
inline
typename boost::math::tools::promote_args<T0__, T1__>::type
ssm_filter_update_ll(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& v,
                         const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& Finv, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            fun_scalar_t__ ll;
            (void) ll;  // dummy to suppress unused var warning
            int p(0);
            (void) p;  // dummy to suppress unused var warning
            stan::math::initialize(ll, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 352;
            stan::math::assign(p, num_elements(v));
            current_statement_begin__ = 354;
            stan::math::assign(ll, (-(0.5) * (((p * log((2 * pi()))) - log_determinant(Finv)) + quad_form(Finv,v))));
            current_statement_begin__ = 359;
            return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_update_ll_functor__ {
    template <typename T0__, typename T1__>
    inline
    typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& v,
                         const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& Finv, std::ostream* pstream__) const {
        return ssm_filter_update_ll(v, Finv, pstream__);
    }
};

inline
std::vector<std::vector<int> >
ssm_filter_idx(const int& m,
                   const int& p, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<vector<int> > sz(6, (vector<int>(3, 0)));
            current_statement_begin__ = 391;
            stan::math::assign(get_base1_lhs(get_base1_lhs(sz,1,"sz",1),1,"sz",2), 1);
            current_statement_begin__ = 393;
            stan::math::assign(get_base1_lhs(get_base1_lhs(sz,2,"sz",1),1,"sz",2), p);
            current_statement_begin__ = 395;
            stan::math::assign(get_base1_lhs(get_base1_lhs(sz,3,"sz",1),1,"sz",2), symmat_size(p, pstream__));
            current_statement_begin__ = 397;
            stan::math::assign(get_base1_lhs(get_base1_lhs(sz,4,"sz",1),1,"sz",2), (m * p));
            current_statement_begin__ = 399;
            stan::math::assign(get_base1_lhs(get_base1_lhs(sz,5,"sz",1),1,"sz",2), m);
            current_statement_begin__ = 401;
            stan::math::assign(get_base1_lhs(get_base1_lhs(sz,6,"sz",1),1,"sz",2), symmat_size(m, pstream__));
            current_statement_begin__ = 403;
            stan::math::assign(get_base1_lhs(get_base1_lhs(sz,1,"sz",1),2,"sz",2), 1);
            current_statement_begin__ = 404;
            stan::math::assign(get_base1_lhs(get_base1_lhs(sz,1,"sz",1),3,"sz",2), ((get_base1(get_base1(sz,1,"sz",1),2,"sz",2) + get_base1(get_base1(sz,1,"sz",1),1,"sz",2)) - 1));
            current_statement_begin__ = 405;
            for (int i = 2; i <= 6; ++i) {
                current_statement_begin__ = 406;
                stan::math::assign(get_base1_lhs(get_base1_lhs(sz,i,"sz",1),2,"sz",2), (get_base1(get_base1(sz,(i - 1),"sz",1),3,"sz",2) + 1));
                current_statement_begin__ = 407;
                stan::math::assign(get_base1_lhs(get_base1_lhs(sz,i,"sz",1),3,"sz",2), ((get_base1(get_base1(sz,i,"sz",1),2,"sz",2) + get_base1(get_base1(sz,i,"sz",1),1,"sz",2)) - 1));
            }
            current_statement_begin__ = 409;
            return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_idx_functor__ {
        inline
    std::vector<std::vector<int> >
    operator()(const int& m,
                   const int& p, std::ostream* pstream__) const {
        return ssm_filter_idx(m, p, pstream__);
    }
};

inline
int
ssm_filter_size(const int& m,
                    const int& p, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            int sz(0);
            (void) sz;  // dummy to suppress unused var warning
            vector<vector<int> > idx(6, (vector<int>(3, 0)));
            current_statement_begin__ = 423;
            stan::math::assign(idx, ssm_filter_idx(m,p, pstream__));
            current_statement_begin__ = 424;
            stan::math::assign(sz, get_base1(get_base1(idx,6,"idx",1),3,"idx",2));
            current_statement_begin__ = 425;
            return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_size_functor__ {
        inline
    int
    operator()(const int& m,
                    const int& p, std::ostream* pstream__) const {
        return ssm_filter_size(m, p, pstream__);
    }
};

template <typename T0__>
inline
typename boost::math::tools::promote_args<T0__>::type
ssm_filter_get_loglik(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                          const int& m,
                          const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            fun_scalar_t__ y;
            (void) y;  // dummy to suppress unused var warning
            stan::math::initialize(y, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 439;
            stan::math::assign(y, get_base1(x,1,"x",1));
            current_statement_begin__ = 440;
            return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_get_loglik_functor__ {
    template <typename T0__>
    inline
    typename boost::math::tools::promote_args<T0__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                          const int& m,
                          const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_loglik(x, m, p, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
ssm_filter_get_v(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  y(static_cast<Eigen::VectorXd::Index>(p));
            (void) y;  // dummy to suppress unused var warning
            vector<vector<int> > idx(6, (vector<int>(3, 0)));
            stan::math::initialize(y, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 455;
            stan::math::assign(idx, ssm_filter_idx(m,p, pstream__));
            current_statement_begin__ = 456;
            stan::math::assign(y, segment(x,get_base1(get_base1(idx,2,"idx",1),2,"idx",2),get_base1(get_base1(idx,2,"idx",1),3,"idx",2)));
            current_statement_begin__ = 457;
            return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_get_v_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_v(x, m, p, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
ssm_filter_get_Finv(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                        const int& m,
                        const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  y(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
            (void) y;  // dummy to suppress unused var warning
            vector<vector<int> > idx(6, (vector<int>(3, 0)));
            stan::math::initialize(y, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 472;
            stan::math::assign(idx, ssm_filter_idx(m,p, pstream__));
            current_statement_begin__ = 473;
            stan::math::assign(y, vector_to_symmat(segment(x,get_base1(get_base1(idx,3,"idx",1),2,"idx",2),get_base1(get_base1(idx,3,"idx",1),3,"idx",2)),p, pstream__));
            current_statement_begin__ = 474;
            return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_get_Finv_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                        const int& m,
                        const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_Finv(x, m, p, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
ssm_filter_get_K(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  y(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(p));
            (void) y;  // dummy to suppress unused var warning
            vector<vector<int> > idx(6, (vector<int>(3, 0)));
            stan::math::initialize(y, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 489;
            stan::math::assign(idx, ssm_filter_idx(m,p, pstream__));
            current_statement_begin__ = 490;
            stan::math::assign(y, to_matrix_colwise(segment(x,get_base1(get_base1(idx,4,"idx",1),2,"idx",2),get_base1(get_base1(idx,4,"idx",1),3,"idx",2)),m,p, pstream__));
            current_statement_begin__ = 491;
            return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_get_K_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_K(x, m, p, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
ssm_filter_get_a(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  y(static_cast<Eigen::VectorXd::Index>(m));
            (void) y;  // dummy to suppress unused var warning
            vector<vector<int> > idx(6, (vector<int>(3, 0)));
            stan::math::initialize(y, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 506;
            stan::math::assign(idx, ssm_filter_idx(m,p, pstream__));
            current_statement_begin__ = 507;
            stan::math::assign(y, segment(x,get_base1(get_base1(idx,5,"idx",1),2,"idx",2),get_base1(get_base1(idx,5,"idx",1),3,"idx",2)));
            current_statement_begin__ = 508;
            return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_get_a_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_a(x, m, p, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
ssm_filter_get_P(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  y(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
            (void) y;  // dummy to suppress unused var warning
            vector<vector<int> > idx(6, (vector<int>(3, 0)));
            stan::math::initialize(y, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 523;
            stan::math::assign(idx, ssm_filter_idx(m,p, pstream__));
            current_statement_begin__ = 524;
            stan::math::assign(y, vector_to_symmat(segment(x,get_base1(get_base1(idx,6,"idx",1),2,"idx",2),get_base1(get_base1(idx,6,"idx",1),3,"idx",2)),m, pstream__));
            current_statement_begin__ = 525;
            return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_get_P_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_P(x, m, p, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
inline
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic,1> >
ssm_filter(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& y,
               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& d,
               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& H,
               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,1> >& c,
               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& T,
               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic> >& R,
               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic> >& Q,
               const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
               const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > res(size(y), (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(ssm_filter_size(get_base1(dims(Z),3,"dims(Z)",1),get_base1(dims(Z),2,"dims(Z)",1), pstream__)))));
            int q(0);
            (void) q;  // dummy to suppress unused var warning
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            int p(0);
            (void) p;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            stan::math::initialize(res, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 575;
            stan::math::assign(n, size(y));
            current_statement_begin__ = 576;
            stan::math::assign(p, get_base1(dims(Z),2,"dims(Z)",1));
            current_statement_begin__ = 577;
            stan::math::assign(m, get_base1(dims(Z),3,"dims(Z)",1));
            current_statement_begin__ = 578;
            stan::math::assign(q, get_base1(dims(Q),2,"dims(Q)",1));
            {
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  d_t(static_cast<Eigen::VectorXd::Index>(p));
                (void) d_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Z_t(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(m));
                (void) Z_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  H_t(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
                (void) H_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  c_t(static_cast<Eigen::VectorXd::Index>(m));
                (void) c_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  T_t(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) T_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  R_t(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(q));
                (void) R_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Q_t(static_cast<Eigen::VectorXd::Index>(q),static_cast<Eigen::VectorXd::Index>(q));
                (void) Q_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  RQR(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) RQR;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  a(static_cast<Eigen::VectorXd::Index>(m));
                (void) a;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  P(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) P;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  v(static_cast<Eigen::VectorXd::Index>(p));
                (void) v;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Finv(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
                (void) Finv;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  K(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(p));
                (void) K;  // dummy to suppress unused var warning
                fun_scalar_t__ ll;
                (void) ll;  // dummy to suppress unused var warning
                vector<vector<int> > idx(6, (vector<int>(3, 0)));
                stan::math::initialize(d_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Z_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(H_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(c_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(T_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(R_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Q_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(RQR, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(a, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(P, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(v, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Finv, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(K, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(ll, std::numeric_limits<double>::quiet_NaN());
                current_statement_begin__ = 600;
                stan::math::assign(idx, ssm_filter_idx(m,p, pstream__));
                current_statement_begin__ = 602;
                stan::math::assign(d_t, get_base1(d,1,"d",1));
                current_statement_begin__ = 603;
                stan::math::assign(Z_t, get_base1(Z,1,"Z",1));
                current_statement_begin__ = 604;
                stan::math::assign(H_t, get_base1(H,1,"H",1));
                current_statement_begin__ = 605;
                stan::math::assign(c_t, get_base1(c,1,"c",1));
                current_statement_begin__ = 606;
                stan::math::assign(T_t, get_base1(T,1,"T",1));
                current_statement_begin__ = 607;
                stan::math::assign(R_t, get_base1(R,1,"R",1));
                current_statement_begin__ = 608;
                stan::math::assign(Q_t, get_base1(Q,1,"Q",1));
                current_statement_begin__ = 609;
                stan::math::assign(RQR, quad_form(Q_t,R_t));
                current_statement_begin__ = 610;
                stan::math::assign(a, a1);
                current_statement_begin__ = 611;
                stan::math::assign(P, P1);
                current_statement_begin__ = 612;
                for (int t = 1; t <= n; ++t) {
                    current_statement_begin__ = 613;
                    if (as_bool(logical_gt(t,1))) {
                        current_statement_begin__ = 614;
                        if (as_bool(logical_gt(size(d),1))) {
                            current_statement_begin__ = 615;
                            stan::math::assign(d_t, get_base1(d,t,"d",1));
                        }
                        current_statement_begin__ = 617;
                        if (as_bool(logical_gt(size(Z),1))) {
                            current_statement_begin__ = 618;
                            stan::math::assign(Z_t, get_base1(Z,t,"Z",1));
                        }
                        current_statement_begin__ = 620;
                        if (as_bool(logical_gt(size(H),1))) {
                            current_statement_begin__ = 621;
                            stan::math::assign(H_t, get_base1(H,t,"H",1));
                        }
                        current_statement_begin__ = 623;
                        if (as_bool(logical_gt(size(c),1))) {
                            current_statement_begin__ = 624;
                            stan::math::assign(c_t, get_base1(c,t,"c",1));
                        }
                        current_statement_begin__ = 626;
                        if (as_bool(logical_gt(size(T),1))) {
                            current_statement_begin__ = 627;
                            stan::math::assign(T_t, get_base1(T,t,"T",1));
                        }
                        current_statement_begin__ = 629;
                        if (as_bool(logical_gt(size(R),1))) {
                            current_statement_begin__ = 630;
                            stan::math::assign(R_t, get_base1(R,t,"R",1));
                        }
                        current_statement_begin__ = 632;
                        if (as_bool(logical_gt(size(Q),1))) {
                            current_statement_begin__ = 633;
                            stan::math::assign(Q_t, get_base1(Q,t,"Q",1));
                        }
                        current_statement_begin__ = 635;
                        if (as_bool((primitive_value(logical_gt(size(R),1)) && primitive_value(logical_gt(size(Q),1))))) {
                            current_statement_begin__ = 636;
                            stan::math::assign(RQR, quad_form(Q_t,R_t));
                        }
                    }
                    current_statement_begin__ = 640;
                    stan::math::assign(v, ssm_filter_update_v(get_base1(y,t,"y",1),a,d_t,Z_t, pstream__));
                    current_statement_begin__ = 641;
                    stan::math::assign(Finv, ssm_filter_update_Finv(P,Z_t,H_t, pstream__));
                    current_statement_begin__ = 642;
                    stan::math::assign(K, ssm_filter_update_K(P,T_t,Z_t,Finv, pstream__));
                    current_statement_begin__ = 643;
                    stan::math::assign(ll, ssm_filter_update_ll(v,Finv, pstream__));
                    current_statement_begin__ = 645;
                    stan::math::assign(get_base1_lhs(get_base1_lhs(res,t,"res",1),1,"res",2), ll);
                    current_statement_begin__ = 646;
                    stan::model::assign(res, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx,2,"idx",1),2,"idx",2), get_base1(get_base1(idx,2,"idx",1),3,"idx",2)), stan::model::nil_index_list())), 
                                v, 
                                "assigning variable res");
                    current_statement_begin__ = 647;
                    stan::model::assign(res, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx,3,"idx",1),2,"idx",2), get_base1(get_base1(idx,3,"idx",1),3,"idx",2)), stan::model::nil_index_list())), 
                                symmat_to_vector(Finv, pstream__), 
                                "assigning variable res");
                    current_statement_begin__ = 648;
                    stan::model::assign(res, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx,4,"idx",1),2,"idx",2), get_base1(get_base1(idx,4,"idx",1),3,"idx",2)), stan::model::nil_index_list())), 
                                to_vector(K), 
                                "assigning variable res");
                    current_statement_begin__ = 649;
                    stan::model::assign(res, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx,5,"idx",1),2,"idx",2), get_base1(get_base1(idx,5,"idx",1),3,"idx",2)), stan::model::nil_index_list())), 
                                a, 
                                "assigning variable res");
                    current_statement_begin__ = 650;
                    stan::model::assign(res, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx,6,"idx",1),2,"idx",2), get_base1(get_base1(idx,6,"idx",1),3,"idx",2)), stan::model::nil_index_list())), 
                                symmat_to_vector(P, pstream__), 
                                "assigning variable res");
                    current_statement_begin__ = 652;
                    if (as_bool(logical_lt(t,n))) {
                        current_statement_begin__ = 653;
                        stan::math::assign(a, ssm_filter_update_a(a,c_t,T_t,v,K, pstream__));
                        current_statement_begin__ = 654;
                        stan::math::assign(P, ssm_filter_update_P(P,Z_t,T_t,RQR,K, pstream__));
                    }
                }
            }
            current_statement_begin__ = 658;
            return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
    inline
    std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic,1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& y,
               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& d,
               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& H,
               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,1> >& c,
               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& T,
               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic> >& R,
               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic> >& Q,
               const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
               const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};

inline
int
ssm_filter_states_size(const int& m, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            int sz(0);
            (void) sz;  // dummy to suppress unused var warning
            current_statement_begin__ = 674;
            stan::math::assign(sz, (m + symmat_size(m, pstream__)));
            current_statement_begin__ = 675;
            return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_states_size_functor__ {
        inline
    int
    operator()(const int& m, std::ostream* pstream__) const {
        return ssm_filter_states_size(m, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
ssm_filter_states_get_a(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                            const int& m, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  a(static_cast<Eigen::VectorXd::Index>(m));
            (void) a;  // dummy to suppress unused var warning
            stan::math::initialize(a, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 689;
            stan::math::assign(a, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_max(m), stan::model::nil_index_list()), "x"));
            current_statement_begin__ = 690;
            return stan::math::promote_scalar<fun_return_scalar_t__>(a);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_states_get_a_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                            const int& m, std::ostream* pstream__) const {
        return ssm_filter_states_get_a(x, m, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
ssm_filter_states_get_P(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                            const int& m, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  P(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
            (void) P;  // dummy to suppress unused var warning
            stan::math::initialize(P, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 704;
            stan::math::assign(P, vector_to_symmat(stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min((m + 1)), stan::model::nil_index_list()), "x"),m, pstream__));
            current_statement_begin__ = 705;
            return stan::math::promote_scalar<fun_return_scalar_t__>(P);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_states_get_P_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                            const int& m, std::ostream* pstream__) const {
        return ssm_filter_states_get_P(x, m, pstream__);
    }
};

template <typename T0__, typename T1__>
inline
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,1> >
ssm_filter_states(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& filter,
                      const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic> >& Z, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > res(size(filter), (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(ssm_filter_states_size(get_base1(dims(Z),3,"dims(Z)",1), pstream__)))));
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            int p(0);
            (void) p;  // dummy to suppress unused var warning
            stan::math::initialize(res, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 734;
            stan::math::assign(n, size(filter));
            current_statement_begin__ = 735;
            stan::math::assign(m, get_base1(dims(Z),3,"dims(Z)",1));
            current_statement_begin__ = 736;
            stan::math::assign(p, get_base1(dims(Z),2,"dims(Z)",1));
            {
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Z_t(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(m));
                (void) Z_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  aa(static_cast<Eigen::VectorXd::Index>(m));
                (void) aa;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  PP(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) PP;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  v(static_cast<Eigen::VectorXd::Index>(p));
                (void) v;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Finv(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
                (void) Finv;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  a(static_cast<Eigen::VectorXd::Index>(m));
                (void) a;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  P(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) P;  // dummy to suppress unused var warning
                stan::math::initialize(Z_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(aa, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(PP, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(v, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Finv, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(a, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(P, std::numeric_limits<double>::quiet_NaN());
                current_statement_begin__ = 748;
                stan::math::assign(Z_t, get_base1(Z,1,"Z",1));
                current_statement_begin__ = 749;
                for (int t = 1; t <= n; ++t) {
                    current_statement_begin__ = 750;
                    if (as_bool(logical_gt(t,1))) {
                        current_statement_begin__ = 751;
                        if (as_bool(logical_gt(size(Z),1))) {
                            current_statement_begin__ = 752;
                            stan::math::assign(Z_t, get_base1(Z,t,"Z",1));
                        }
                    }
                    current_statement_begin__ = 756;
                    stan::math::assign(v, ssm_filter_get_v(get_base1(filter,t,"filter",1),m,p, pstream__));
                    current_statement_begin__ = 757;
                    stan::math::assign(Finv, ssm_filter_get_Finv(get_base1(filter,t,"filter",1),m,p, pstream__));
                    current_statement_begin__ = 758;
                    stan::math::assign(a, ssm_filter_get_a(get_base1(filter,t,"filter",1),m,p, pstream__));
                    current_statement_begin__ = 759;
                    stan::math::assign(P, ssm_filter_get_P(get_base1(filter,t,"filter",1),m,p, pstream__));
                    current_statement_begin__ = 761;
                    stan::math::assign(aa, add(a,multiply(multiply(multiply(P,transpose(Z_t)),Finv),v)));
                    current_statement_begin__ = 762;
                    stan::math::assign(PP, to_symmetric_matrix(subtract(P,multiply(multiply(P,quad_form(Finv,Z_t)),P)), pstream__));
                    current_statement_begin__ = 764;
                    stan::model::assign(res, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_max(m), stan::model::nil_index_list())), 
                                aa, 
                                "assigning variable res");
                    current_statement_begin__ = 765;
                    stan::model::assign(res, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min((m + 1)), stan::model::nil_index_list())), 
                                symmat_to_vector(PP, pstream__), 
                                "assigning variable res");
                }
            }
            current_statement_begin__ = 768;
            return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_filter_states_functor__ {
    template <typename T0__, typename T1__>
    inline
    std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& filter,
                      const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic> >& Z, std::ostream* pstream__) const {
        return ssm_filter_states(filter, Z, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
inline
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            fun_scalar_t__ ll;
            (void) ll;  // dummy to suppress unused var warning
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            int p(0);
            (void) p;  // dummy to suppress unused var warning
            int q(0);
            (void) q;  // dummy to suppress unused var warning
            stan::math::initialize(ll, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 813;
            stan::math::assign(n, size(y));
            current_statement_begin__ = 814;
            stan::math::assign(m, get_base1(dims(Z),2,"dims(Z)",1));
            current_statement_begin__ = 815;
            stan::math::assign(p, get_base1(dims(Z),3,"dims(Z)",1));
            current_statement_begin__ = 816;
            stan::math::assign(q, get_base1(dims(Q),2,"dims(Q)",1));
            {
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  d_t(static_cast<Eigen::VectorXd::Index>(p));
                (void) d_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Z_t(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(m));
                (void) Z_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  H_t(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
                (void) H_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  c_t(static_cast<Eigen::VectorXd::Index>(m));
                (void) c_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  T_t(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) T_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  R_t(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(q));
                (void) R_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Q_t(static_cast<Eigen::VectorXd::Index>(q),static_cast<Eigen::VectorXd::Index>(q));
                (void) Q_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  RQR(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) RQR;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  ll_obs(static_cast<Eigen::VectorXd::Index>(n));
                (void) ll_obs;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  a(static_cast<Eigen::VectorXd::Index>(m));
                (void) a;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  P(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) P;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  v(static_cast<Eigen::VectorXd::Index>(p));
                (void) v;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Finv(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
                (void) Finv;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  K(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(p));
                (void) K;  // dummy to suppress unused var warning
                stan::math::initialize(d_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Z_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(H_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(c_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(T_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(R_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Q_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(RQR, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(ll_obs, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(a, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(P, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(v, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Finv, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(K, std::numeric_limits<double>::quiet_NaN());
                current_statement_begin__ = 835;
                stan::math::assign(d_t, get_base1(d,1,"d",1));
                current_statement_begin__ = 836;
                stan::math::assign(Z_t, get_base1(Z,1,"Z",1));
                current_statement_begin__ = 837;
                stan::math::assign(H_t, get_base1(H,1,"H",1));
                current_statement_begin__ = 838;
                stan::math::assign(c_t, get_base1(c,1,"c",1));
                current_statement_begin__ = 839;
                stan::math::assign(T_t, get_base1(T,1,"T",1));
                current_statement_begin__ = 840;
                stan::math::assign(R_t, get_base1(R,1,"R",1));
                current_statement_begin__ = 841;
                stan::math::assign(Q_t, get_base1(Q,1,"Q",1));
                current_statement_begin__ = 842;
                stan::math::assign(RQR, quad_form(Q_t,R_t));
                current_statement_begin__ = 844;
                stan::math::assign(a, a1);
                current_statement_begin__ = 845;
                stan::math::assign(P, P1);
                current_statement_begin__ = 846;
                for (int t = 1; t <= n; ++t) {
                    current_statement_begin__ = 847;
                    if (as_bool(logical_gt(t,1))) {
                        current_statement_begin__ = 848;
                        if (as_bool(logical_gt(size(d),1))) {
                            current_statement_begin__ = 849;
                            stan::math::assign(d_t, get_base1(d,t,"d",1));
                        }
                        current_statement_begin__ = 851;
                        if (as_bool(logical_gt(size(Z),1))) {
                            current_statement_begin__ = 852;
                            stan::math::assign(Z_t, get_base1(Z,t,"Z",1));
                        }
                        current_statement_begin__ = 854;
                        if (as_bool(logical_gt(size(H),1))) {
                            current_statement_begin__ = 855;
                            stan::math::assign(H_t, get_base1(H,t,"H",1));
                        }
                        current_statement_begin__ = 857;
                        if (as_bool(logical_gt(size(c),1))) {
                            current_statement_begin__ = 858;
                            stan::math::assign(c_t, get_base1(c,t,"c",1));
                        }
                        current_statement_begin__ = 860;
                        if (as_bool(logical_gt(size(T),1))) {
                            current_statement_begin__ = 861;
                            stan::math::assign(T_t, get_base1(T,t,"T",1));
                        }
                        current_statement_begin__ = 863;
                        if (as_bool(logical_gt(size(R),1))) {
                            current_statement_begin__ = 864;
                            stan::math::assign(R_t, get_base1(R,t,"R",1));
                        }
                        current_statement_begin__ = 866;
                        if (as_bool(logical_gt(size(Q),1))) {
                            current_statement_begin__ = 867;
                            stan::math::assign(Q_t, get_base1(Q,t,"Q",1));
                        }
                        current_statement_begin__ = 869;
                        if (as_bool((primitive_value(logical_gt(size(R),1)) && primitive_value(logical_gt(size(Q),1))))) {
                            current_statement_begin__ = 870;
                            stan::math::assign(RQR, quad_form(Q_t,R_t));
                        }
                    }
                    current_statement_begin__ = 873;
                    stan::math::assign(v, ssm_filter_update_v(get_base1(y,t,"y",1),a,d_t,Z_t, pstream__));
                    current_statement_begin__ = 874;
                    stan::math::assign(Finv, ssm_filter_update_Finv(P,Z_t,H_t, pstream__));
                    current_statement_begin__ = 875;
                    stan::math::assign(K, ssm_filter_update_K(P,Z_t,T_t,Finv, pstream__));
                    current_statement_begin__ = 876;
                    stan::math::assign(get_base1_lhs(ll_obs,t,"ll_obs",1), ssm_filter_update_ll(v,Finv, pstream__));
                    current_statement_begin__ = 878;
                    if (as_bool(logical_lt(t,n))) {
                        current_statement_begin__ = 879;
                        stan::math::assign(a, ssm_filter_update_a(a,c_t,T_t,v,K, pstream__));
                        current_statement_begin__ = 880;
                        stan::math::assign(P, ssm_filter_update_P(P,Z_t,T_t,RQR,K, pstream__));
                    }
                }
                current_statement_begin__ = 883;
                stan::math::assign(ll, sum(ll_obs));
            }
            current_statement_begin__ = 885;
            return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
inline
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, std::ostream* pstream__) {
    return ssm_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1, pstream__);
}


struct ssm_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
    inline
    typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
inline
int
ssm_check_matrix_equal(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& A,
                           const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& B,
                           const T2__& tol, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            fun_scalar_t__ eps;
            (void) eps;  // dummy to suppress unused var warning
            stan::math::initialize(eps, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 909;
            stan::math::assign(eps, (max(to_vector(subtract(A,B))) / max(to_vector(A))));
            current_statement_begin__ = 910;
            if (as_bool(logical_lt(eps,tol))) {
                current_statement_begin__ = 911;
                return stan::math::promote_scalar<fun_return_scalar_t__>(1);
            } else {
                current_statement_begin__ = 913;
                return stan::math::promote_scalar<fun_return_scalar_t__>(0);
            }
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_check_matrix_equal_functor__ {
    template <typename T0__, typename T1__, typename T2__>
    inline
    int
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& A,
                           const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& B,
                           const T2__& tol, std::ostream* pstream__) const {
        return ssm_check_matrix_equal(A, B, tol, pstream__);
    }
};

template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
inline
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_constant_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic,1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic,1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            fun_scalar_t__ ll;
            (void) ll;  // dummy to suppress unused var warning
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            int p(0);
            (void) p;  // dummy to suppress unused var warning
            stan::math::initialize(ll, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 948;
            stan::math::assign(n, size(y));
            current_statement_begin__ = 949;
            stan::math::assign(m, cols(Z));
            current_statement_begin__ = 950;
            stan::math::assign(p, rows(Z));
            {
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  ll_obs(static_cast<Eigen::VectorXd::Index>(n));
                (void) ll_obs;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  a(static_cast<Eigen::VectorXd::Index>(m));
                (void) a;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  P(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) P;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  v(static_cast<Eigen::VectorXd::Index>(p));
                (void) v;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Finv(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
                (void) Finv;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  K(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(p));
                (void) K;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  RQR(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) RQR;  // dummy to suppress unused var warning
                int converged(0);
                (void) converged;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  P_old(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) P_old;  // dummy to suppress unused var warning
                fun_scalar_t__ tol;
                (void) tol;  // dummy to suppress unused var warning
                stan::math::initialize(ll_obs, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(a, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(P, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(v, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Finv, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(K, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(RQR, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(P_old, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(tol, std::numeric_limits<double>::quiet_NaN());
                current_statement_begin__ = 964;
                stan::math::assign(converged, 0);
                current_statement_begin__ = 965;
                stan::math::assign(tol, 9.9999999999999995e-08);
                current_statement_begin__ = 967;
                stan::math::assign(RQR, quad_form(Q,R));
                current_statement_begin__ = 968;
                stan::math::assign(a, a1);
                current_statement_begin__ = 969;
                stan::math::assign(P, P1);
                current_statement_begin__ = 970;
                for (int t = 1; t <= n; ++t) {
                    current_statement_begin__ = 971;
                    stan::math::assign(v, ssm_filter_update_v(get_base1(y,t,"y",1),a,d,Z, pstream__));
                    current_statement_begin__ = 972;
                    if (as_bool(logical_lt(converged,1))) {
                        current_statement_begin__ = 973;
                        stan::math::assign(Finv, ssm_filter_update_Finv(P,Z,H, pstream__));
                        current_statement_begin__ = 974;
                        stan::math::assign(K, ssm_filter_update_K(P,Z,T,Finv, pstream__));
                    }
                    current_statement_begin__ = 976;
                    stan::math::assign(get_base1_lhs(ll_obs,t,"ll_obs",1), ssm_filter_update_ll(v,Finv, pstream__));
                    current_statement_begin__ = 978;
                    if (as_bool(logical_lt(t,n))) {
                        current_statement_begin__ = 979;
                        stan::math::assign(a, ssm_filter_update_a(a,c,T,v,K, pstream__));
                        current_statement_begin__ = 982;
                        if (as_bool(logical_lt(converged,1))) {
                            current_statement_begin__ = 983;
                            stan::math::assign(P_old, P);
                            current_statement_begin__ = 984;
                            stan::math::assign(P, ssm_filter_update_P(P,Z,T,RQR,K, pstream__));
                            current_statement_begin__ = 985;
                            stan::math::assign(converged, ssm_check_matrix_equal(P,P_old,tol, pstream__));
                        }
                    }
                }
                current_statement_begin__ = 989;
                stan::math::assign(ll, sum(ll_obs));
            }
            current_statement_begin__ = 991;
            return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
inline
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_constant_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic,1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic,1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, std::ostream* pstream__) {
    return ssm_constant_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1, pstream__);
}


struct ssm_constant_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
    inline
    typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic,1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic,1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_constant_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,1>
ssm_smooth_update_r(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& r,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,1>& v,
                        const Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic>& Finv,
                        const Eigen::Matrix<T4__, Eigen::Dynamic,Eigen::Dynamic>& L, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  r_new(static_cast<Eigen::VectorXd::Index>(num_elements(r)));
            (void) r_new;  // dummy to suppress unused var warning
            stan::math::initialize(r_new, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1020;
            stan::math::assign(r_new, add(multiply(multiply(transpose(Z),Finv),v),multiply(transpose(L),r)));
            current_statement_begin__ = 1021;
            return stan::math::promote_scalar<fun_return_scalar_t__>(r_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_update_r_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& r,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,1>& v,
                        const Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic>& Finv,
                        const Eigen::Matrix<T4__, Eigen::Dynamic,Eigen::Dynamic>& L, std::ostream* pstream__) const {
        return ssm_smooth_update_r(r, Z, v, Finv, L, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,Eigen::Dynamic>
ssm_smooth_update_N(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& N,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& Finv,
                        const Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic>& L, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  N_new(static_cast<Eigen::VectorXd::Index>(rows(N)),static_cast<Eigen::VectorXd::Index>(cols(N)));
            (void) N_new;  // dummy to suppress unused var warning
            stan::math::initialize(N_new, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1042;
            stan::math::assign(N_new, add(quad_form(Finv,Z),quad_form(N,L)));
            current_statement_begin__ = 1043;
            return stan::math::promote_scalar<fun_return_scalar_t__>(N_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_update_N_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& N,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& Z,
                        const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& Finv,
                        const Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic>& L, std::ostream* pstream__) const {
        return ssm_smooth_update_N(N, Z, Finv, L, pstream__);
    }
};

inline
int
ssm_smooth_state_size(const int& m, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            int sz(0);
            (void) sz;  // dummy to suppress unused var warning
            current_statement_begin__ = 1061;
            stan::math::assign(sz, (m + symmat_size(m, pstream__)));
            current_statement_begin__ = 1062;
            return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_state_size_functor__ {
        inline
    int
    operator()(const int& m, std::ostream* pstream__) const {
        return ssm_smooth_state_size(m, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
ssm_smooth_state_get_mean(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                              const int& m, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(m));
            (void) alpha;  // dummy to suppress unused var warning
            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1074;
            stan::math::assign(alpha, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_max(m), stan::model::nil_index_list()), "x"));
            current_statement_begin__ = 1075;
            return stan::math::promote_scalar<fun_return_scalar_t__>(alpha);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_state_get_mean_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                              const int& m, std::ostream* pstream__) const {
        return ssm_smooth_state_get_mean(x, m, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
ssm_smooth_state_get_var(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                             const int& m, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  V(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
            (void) V;  // dummy to suppress unused var warning
            stan::math::initialize(V, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1087;
            stan::math::assign(V, vector_to_symmat(stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min((m + 1)), stan::model::nil_index_list()), "x"),m, pstream__));
            current_statement_begin__ = 1088;
            return stan::math::promote_scalar<fun_return_scalar_t__>(V);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_state_get_var_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                             const int& m, std::ostream* pstream__) const {
        return ssm_smooth_state_get_var(x, m, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
inline
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic,1> >
ssm_smooth_state(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& filter,
                     const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                     const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& T, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > res(size(filter), (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(ssm_smooth_state_size(get_base1(dims(Z),3,"dims(Z)",1), pstream__)))));
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            int p(0);
            (void) p;  // dummy to suppress unused var warning
            stan::math::initialize(res, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1125;
            stan::math::assign(n, size(filter));
            current_statement_begin__ = 1126;
            stan::math::assign(m, get_base1(dims(Z),3,"dims(Z)",1));
            current_statement_begin__ = 1127;
            stan::math::assign(p, get_base1(dims(Z),2,"dims(Z)",1));
            {
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Z_t(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(m));
                (void) Z_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  T_t(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) T_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  r(static_cast<Eigen::VectorXd::Index>(m));
                (void) r;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  N(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) N;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  L(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) L;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  alpha(static_cast<Eigen::VectorXd::Index>(m));
                (void) alpha;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  V(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) V;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  v(static_cast<Eigen::VectorXd::Index>(p));
                (void) v;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  K(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(p));
                (void) K;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Finv(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
                (void) Finv;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  a(static_cast<Eigen::VectorXd::Index>(m));
                (void) a;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  P(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) P;  // dummy to suppress unused var warning
                stan::math::initialize(Z_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(T_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(r, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(N, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(L, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(V, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(v, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(K, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Finv, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(a, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(P, std::numeric_limits<double>::quiet_NaN());
                current_statement_begin__ = 1145;
                if (as_bool(logical_eq(size(Z),1))) {
                    current_statement_begin__ = 1146;
                    stan::math::assign(Z_t, get_base1(Z,1,"Z",1));
                }
                current_statement_begin__ = 1148;
                if (as_bool(logical_eq(size(T),1))) {
                    current_statement_begin__ = 1149;
                    stan::math::assign(T_t, get_base1(T,1,"T",1));
                }
                current_statement_begin__ = 1154;
                stan::math::assign(r, rep_vector(0.0,m));
                current_statement_begin__ = 1155;
                stan::math::assign(N, rep_matrix(0.0,m,m));
                current_statement_begin__ = 1157;
                for (int i = 0; i <= (n - 1); ++i) {
                    {
                        int t(0);
                        (void) t;  // dummy to suppress unused var warning
                        current_statement_begin__ = 1159;
                        stan::math::assign(t, (n - i));
                        current_statement_begin__ = 1161;
                        if (as_bool(logical_gt(size(Z),1))) {
                            current_statement_begin__ = 1162;
                            stan::math::assign(Z_t, get_base1(Z,t,"Z",1));
                        }
                        current_statement_begin__ = 1164;
                        if (as_bool(logical_gt(size(T),1))) {
                            current_statement_begin__ = 1165;
                            stan::math::assign(T_t, get_base1(T,t,"T",1));
                        }
                        current_statement_begin__ = 1168;
                        stan::math::assign(K, ssm_filter_get_K(get_base1(filter,t,"filter",1),m,p, pstream__));
                        current_statement_begin__ = 1169;
                        stan::math::assign(v, ssm_filter_get_v(get_base1(filter,t,"filter",1),m,p, pstream__));
                        current_statement_begin__ = 1170;
                        stan::math::assign(Finv, ssm_filter_get_Finv(get_base1(filter,t,"filter",1),m,p, pstream__));
                        current_statement_begin__ = 1171;
                        stan::math::assign(a, ssm_filter_get_a(get_base1(filter,t,"filter",1),m,p, pstream__));
                        current_statement_begin__ = 1172;
                        stan::math::assign(P, ssm_filter_get_P(get_base1(filter,t,"filter",1),m,p, pstream__));
                        current_statement_begin__ = 1175;
                        stan::math::assign(L, ssm_filter_update_L(Z_t,T_t,K, pstream__));
                        current_statement_begin__ = 1177;
                        stan::math::assign(r, ssm_smooth_update_r(r,Z_t,v,Finv,L, pstream__));
                        current_statement_begin__ = 1178;
                        stan::math::assign(N, ssm_smooth_update_N(N,Z_t,Finv,L, pstream__));
                        current_statement_begin__ = 1180;
                        stan::math::assign(alpha, add(a,multiply(P,r)));
                        current_statement_begin__ = 1181;
                        stan::math::assign(V, to_symmetric_matrix(subtract(P,multiply(multiply(P,N),P)), pstream__));
                        current_statement_begin__ = 1183;
                        stan::model::assign(res, 
                                    stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_max(m), stan::model::nil_index_list())), 
                                    alpha, 
                                    "assigning variable res");
                        current_statement_begin__ = 1184;
                        stan::model::assign(res, 
                                    stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min((m + 1)), stan::model::nil_index_list())), 
                                    symmat_to_vector(V, pstream__), 
                                    "assigning variable res");
                    }
                }
            }
            current_statement_begin__ = 1187;
            return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_state_functor__ {
    template <typename T0__, typename T1__, typename T2__>
    inline
    std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic,1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& filter,
                     const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                     const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& T, std::ostream* pstream__) const {
        return ssm_smooth_state(filter, Z, T, pstream__);
    }
};

inline
int
ssm_smooth_eps_size(const int& p, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            int sz(0);
            (void) sz;  // dummy to suppress unused var warning
            current_statement_begin__ = 1200;
            stan::math::assign(sz, (p + symmat_size(p, pstream__)));
            current_statement_begin__ = 1201;
            return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_eps_size_functor__ {
        inline
    int
    operator()(const int& p, std::ostream* pstream__) const {
        return ssm_smooth_eps_size(p, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
ssm_smooth_eps_get_mean(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                            const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  eps(static_cast<Eigen::VectorXd::Index>(p));
            (void) eps;  // dummy to suppress unused var warning
            stan::math::initialize(eps, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1213;
            stan::math::assign(eps, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_max(p), stan::model::nil_index_list()), "x"));
            current_statement_begin__ = 1214;
            return stan::math::promote_scalar<fun_return_scalar_t__>(eps);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_eps_get_mean_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                            const int& p, std::ostream* pstream__) const {
        return ssm_smooth_eps_get_mean(x, p, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
ssm_smooth_eps_get_var(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                           const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  eps_var(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
            (void) eps_var;  // dummy to suppress unused var warning
            stan::math::initialize(eps_var, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1227;
            stan::math::assign(eps_var, vector_to_symmat(stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min((p + 1)), stan::model::nil_index_list()), "x"),p, pstream__));
            current_statement_begin__ = 1228;
            return stan::math::promote_scalar<fun_return_scalar_t__>(eps_var);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_eps_get_var_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                           const int& p, std::ostream* pstream__) const {
        return ssm_smooth_eps_get_var(x, p, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
inline
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,1> >
ssm_smooth_eps(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& filter,
                   const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                   const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& H,
                   const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& T, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > res(size(filter), (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(ssm_smooth_eps_size(get_base1(dims(Z),2,"dims(Z)",1), pstream__)))));
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            int p(0);
            (void) p;  // dummy to suppress unused var warning
            stan::math::initialize(res, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1268;
            stan::math::assign(n, size(filter));
            current_statement_begin__ = 1269;
            stan::math::assign(m, get_base1(dims(Z),3,"dims(Z)",1));
            current_statement_begin__ = 1270;
            stan::math::assign(p, get_base1(dims(Z),2,"dims(Z)",1));
            {
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  r(static_cast<Eigen::VectorXd::Index>(m));
                (void) r;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  N(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) N;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  L(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) L;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  eps(static_cast<Eigen::VectorXd::Index>(p));
                (void) eps;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  var_eps(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
                (void) var_eps;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  v(static_cast<Eigen::VectorXd::Index>(p));
                (void) v;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  K(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(p));
                (void) K;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Finv(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
                (void) Finv;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Z_t(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(m));
                (void) Z_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  H_t(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
                (void) H_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  T_t(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) T_t;  // dummy to suppress unused var warning
                stan::math::initialize(r, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(N, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(L, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(eps, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(var_eps, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(v, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(K, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Finv, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Z_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(H_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(T_t, std::numeric_limits<double>::quiet_NaN());
                current_statement_begin__ = 1288;
                if (as_bool(logical_eq(size(Z),1))) {
                    current_statement_begin__ = 1289;
                    stan::math::assign(Z_t, get_base1(Z,1,"Z",1));
                }
                current_statement_begin__ = 1291;
                if (as_bool(logical_eq(size(H),1))) {
                    current_statement_begin__ = 1292;
                    stan::math::assign(H_t, get_base1(H,1,"H",1));
                }
                current_statement_begin__ = 1294;
                if (as_bool(logical_eq(size(T),1))) {
                    current_statement_begin__ = 1295;
                    stan::math::assign(T_t, get_base1(T,1,"T",1));
                }
                current_statement_begin__ = 1300;
                stan::math::assign(r, rep_vector(0.0,m));
                current_statement_begin__ = 1301;
                stan::math::assign(N, rep_matrix(0.0,m,m));
                current_statement_begin__ = 1302;
                for (int i = 1; i <= n; ++i) {
                    {
                        int t(0);
                        (void) t;  // dummy to suppress unused var warning
                        current_statement_begin__ = 1305;
                        stan::math::assign(t, ((n - i) + 1));
                        current_statement_begin__ = 1307;
                        if (as_bool(logical_gt(size(Z),1))) {
                            current_statement_begin__ = 1308;
                            stan::math::assign(Z_t, get_base1(Z,t,"Z",1));
                        }
                        current_statement_begin__ = 1310;
                        if (as_bool(logical_gt(size(H),1))) {
                            current_statement_begin__ = 1311;
                            stan::math::assign(H_t, get_base1(H,t,"H",1));
                        }
                        current_statement_begin__ = 1313;
                        if (as_bool(logical_gt(size(T),1))) {
                            current_statement_begin__ = 1314;
                            stan::math::assign(T_t, get_base1(T,t,"T",1));
                        }
                        current_statement_begin__ = 1317;
                        stan::math::assign(K, ssm_filter_get_K(get_base1(filter,t,"filter",1),m,p, pstream__));
                        current_statement_begin__ = 1318;
                        stan::math::assign(v, ssm_filter_get_v(get_base1(filter,t,"filter",1),m,p, pstream__));
                        current_statement_begin__ = 1319;
                        stan::math::assign(Finv, ssm_filter_get_Finv(get_base1(filter,t,"filter",1),m,p, pstream__));
                        current_statement_begin__ = 1321;
                        stan::math::assign(L, ssm_filter_update_L(Z_t,T_t,K, pstream__));
                        current_statement_begin__ = 1323;
                        stan::math::assign(r, ssm_smooth_update_r(r,Z_t,v,Finv,L, pstream__));
                        current_statement_begin__ = 1324;
                        stan::math::assign(N, ssm_smooth_update_N(N,Z_t,Finv,L, pstream__));
                        current_statement_begin__ = 1326;
                        stan::math::assign(eps, multiply(H_t,subtract(multiply(Finv,v),multiply(transpose(K),r))));
                        current_statement_begin__ = 1327;
                        stan::math::assign(var_eps, to_symmetric_matrix(subtract(H_t,multiply(multiply(H_t,add(Finv,quad_form(N,K))),H_t)), pstream__));
                        current_statement_begin__ = 1329;
                        stan::model::assign(res, 
                                    stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_max(p), stan::model::nil_index_list())), 
                                    eps, 
                                    "assigning variable res");
                        current_statement_begin__ = 1330;
                        stan::model::assign(res, 
                                    stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min((p + 1)), stan::model::nil_index_list())), 
                                    symmat_to_vector(var_eps, pstream__), 
                                    "assigning variable res");
                    }
                }
            }
            current_statement_begin__ = 1333;
            return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_eps_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
    inline
    std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& filter,
                   const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                   const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& H,
                   const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& T, std::ostream* pstream__) const {
        return ssm_smooth_eps(filter, Z, H, T, pstream__);
    }
};

inline
int
ssm_smooth_eta_size(const int& q, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            int sz(0);
            (void) sz;  // dummy to suppress unused var warning
            current_statement_begin__ = 1345;
            stan::math::assign(sz, (q + symmat_size(q, pstream__)));
            current_statement_begin__ = 1346;
            return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_eta_size_functor__ {
        inline
    int
    operator()(const int& q, std::ostream* pstream__) const {
        return ssm_smooth_eta_size(q, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
ssm_smooth_eta_get_mean(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                            const int& q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  eta(static_cast<Eigen::VectorXd::Index>(q));
            (void) eta;  // dummy to suppress unused var warning
            stan::math::initialize(eta, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1358;
            stan::math::assign(eta, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_max(q), stan::model::nil_index_list()), "x"));
            current_statement_begin__ = 1359;
            return stan::math::promote_scalar<fun_return_scalar_t__>(eta);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_eta_get_mean_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                            const int& q, std::ostream* pstream__) const {
        return ssm_smooth_eta_get_mean(x, q, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
ssm_smooth_eta_get_var(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                           const int& q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  eta_var(static_cast<Eigen::VectorXd::Index>(q),static_cast<Eigen::VectorXd::Index>(q));
            (void) eta_var;  // dummy to suppress unused var warning
            stan::math::initialize(eta_var, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1372;
            stan::math::assign(eta_var, vector_to_symmat(stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min((q + 1)), stan::model::nil_index_list()), "x"),q, pstream__));
            current_statement_begin__ = 1373;
            return stan::math::promote_scalar<fun_return_scalar_t__>(eta_var);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_eta_get_var_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                           const int& q, std::ostream* pstream__) const {
        return ssm_smooth_eta_get_var(x, q, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
inline
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,1> >
ssm_smooth_eta(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& filter,
                   const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                   const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& T,
                   const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& R,
                   const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,Eigen::Dynamic> >& Q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > res(size(filter), (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(ssm_smooth_eta_size(get_base1(dims(Q),2,"dims(Q)",1), pstream__)))));
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            int p(0);
            (void) p;  // dummy to suppress unused var warning
            int q(0);
            (void) q;  // dummy to suppress unused var warning
            stan::math::initialize(res, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1415;
            stan::math::assign(n, size(filter));
            current_statement_begin__ = 1416;
            stan::math::assign(m, get_base1(dims(Z),3,"dims(Z)",1));
            current_statement_begin__ = 1417;
            stan::math::assign(p, get_base1(dims(Z),2,"dims(Z)",1));
            current_statement_begin__ = 1418;
            stan::math::assign(q, get_base1(dims(Q),2,"dims(Q)",1));
            {
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  r(static_cast<Eigen::VectorXd::Index>(m));
                (void) r;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  N(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) N;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  L(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) L;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  eta(static_cast<Eigen::VectorXd::Index>(q));
                (void) eta;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  var_eta(static_cast<Eigen::VectorXd::Index>(q),static_cast<Eigen::VectorXd::Index>(q));
                (void) var_eta;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Z_t(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(m));
                (void) Z_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  T_t(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) T_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  R_t(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(q));
                (void) R_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Q_t(static_cast<Eigen::VectorXd::Index>(q),static_cast<Eigen::VectorXd::Index>(q));
                (void) Q_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  v(static_cast<Eigen::VectorXd::Index>(p));
                (void) v;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  K(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(p));
                (void) K;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Finv(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
                (void) Finv;  // dummy to suppress unused var warning
                stan::math::initialize(r, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(N, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(L, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(eta, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(var_eta, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Z_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(T_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(R_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Q_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(v, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(K, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Finv, std::numeric_limits<double>::quiet_NaN());
                current_statement_begin__ = 1437;
                if (as_bool(logical_eq(size(Z),1))) {
                    current_statement_begin__ = 1438;
                    stan::math::assign(Z_t, get_base1(Z,1,"Z",1));
                }
                current_statement_begin__ = 1440;
                if (as_bool(logical_eq(size(T),1))) {
                    current_statement_begin__ = 1441;
                    stan::math::assign(T_t, get_base1(T,1,"T",1));
                }
                current_statement_begin__ = 1443;
                if (as_bool(logical_eq(size(R),1))) {
                    current_statement_begin__ = 1444;
                    stan::math::assign(R_t, get_base1(R,1,"R",1));
                }
                current_statement_begin__ = 1446;
                if (as_bool(logical_eq(size(Q),1))) {
                    current_statement_begin__ = 1447;
                    stan::math::assign(Q_t, get_base1(Q,1,"Q",1));
                }
                current_statement_begin__ = 1450;
                stan::math::assign(r, rep_vector(0.0,m));
                current_statement_begin__ = 1451;
                stan::math::assign(N, rep_matrix(0.0,m,m));
                current_statement_begin__ = 1452;
                for (int i = 0; i <= (n - 1); ++i) {
                    {
                        int t(0);
                        (void) t;  // dummy to suppress unused var warning
                        current_statement_begin__ = 1455;
                        stan::math::assign(t, (n - i));
                        current_statement_begin__ = 1457;
                        if (as_bool(logical_gt(size(Z),1))) {
                            current_statement_begin__ = 1458;
                            stan::math::assign(Z_t, get_base1(Z,t,"Z",1));
                        }
                        current_statement_begin__ = 1460;
                        if (as_bool(logical_gt(size(T),1))) {
                            current_statement_begin__ = 1461;
                            stan::math::assign(T_t, get_base1(T,t,"T",1));
                        }
                        current_statement_begin__ = 1463;
                        if (as_bool(logical_gt(size(R),1))) {
                            current_statement_begin__ = 1464;
                            stan::math::assign(R_t, get_base1(R,t,"R",1));
                        }
                        current_statement_begin__ = 1466;
                        if (as_bool(logical_gt(size(Q),1))) {
                            current_statement_begin__ = 1467;
                            stan::math::assign(Q_t, get_base1(Q,t,"Q",1));
                        }
                        current_statement_begin__ = 1470;
                        stan::math::assign(K, ssm_filter_get_K(get_base1(filter,t,"filter",1),m,p, pstream__));
                        current_statement_begin__ = 1471;
                        stan::math::assign(v, ssm_filter_get_v(get_base1(filter,t,"filter",1),m,p, pstream__));
                        current_statement_begin__ = 1472;
                        stan::math::assign(Finv, ssm_filter_get_Finv(get_base1(filter,t,"filter",1),m,p, pstream__));
                        current_statement_begin__ = 1474;
                        stan::math::assign(L, ssm_filter_update_L(Z_t,T_t,K, pstream__));
                        current_statement_begin__ = 1475;
                        stan::math::assign(r, ssm_smooth_update_r(r,Z_t,v,Finv,L, pstream__));
                        current_statement_begin__ = 1476;
                        stan::math::assign(N, ssm_smooth_update_N(N,Z_t,Finv,L, pstream__));
                        current_statement_begin__ = 1477;
                        stan::math::assign(eta, multiply(multiply(Q_t,transpose(R_t)),r));
                        current_statement_begin__ = 1478;
                        stan::math::assign(var_eta, to_symmetric_matrix(subtract(Q_t,multiply(multiply(Q_t,quad_form(N,R_t)),Q_t)), pstream__));
                        current_statement_begin__ = 1480;
                        stan::model::assign(res, 
                                    stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_max(q), stan::model::nil_index_list())), 
                                    eta, 
                                    "assigning variable res");
                        current_statement_begin__ = 1481;
                        stan::model::assign(res, 
                                    stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min((q + 1)), stan::model::nil_index_list())), 
                                    symmat_to_vector(var_eta, pstream__), 
                                    "assigning variable res");
                    }
                }
            }
            current_statement_begin__ = 1484;
            return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_eta_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
    inline
    std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic,1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& filter,
                   const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                   const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& T,
                   const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& R,
                   const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,Eigen::Dynamic> >& Q, std::ostream* pstream__) const {
        return ssm_smooth_eta(filter, Z, T, R, Q, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
inline
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type, Eigen::Dynamic,1> >
ssm_smooth_faststate(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& filter,
                         const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& c,
                         const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                         const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& T,
                         const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,Eigen::Dynamic> >& R,
                         const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& Q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > alpha(size(filter), (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(get_base1(dims(Z),3,"dims(Z)",1)))));
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            int p(0);
            (void) p;  // dummy to suppress unused var warning
            int q(0);
            (void) q;  // dummy to suppress unused var warning
            stan::math::initialize(alpha, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1521;
            stan::math::assign(n, size(filter));
            current_statement_begin__ = 1522;
            stan::math::assign(m, get_base1(dims(Z),3,"dims(Z)",1));
            current_statement_begin__ = 1523;
            stan::math::assign(p, get_base1(dims(Z),2,"dims(Z)",1));
            current_statement_begin__ = 1524;
            stan::math::assign(q, get_base1(dims(Q),2,"dims(Q)",1));
            {
                vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > r((n + 1), (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(m))));
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  L(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) L;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  a1(static_cast<Eigen::VectorXd::Index>(m));
                (void) a1;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  P1(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) P1;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  v(static_cast<Eigen::VectorXd::Index>(p));
                (void) v;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  K(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(p));
                (void) K;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Finv(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
                (void) Finv;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Z_t(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(m));
                (void) Z_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  c_t(static_cast<Eigen::VectorXd::Index>(m));
                (void) c_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  T_t(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) T_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  R_t(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(q));
                (void) R_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Q_t(static_cast<Eigen::VectorXd::Index>(q),static_cast<Eigen::VectorXd::Index>(q));
                (void) Q_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  RQR(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) RQR;  // dummy to suppress unused var warning
                stan::math::initialize(r, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(L, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(a1, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(P1, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(v, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(K, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Finv, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Z_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(c_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(T_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(R_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Q_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(RQR, std::numeric_limits<double>::quiet_NaN());
                current_statement_begin__ = 1543;
                if (as_bool(logical_eq(size(c),1))) {
                    current_statement_begin__ = 1544;
                    stan::math::assign(c_t, get_base1(c,1,"c",1));
                }
                current_statement_begin__ = 1546;
                if (as_bool(logical_eq(size(Z),1))) {
                    current_statement_begin__ = 1547;
                    stan::math::assign(Z_t, get_base1(Z,1,"Z",1));
                }
                current_statement_begin__ = 1549;
                if (as_bool(logical_eq(size(T),1))) {
                    current_statement_begin__ = 1550;
                    stan::math::assign(T_t, get_base1(T,1,"T",1));
                }
                current_statement_begin__ = 1552;
                if (as_bool(logical_eq(size(R),1))) {
                    current_statement_begin__ = 1553;
                    stan::math::assign(R_t, get_base1(R,1,"R",1));
                }
                current_statement_begin__ = 1555;
                if (as_bool(logical_eq(size(Q),1))) {
                    current_statement_begin__ = 1556;
                    stan::math::assign(Q_t, get_base1(Q,1,"Q",1));
                }
                current_statement_begin__ = 1558;
                if (as_bool((primitive_value(logical_eq(size(Q),1)) && primitive_value(logical_eq(size(R),1))))) {
                    current_statement_begin__ = 1559;
                    stan::math::assign(RQR, quad_form(get_base1(Q,1,"Q",1),transpose(get_base1(R,1,"R",1))));
                }
                current_statement_begin__ = 1568;
                stan::math::assign(get_base1_lhs(r,(n + 1),"r",1), rep_vector(0.0,m));
                current_statement_begin__ = 1569;
                for (int i = 0; i <= (n - 1); ++i) {
                    {
                        int t(0);
                        (void) t;  // dummy to suppress unused var warning
                        current_statement_begin__ = 1572;
                        stan::math::assign(t, (n - i));
                        current_statement_begin__ = 1574;
                        if (as_bool(logical_gt(size(Z),1))) {
                            current_statement_begin__ = 1575;
                            stan::math::assign(Z_t, get_base1(Z,t,"Z",1));
                        }
                        current_statement_begin__ = 1577;
                        if (as_bool(logical_gt(size(T),1))) {
                            current_statement_begin__ = 1578;
                            stan::math::assign(T_t, get_base1(T,t,"T",1));
                        }
                        current_statement_begin__ = 1581;
                        stan::math::assign(K, ssm_filter_get_K(get_base1(filter,t,"filter",1),m,p, pstream__));
                        current_statement_begin__ = 1582;
                        stan::math::assign(v, ssm_filter_get_v(get_base1(filter,t,"filter",1),m,p, pstream__));
                        current_statement_begin__ = 1583;
                        stan::math::assign(Finv, ssm_filter_get_Finv(get_base1(filter,t,"filter",1),m,p, pstream__));
                        current_statement_begin__ = 1585;
                        stan::math::assign(L, ssm_filter_update_L(Z_t,T_t,K, pstream__));
                        current_statement_begin__ = 1587;
                        stan::math::assign(get_base1_lhs(r,t,"r",1), ssm_smooth_update_r(get_base1(r,(t + 1),"r",1),Z_t,v,Finv,L, pstream__));
                    }
                }
                current_statement_begin__ = 1590;
                stan::math::assign(a1, ssm_filter_get_a(get_base1(filter,1,"filter",1),m,p, pstream__));
                current_statement_begin__ = 1591;
                stan::math::assign(P1, ssm_filter_get_P(get_base1(filter,1,"filter",1),m,p, pstream__));
                current_statement_begin__ = 1593;
                stan::math::assign(get_base1_lhs(alpha,1,"alpha",1), add(a1,multiply(P1,get_base1(r,1,"r",1))));
                current_statement_begin__ = 1595;
                for (int t = 1; t <= (n - 1); ++t) {
                    current_statement_begin__ = 1596;
                    if (as_bool(logical_gt(size(c),1))) {
                        current_statement_begin__ = 1597;
                        stan::math::assign(c_t, get_base1(c,t,"c",1));
                    }
                    current_statement_begin__ = 1599;
                    if (as_bool(logical_gt(size(T),1))) {
                        current_statement_begin__ = 1600;
                        stan::math::assign(T_t, get_base1(T,t,"T",1));
                    }
                    current_statement_begin__ = 1602;
                    if (as_bool(logical_gt(size(Q),1))) {
                        current_statement_begin__ = 1603;
                        stan::math::assign(Q_t, get_base1(Q,t,"Q",1));
                    }
                    current_statement_begin__ = 1605;
                    if (as_bool(logical_gt(size(R),1))) {
                        current_statement_begin__ = 1606;
                        stan::math::assign(R_t, get_base1(R,t,"R",1));
                    }
                    current_statement_begin__ = 1608;
                    if (as_bool((primitive_value(logical_gt(size(Q),1)) || primitive_value(logical_gt(size(R),1))))) {
                        current_statement_begin__ = 1609;
                        stan::math::assign(RQR, quad_form(Q_t,transpose(R_t)));
                    }
                    current_statement_begin__ = 1613;
                    stan::math::assign(get_base1_lhs(alpha,(t + 1),"alpha",1), add(add(c_t,multiply(T_t,get_base1(alpha,t,"alpha",1))),multiply(RQR,get_base1(r,(t + 1),"r",1))));
                }
            }
            current_statement_begin__ = 1616;
            return stan::math::promote_scalar<fun_return_scalar_t__>(alpha);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_smooth_faststate_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
    inline
    std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type, Eigen::Dynamic,1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& filter,
                         const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& c,
                         const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                         const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& T,
                         const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,Eigen::Dynamic> >& R,
                         const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& Q, std::ostream* pstream__) const {
        return ssm_smooth_faststate(filter, c, Z, T, R, Q, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
pacf_to_acf(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  y(static_cast<Eigen::VectorXd::Index>(num_elements(x)),static_cast<Eigen::VectorXd::Index>(num_elements(x)));
            (void) y;  // dummy to suppress unused var warning
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            stan::math::initialize(y, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1634;
            stan::math::assign(n, num_elements(x));
            current_statement_begin__ = 1635;
            stan::math::assign(y, rep_matrix(0.0,n,n));
            current_statement_begin__ = 1636;
            for (int k = 1; k <= n; ++k) {
                current_statement_begin__ = 1637;
                for (int i = 1; i <= (k - 1); ++i) {
                    current_statement_begin__ = 1638;
                    stan::math::assign(get_base1_lhs(y,k,i,"y",1), (get_base1(y,(k - 1),i,"y",1) + (get_base1(x,k,"x",1) * get_base1(y,(k - 1),(k - i),"y",1))));
                }
                current_statement_begin__ = 1640;
                stan::math::assign(get_base1_lhs(y,k,k,"y",1), get_base1(x,k,"x",1));
                current_statement_begin__ = 1641;
                if (pstream__) {
                    stan_print(pstream__,y);
                    *pstream__ << std::endl;
                }
                current_statement_begin__ = 1641;
            }
            current_statement_begin__ = 1643;
            return stan::math::promote_scalar<fun_return_scalar_t__>(minus(transpose(get_base1(y,n,"y",1))));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct pacf_to_acf_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x, std::ostream* pstream__) const {
        return pacf_to_acf(x, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
constrain_stationary(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  r(static_cast<Eigen::VectorXd::Index>(num_elements(x)));
            (void) r;  // dummy to suppress unused var warning
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            stan::math::initialize(r, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1660;
            stan::math::assign(n, num_elements(x));
            current_statement_begin__ = 1662;
            for (int i = 1; i <= n; ++i) {
                current_statement_begin__ = 1663;
                stan::math::assign(get_base1_lhs(r,i,"r",1), (get_base1(x,i,"x",1) / sqrt((1.0 + pow(get_base1(x,i,"x",1),2)))));
            }
            current_statement_begin__ = 1666;
            return stan::math::promote_scalar<fun_return_scalar_t__>(pacf_to_acf(r, pstream__));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct constrain_stationary_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x, std::ostream* pstream__) const {
        return constrain_stationary(x, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
acf_to_pacf(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  y(static_cast<Eigen::VectorXd::Index>(num_elements(x)),static_cast<Eigen::VectorXd::Index>(num_elements(x)));
            (void) y;  // dummy to suppress unused var warning
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  r(static_cast<Eigen::VectorXd::Index>(num_elements(x)));
            (void) r;  // dummy to suppress unused var warning
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            stan::math::initialize(y, std::numeric_limits<double>::quiet_NaN());
            stan::math::initialize(r, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1680;
            stan::math::assign(n, num_elements(x));
            current_statement_begin__ = 1681;
            stan::math::assign(y, rep_matrix(0.0,n,n));
            current_statement_begin__ = 1682;
            stan::math::assign(get_base1_lhs(y,n,"y",1), minus(transpose(x)));
            current_statement_begin__ = 1683;
            for (int j = 0; j <= (n - 1); ++j) {
                {
                    int k(0);
                    (void) k;  // dummy to suppress unused var warning
                    current_statement_begin__ = 1685;
                    stan::math::assign(k, (n - j));
                    current_statement_begin__ = 1686;
                    for (int i = 1; i <= (k - 1); ++i) {
                        current_statement_begin__ = 1687;
                        stan::math::assign(get_base1_lhs(y,(k - 1),i,"y",1), ((get_base1(y,k,i,"y",1) - (get_base1(y,k,k,"y",1) * get_base1(y,k,(k - i),"y",1))) / (1 - pow(get_base1(y,k,k,"y",1),2))));
                    }
                }
            }
            current_statement_begin__ = 1690;
            stan::math::assign(r, diagonal(y));
            current_statement_begin__ = 1691;
            return stan::math::promote_scalar<fun_return_scalar_t__>(r);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct acf_to_pacf_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x, std::ostream* pstream__) const {
        return acf_to_pacf(x, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
unconstrain_stationary(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  y(static_cast<Eigen::VectorXd::Index>(num_elements(x)),static_cast<Eigen::VectorXd::Index>(num_elements(x)));
            (void) y;  // dummy to suppress unused var warning
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  r(static_cast<Eigen::VectorXd::Index>(num_elements(x)));
            (void) r;  // dummy to suppress unused var warning
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  z(static_cast<Eigen::VectorXd::Index>(num_elements(x)));
            (void) z;  // dummy to suppress unused var warning
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            stan::math::initialize(y, std::numeric_limits<double>::quiet_NaN());
            stan::math::initialize(r, std::numeric_limits<double>::quiet_NaN());
            stan::math::initialize(z, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1706;
            stan::math::assign(n, num_elements(x));
            current_statement_begin__ = 1708;
            stan::math::assign(r, acf_to_pacf(x, pstream__));
            current_statement_begin__ = 1710;
            for (int i = 1; i <= n; ++i) {
                current_statement_begin__ = 1711;
                stan::math::assign(get_base1_lhs(z,i,"z",1), (get_base1(r,i,"r",1) / sqrt((1.0 - pow(get_base1(r,i,"r",1),2)))));
            }
            current_statement_begin__ = 1713;
            return stan::math::promote_scalar<fun_return_scalar_t__>(z);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct unconstrain_stationary_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x, std::ostream* pstream__) const {
        return unconstrain_stationary(x, pstream__);
    }
};

template <typename T0__, typename T1__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,Eigen::Dynamic>
kronecker_prod(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& A,
                   const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& B, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  C(static_cast<Eigen::VectorXd::Index>((rows(A) * rows(B))),static_cast<Eigen::VectorXd::Index>((cols(A) * cols(B))));
            (void) C;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            int p(0);
            (void) p;  // dummy to suppress unused var warning
            int q(0);
            (void) q;  // dummy to suppress unused var warning
            stan::math::initialize(C, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1740;
            stan::math::assign(m, rows(A));
            current_statement_begin__ = 1741;
            stan::math::assign(n, cols(A));
            current_statement_begin__ = 1742;
            stan::math::assign(p, rows(B));
            current_statement_begin__ = 1743;
            stan::math::assign(q, cols(B));
            current_statement_begin__ = 1744;
            for (int i = 1; i <= m; ++i) {
                current_statement_begin__ = 1745;
                for (int j = 1; j <= n; ++j) {
                    {
                        int row_start(0);
                        (void) row_start;  // dummy to suppress unused var warning
                        int row_end(0);
                        (void) row_end;  // dummy to suppress unused var warning
                        int col_start(0);
                        (void) col_start;  // dummy to suppress unused var warning
                        int col_end(0);
                        (void) col_end;  // dummy to suppress unused var warning
                        current_statement_begin__ = 1750;
                        stan::math::assign(row_start, (((i - 1) * p) + 1));
                        current_statement_begin__ = 1751;
                        stan::math::assign(row_end, (((i - 1) * p) + p));
                        current_statement_begin__ = 1752;
                        stan::math::assign(col_start, (((j - 1) * q) + 1));
                        current_statement_begin__ = 1753;
                        stan::math::assign(col_end, (((j - 1) * q) + 1));
                        current_statement_begin__ = 1754;
                        stan::model::assign(C, 
                                    stan::model::cons_list(stan::model::index_min_max(row_start, row_end), stan::model::cons_list(stan::model::index_min_max(col_start, col_end), stan::model::nil_index_list())), 
                                    multiply(get_base1(A,i,j,"A",1),B), 
                                    "assigning variable C");
                    }
                }
            }
            current_statement_begin__ = 1757;
            return stan::math::promote_scalar<fun_return_scalar_t__>(C);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct kronecker_prod_functor__ {
    template <typename T0__, typename T1__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& A,
                   const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& B, std::ostream* pstream__) const {
        return kronecker_prod(A, B, pstream__);
    }
};

template <typename T0__, typename T1__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,Eigen::Dynamic>
arima_stationary_cov(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& T,
                         const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& R, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Q0(static_cast<Eigen::VectorXd::Index>(rows(T)),static_cast<Eigen::VectorXd::Index>(cols(T)));
            (void) Q0;  // dummy to suppress unused var warning
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  TT(static_cast<Eigen::VectorXd::Index>((rows(T) * rows(T))),static_cast<Eigen::VectorXd::Index>((rows(T) * rows(T))));
            (void) TT;  // dummy to suppress unused var warning
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  RR(static_cast<Eigen::VectorXd::Index>((rows(T) * rows(T))));
            (void) RR;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            int m2(0);
            (void) m2;  // dummy to suppress unused var warning
            stan::math::initialize(Q0, std::numeric_limits<double>::quiet_NaN());
            stan::math::initialize(TT, std::numeric_limits<double>::quiet_NaN());
            stan::math::initialize(RR, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1783;
            stan::math::assign(m, rows(T));
            current_statement_begin__ = 1784;
            stan::math::assign(m2, (m * m));
            current_statement_begin__ = 1785;
            stan::math::assign(RR, to_vector(tcrossprod(R)));
            current_statement_begin__ = 1786;
            stan::math::assign(TT, kronecker_prod(T,T, pstream__));
            current_statement_begin__ = 1787;
            stan::math::assign(Q0, to_matrix_colwise(mdivide_left(subtract(diag_matrix(rep_vector(1.0,m2)),TT),RR),m,m, pstream__));
            current_statement_begin__ = 1788;
            return stan::math::promote_scalar<fun_return_scalar_t__>(Q0);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct arima_stationary_cov_functor__ {
    template <typename T0__, typename T1__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& T,
                         const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& R, std::ostream* pstream__) const {
        return arima_stationary_cov(T, R, pstream__);
    }
};

inline
std::vector<std::vector<int> >
ssm_sim_idx(const int& m,
                const int& p,
                const int& q, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<vector<int> > sz(4, (vector<int>(3, 0)));
            current_statement_begin__ = 1811;
            stan::math::assign(get_base1_lhs(get_base1_lhs(sz,1,"sz",1),1,"sz",2), p);
            current_statement_begin__ = 1813;
            stan::math::assign(get_base1_lhs(get_base1_lhs(sz,2,"sz",1),1,"sz",2), m);
            current_statement_begin__ = 1815;
            stan::math::assign(get_base1_lhs(get_base1_lhs(sz,3,"sz",1),1,"sz",2), p);
            current_statement_begin__ = 1817;
            stan::math::assign(get_base1_lhs(get_base1_lhs(sz,4,"sz",1),1,"sz",2), q);
            current_statement_begin__ = 1819;
            stan::math::assign(get_base1_lhs(get_base1_lhs(sz,1,"sz",1),2,"sz",2), 1);
            current_statement_begin__ = 1820;
            stan::math::assign(get_base1_lhs(get_base1_lhs(sz,1,"sz",1),3,"sz",2), ((get_base1(get_base1(sz,1,"sz",1),2,"sz",2) + get_base1(get_base1(sz,1,"sz",1),1,"sz",2)) - 1));
            current_statement_begin__ = 1821;
            for (int i = 2; i <= 4; ++i) {
                current_statement_begin__ = 1822;
                stan::math::assign(get_base1_lhs(get_base1_lhs(sz,i,"sz",1),2,"sz",2), (get_base1(get_base1(sz,(i - 1),"sz",1),3,"sz",2) + 1));
                current_statement_begin__ = 1823;
                stan::math::assign(get_base1_lhs(get_base1_lhs(sz,i,"sz",1),3,"sz",2), ((get_base1(get_base1(sz,i,"sz",1),2,"sz",2) + get_base1(get_base1(sz,i,"sz",1),1,"sz",2)) - 1));
            }
            current_statement_begin__ = 1825;
            return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_sim_idx_functor__ {
        inline
    std::vector<std::vector<int> >
    operator()(const int& m,
                const int& p,
                const int& q, std::ostream* pstream__) const {
        return ssm_sim_idx(m, p, q, pstream__);
    }
};

inline
int
ssm_sim_size(const int& m,
                 const int& p,
                 const int& q, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            int sz(0);
            (void) sz;  // dummy to suppress unused var warning
            current_statement_begin__ = 1839;
            stan::math::assign(sz, get_base1(get_base1(ssm_sim_idx(m,p,q, pstream__),4,"ssm_sim_idx(m,p,q, pstream__)",1),3,"ssm_sim_idx(m,p,q, pstream__)",2));
            current_statement_begin__ = 1840;
            return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_sim_size_functor__ {
        inline
    int
    operator()(const int& m,
                 const int& p,
                 const int& q, std::ostream* pstream__) const {
        return ssm_sim_size(m, p, q, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
ssm_sim_get_y(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  y(static_cast<Eigen::VectorXd::Index>(m));
            (void) y;  // dummy to suppress unused var warning
            vector<vector<int> > idx(4, (vector<int>(3, 0)));
            stan::math::initialize(y, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1855;
            stan::math::assign(idx, ssm_sim_idx(m,p,q, pstream__));
            current_statement_begin__ = 1856;
            stan::math::assign(y, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx,1,"idx",1),2,"idx",2), get_base1(get_base1(idx,1,"idx",1),3,"idx",2)), stan::model::nil_index_list()), "x"));
            current_statement_begin__ = 1857;
            return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_sim_get_y_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) const {
        return ssm_sim_get_y(x, m, p, q, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
ssm_sim_get_a(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  a(static_cast<Eigen::VectorXd::Index>(m));
            (void) a;  // dummy to suppress unused var warning
            vector<vector<int> > idx(4, (vector<int>(3, 0)));
            stan::math::initialize(a, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1872;
            stan::math::assign(idx, ssm_sim_idx(m,p,q, pstream__));
            current_statement_begin__ = 1873;
            stan::math::assign(a, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx,2,"idx",1),2,"idx",2), get_base1(get_base1(idx,2,"idx",1),3,"idx",2)), stan::model::nil_index_list()), "x"));
            current_statement_begin__ = 1874;
            return stan::math::promote_scalar<fun_return_scalar_t__>(a);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_sim_get_a_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) const {
        return ssm_sim_get_a(x, m, p, q, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
ssm_sim_get_eps(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                    const int& m,
                    const int& p,
                    const int& q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  eps(static_cast<Eigen::VectorXd::Index>(m));
            (void) eps;  // dummy to suppress unused var warning
            vector<vector<int> > idx(4, (vector<int>(3, 0)));
            stan::math::initialize(eps, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1890;
            stan::math::assign(idx, ssm_sim_idx(m,p,q, pstream__));
            current_statement_begin__ = 1891;
            stan::math::assign(eps, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx,3,"idx",1),2,"idx",2), get_base1(get_base1(idx,3,"idx",1),3,"idx",2)), stan::model::nil_index_list()), "x"));
            current_statement_begin__ = 1892;
            return stan::math::promote_scalar<fun_return_scalar_t__>(eps);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_sim_get_eps_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                    const int& m,
                    const int& p,
                    const int& q, std::ostream* pstream__) const {
        return ssm_sim_get_eps(x, m, p, q, pstream__);
    }
};

template <typename T0__>
inline
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
ssm_sim_get_eta(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                    const int& m,
                    const int& p,
                    const int& q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  eta(static_cast<Eigen::VectorXd::Index>(m));
            (void) eta;  // dummy to suppress unused var warning
            vector<vector<int> > idx(4, (vector<int>(3, 0)));
            stan::math::initialize(eta, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1907;
            stan::math::assign(idx, ssm_sim_idx(m,p,q, pstream__));
            current_statement_begin__ = 1908;
            stan::math::assign(eta, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx,4,"idx",1),2,"idx",2), get_base1(get_base1(idx,4,"idx",1),3,"idx",2)), stan::model::nil_index_list()), "x"));
            current_statement_begin__ = 1909;
            return stan::math::promote_scalar<fun_return_scalar_t__>(eta);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_sim_get_eta_functor__ {
    template <typename T0__>
    inline
    Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                    const int& m,
                    const int& p,
                    const int& q, std::ostream* pstream__) const {
        return ssm_sim_get_eta(x, m, p, q, pstream__);
    }
};

template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
inline
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type, Eigen::Dynamic,1> >
ssm_sim_rng(const int& n,
                const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& d,
                const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& H,
                const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,1> >& c,
                const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& T,
                const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic> >& R,
                const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic> >& Q,
                const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
                const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > ret(n, (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(ssm_sim_size(get_base1(dims(Z),3,"dims(Z)",1),get_base1(dims(Z),2,"dims(Z)",1),get_base1(dims(Q),2,"dims(Q)",1), pstream__)))));
            int p(0);
            (void) p;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            int q(0);
            (void) q;  // dummy to suppress unused var warning
            stan::math::initialize(ret, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 1970;
            stan::math::assign(p, get_base1(dims(Z),2,"dims(Z)",1));
            current_statement_begin__ = 1971;
            stan::math::assign(m, get_base1(dims(Z),3,"dims(Z)",1));
            current_statement_begin__ = 1972;
            stan::math::assign(q, get_base1(dims(Q),2,"dims(Q)",1));
            {
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  d_t(static_cast<Eigen::VectorXd::Index>(p));
                (void) d_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Z_t(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(m));
                (void) Z_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  H_t(static_cast<Eigen::VectorXd::Index>(p),static_cast<Eigen::VectorXd::Index>(p));
                (void) H_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  c_t(static_cast<Eigen::VectorXd::Index>(m));
                (void) c_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  T_t(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) T_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  R_t(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(q));
                (void) R_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Q_t(static_cast<Eigen::VectorXd::Index>(q),static_cast<Eigen::VectorXd::Index>(q));
                (void) Q_t;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  RQR(static_cast<Eigen::VectorXd::Index>(m),static_cast<Eigen::VectorXd::Index>(m));
                (void) RQR;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  y(static_cast<Eigen::VectorXd::Index>(p));
                (void) y;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  eps(static_cast<Eigen::VectorXd::Index>(p));
                (void) eps;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  a(static_cast<Eigen::VectorXd::Index>(m));
                (void) a;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  eta(static_cast<Eigen::VectorXd::Index>(q));
                (void) eta;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  zero_p(static_cast<Eigen::VectorXd::Index>(p));
                (void) zero_p;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  zero_q(static_cast<Eigen::VectorXd::Index>(q));
                (void) zero_q;  // dummy to suppress unused var warning
                Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  zero_m(static_cast<Eigen::VectorXd::Index>(m));
                (void) zero_m;  // dummy to suppress unused var warning
                vector<vector<int> > idx(4, (vector<int>(3, 0)));
                stan::math::initialize(d_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Z_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(H_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(c_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(T_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(R_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(Q_t, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(RQR, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(y, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(eps, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(a, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(eta, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(zero_p, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(zero_q, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(zero_m, std::numeric_limits<double>::quiet_NaN());
                current_statement_begin__ = 1994;
                stan::math::assign(d_t, get_base1(d,1,"d",1));
                current_statement_begin__ = 1995;
                stan::math::assign(Z_t, get_base1(Z,1,"Z",1));
                current_statement_begin__ = 1996;
                stan::math::assign(H_t, get_base1(H,1,"H",1));
                current_statement_begin__ = 1997;
                stan::math::assign(c_t, get_base1(c,1,"c",1));
                current_statement_begin__ = 1998;
                stan::math::assign(T_t, get_base1(T,1,"T",1));
                current_statement_begin__ = 1999;
                stan::math::assign(R_t, get_base1(R,1,"R",1));
                current_statement_begin__ = 2000;
                stan::math::assign(Q_t, get_base1(Q,1,"Q",1));
                current_statement_begin__ = 2002;
                stan::math::assign(idx, ssm_sim_idx(m,p,q, pstream__));
                current_statement_begin__ = 2003;
                stan::math::assign(zero_p, rep_vector(0.0,p));
                current_statement_begin__ = 2004;
                stan::math::assign(zero_q, rep_vector(0.0,q));
                current_statement_begin__ = 2005;
                stan::math::assign(zero_m, rep_vector(0.0,m));
                current_statement_begin__ = 2006;
                stan::math::assign(a, multi_normal_rng(a1,P1, base_rng__));
                current_statement_begin__ = 2007;
                for (int t = 1; t <= n; ++t) {
                    current_statement_begin__ = 2009;
                    if (as_bool(logical_gt(t,1))) {
                        current_statement_begin__ = 2010;
                        if (as_bool(logical_gt(size(d),1))) {
                            current_statement_begin__ = 2011;
                            stan::math::assign(d_t, get_base1(d,t,"d",1));
                        }
                        current_statement_begin__ = 2013;
                        if (as_bool(logical_gt(size(Z),1))) {
                            current_statement_begin__ = 2014;
                            stan::math::assign(Z_t, get_base1(Z,t,"Z",1));
                        }
                        current_statement_begin__ = 2016;
                        if (as_bool(logical_gt(size(H),1))) {
                            current_statement_begin__ = 2017;
                            stan::math::assign(H_t, get_base1(H,t,"H",1));
                        }
                        current_statement_begin__ = 2020;
                        if (as_bool(logical_lt(t,n))) {
                            current_statement_begin__ = 2021;
                            if (as_bool(logical_gt(size(c),1))) {
                                current_statement_begin__ = 2022;
                                stan::math::assign(c_t, get_base1(c,t,"c",1));
                            }
                            current_statement_begin__ = 2024;
                            if (as_bool(logical_gt(size(T),1))) {
                                current_statement_begin__ = 2025;
                                stan::math::assign(T_t, get_base1(T,t,"T",1));
                            }
                            current_statement_begin__ = 2027;
                            if (as_bool(logical_gt(size(R),1))) {
                                current_statement_begin__ = 2028;
                                stan::math::assign(R_t, get_base1(R,t,"R",1));
                            }
                            current_statement_begin__ = 2030;
                            if (as_bool(logical_gt(size(Q),1))) {
                                current_statement_begin__ = 2031;
                                stan::math::assign(Q_t, get_base1(Q,t,"Q",1));
                            }
                        }
                    }
                    current_statement_begin__ = 2036;
                    stan::math::assign(eps, multi_normal_rng(zero_p,H_t, base_rng__));
                    current_statement_begin__ = 2038;
                    stan::math::assign(y, add(add(d_t,multiply(Z_t,a)),eps));
                    current_statement_begin__ = 2041;
                    if (as_bool(logical_eq(t,n))) {
                        current_statement_begin__ = 2042;
                        stan::math::assign(eta, zero_q);
                    } else {
                        current_statement_begin__ = 2044;
                        stan::math::assign(eta, multi_normal_rng(zero_q,Q_t, base_rng__));
                    }
                    current_statement_begin__ = 2047;
                    stan::model::assign(ret, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx,1,"idx",1),2,"idx",2), get_base1(get_base1(idx,1,"idx",1),3,"idx",2)), stan::model::nil_index_list())), 
                                y, 
                                "assigning variable ret");
                    current_statement_begin__ = 2048;
                    stan::model::assign(ret, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx,2,"idx",1),2,"idx",2), get_base1(get_base1(idx,2,"idx",1),3,"idx",2)), stan::model::nil_index_list())), 
                                a, 
                                "assigning variable ret");
                    current_statement_begin__ = 2049;
                    stan::model::assign(ret, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx,3,"idx",1),2,"idx",2), get_base1(get_base1(idx,3,"idx",1),3,"idx",2)), stan::model::nil_index_list())), 
                                eps, 
                                "assigning variable ret");
                    current_statement_begin__ = 2050;
                    stan::model::assign(ret, 
                                stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx,4,"idx",1),2,"idx",2), get_base1(get_base1(idx,4,"idx",1),3,"idx",2)), stan::model::nil_index_list())), 
                                eta, 
                                "assigning variable ret");
                    current_statement_begin__ = 2052;
                    if (as_bool(logical_lt(t,n))) {
                        current_statement_begin__ = 2053;
                        stan::math::assign(a, add(add(c_t,multiply(T_t,a)),multiply(R_t,eta)));
                    }
                }
            }
            current_statement_begin__ = 2057;
            return stan::math::promote_scalar<fun_return_scalar_t__>(ret);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_sim_rng_functor__ {
    template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
    inline
    std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type, Eigen::Dynamic,1> >
    operator()(const int& n,
                const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& d,
                const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& H,
                const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,1> >& c,
                const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& T,
                const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic> >& R,
                const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic> >& Q,
                const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
                const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
inline
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic,1> >
ssm_simsmo_eps_rng(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& eps,
                       const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& d,
                       const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                       const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& H,
                       const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,1> >& c,
                       const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& T,
                       const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic> >& R,
                       const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic> >& Q,
                       const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
                       const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > draws(size(eps), (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(get_base1(dims(Z),2,"dims(Z)",1)))));
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            int p(0);
            (void) p;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            int q(0);
            (void) q;  // dummy to suppress unused var warning
            stan::math::initialize(draws, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 2099;
            stan::math::assign(n, size(eps));
            current_statement_begin__ = 2100;
            stan::math::assign(p, get_base1(dims(Z),2,"dims(Z)",1));
            current_statement_begin__ = 2101;
            stan::math::assign(m, get_base1(dims(Z),3,"dims(Z)",1));
            current_statement_begin__ = 2102;
            stan::math::assign(q, get_base1(dims(Q),2,"dims(Q)",1));
            {
                vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > filter(n, (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(ssm_filter_size(m,p, pstream__)))));
                vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > y(n, (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(p))));
                vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > sims(n, (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(ssm_sim_size(m,p,q, pstream__)))));
                vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > epshat_plus(n, (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(ssm_smooth_eta_size(p, pstream__)))));
                stan::math::initialize(filter, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(y, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(sims, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(epshat_plus, std::numeric_limits<double>::quiet_NaN());
                current_statement_begin__ = 2109;
                stan::math::assign(sims, ssm_sim_rng(n,d,Z,H,c,T,R,Q,a1,P1, base_rng__, pstream__));
                current_statement_begin__ = 2110;
                for (int i = 1; i <= n; ++i) {
                    current_statement_begin__ = 2111;
                    stan::math::assign(get_base1_lhs(y,i,"y",1), ssm_sim_get_y(get_base1(sims,i,"sims",1),m,p,q, pstream__));
                }
                current_statement_begin__ = 2114;
                stan::math::assign(filter, ssm_filter(y,d,Z,H,c,T,R,Q,a1,P1, pstream__));
                current_statement_begin__ = 2116;
                stan::math::assign(epshat_plus, ssm_smooth_eps(filter,Z,H,T, pstream__));
                current_statement_begin__ = 2117;
                for (int i = 1; i <= n; ++i) {
                    current_statement_begin__ = 2118;
                    stan::math::assign(get_base1_lhs(draws,i,"draws",1), add(subtract(ssm_sim_get_eps(get_base1(sims,i,"sims",1),m,p,q, pstream__),ssm_smooth_eps_get_mean(get_base1(epshat_plus,i,"epshat_plus",1),p, pstream__)),ssm_smooth_eps_get_mean(get_base1(eps,i,"eps",1),p, pstream__)));
                }
            }
            current_statement_begin__ = 2123;
            return stan::math::promote_scalar<fun_return_scalar_t__>(draws);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_simsmo_eps_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
    inline
    std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic,1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& eps,
                       const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& d,
                       const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                       const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& H,
                       const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,1> >& c,
                       const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& T,
                       const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic> >& R,
                       const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic> >& Q,
                       const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
                       const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_simsmo_eps_rng(eps, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
inline
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic,1> >
ssm_simsmo_states_rng(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& alpha,
                          const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& d,
                          const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                          const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& H,
                          const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,1> >& c,
                          const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& T,
                          const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic> >& R,
                          const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic> >& Q,
                          const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
                          const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > draws(size(alpha), (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(get_base1(dims(Z),2,"dims(Z)",1)))));
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            int p(0);
            (void) p;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            int q(0);
            (void) q;  // dummy to suppress unused var warning
            stan::math::initialize(draws, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 2162;
            stan::math::assign(n, size(alpha));
            current_statement_begin__ = 2163;
            stan::math::assign(p, get_base1(dims(Z),2,"dims(Z)",1));
            current_statement_begin__ = 2164;
            stan::math::assign(m, get_base1(dims(Z),3,"dims(Z)",1));
            current_statement_begin__ = 2165;
            stan::math::assign(q, get_base1(dims(Q),2,"dims(Q)",1));
            {
                vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > filter(n, (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(ssm_filter_size(m,p, pstream__)))));
                vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > sims(n, (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(ssm_sim_size(m,p,q, pstream__)))));
                vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > y(n, (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(p))));
                vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > alpha_hat_plus(n, (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(m))));
                stan::math::initialize(filter, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(sims, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(y, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(alpha_hat_plus, std::numeric_limits<double>::quiet_NaN());
                current_statement_begin__ = 2172;
                stan::math::assign(sims, ssm_sim_rng(n,d,Z,H,c,T,R,Q,a1,P1, base_rng__, pstream__));
                current_statement_begin__ = 2173;
                for (int i = 1; i <= n; ++i) {
                    current_statement_begin__ = 2174;
                    stan::math::assign(get_base1_lhs(y,i,"y",1), ssm_sim_get_y(get_base1(sims,i,"sims",1),m,p,q, pstream__));
                }
                current_statement_begin__ = 2177;
                stan::math::assign(filter, ssm_filter(y,d,Z,H,c,T,R,Q,a1,P1, pstream__));
                current_statement_begin__ = 2179;
                stan::math::assign(alpha_hat_plus, ssm_smooth_faststate(filter,c,Z,T,R,Q, pstream__));
                current_statement_begin__ = 2180;
                for (int i = 1; i <= n; ++i) {
                    current_statement_begin__ = 2181;
                    stan::math::assign(get_base1_lhs(draws,i,"draws",1), add(subtract(ssm_sim_get_a(get_base1(sims,i,"sims",1),m,p,q, pstream__),get_base1(alpha_hat_plus,i,"alpha_hat_plus",1)),get_base1(alpha,i,"alpha",1)));
                }
            }
            current_statement_begin__ = 2186;
            return stan::math::promote_scalar<fun_return_scalar_t__>(draws);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_simsmo_states_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
    inline
    std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic,1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& alpha,
                          const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& d,
                          const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                          const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& H,
                          const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,1> >& c,
                          const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& T,
                          const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic> >& R,
                          const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic> >& Q,
                          const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
                          const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_simsmo_states_rng(alpha, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
inline
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic,1> >
ssm_simsmo_eta_rng(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& eta,
                       const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& d,
                       const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                       const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& H,
                       const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,1> >& c,
                       const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& T,
                       const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic> >& R,
                       const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic> >& Q,
                       const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
                       const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
    int current_statement_begin__ = -1;
    try {
        {
            vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > draws(size(eta), (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(get_base1(dims(Q),2,"dims(Q)",1)))));
            int n(0);
            (void) n;  // dummy to suppress unused var warning
            int p(0);
            (void) p;  // dummy to suppress unused var warning
            int m(0);
            (void) m;  // dummy to suppress unused var warning
            int q(0);
            (void) q;  // dummy to suppress unused var warning
            stan::math::initialize(draws, std::numeric_limits<double>::quiet_NaN());
            current_statement_begin__ = 2223;
            stan::math::assign(n, size(eta));
            current_statement_begin__ = 2224;
            stan::math::assign(p, get_base1(dims(Z),2,"dims(Z)",1));
            current_statement_begin__ = 2225;
            stan::math::assign(m, get_base1(dims(Z),3,"dims(Z)",1));
            current_statement_begin__ = 2226;
            stan::math::assign(q, get_base1(dims(Q),2,"dims(Q)",1));
            {
                vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > filter(n, (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(ssm_filter_size(m,p, pstream__)))));
                vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > y(n, (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(p))));
                vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > sims(n, (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(ssm_sim_size(m,p,q, pstream__)))));
                vector<Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> > etahat_plus(n, (Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(ssm_smooth_eta_size(q, pstream__)))));
                stan::math::initialize(filter, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(y, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(sims, std::numeric_limits<double>::quiet_NaN());
                stan::math::initialize(etahat_plus, std::numeric_limits<double>::quiet_NaN());
                current_statement_begin__ = 2233;
                stan::math::assign(sims, ssm_sim_rng(n,d,Z,H,c,T,R,Q,a1,P1, base_rng__, pstream__));
                current_statement_begin__ = 2234;
                for (int i = 1; i <= n; ++i) {
                    current_statement_begin__ = 2235;
                    stan::math::assign(get_base1_lhs(y,i,"y",1), ssm_sim_get_y(get_base1(sims,i,"sims",1),m,p,q, pstream__));
                }
                current_statement_begin__ = 2238;
                stan::math::assign(filter, ssm_filter(y,d,Z,H,c,T,R,Q,a1,P1, pstream__));
                current_statement_begin__ = 2240;
                stan::math::assign(etahat_plus, ssm_smooth_eta(filter,Z,T,R,Q, pstream__));
                current_statement_begin__ = 2241;
                for (int i = 1; i <= n; ++i) {
                    current_statement_begin__ = 2242;
                    stan::math::assign(get_base1_lhs(draws,i,"draws",1), add(subtract(ssm_sim_get_eta(get_base1(sims,i,"sims",1),m,p,q, pstream__),ssm_smooth_eta_get_mean(get_base1(etahat_plus,i,"etahat_plus",1),q, pstream__)),ssm_smooth_eta_get_mean(get_base1(eta,i,"eta",1),q, pstream__)));
                }
            }
            current_statement_begin__ = 2247;
            return stan::math::promote_scalar<fun_return_scalar_t__>(draws);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e,current_statement_begin__);
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ssm_simsmo_eta_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
    inline
    std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic,1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic,1> >& eta,
                       const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic,1> >& d,
                       const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic> >& Z,
                       const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic,Eigen::Dynamic> >& H,
                       const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic,1> >& c,
                       const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,Eigen::Dynamic> >& T,
                       const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic> >& R,
                       const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic> >& Q,
                       const Eigen::Matrix<T8__, Eigen::Dynamic,1>& a1,
                       const Eigen::Matrix<T9__, Eigen::Dynamic,Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_simsmo_eta_rng(eta, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__);
    }
};

class model_linear_trend_ar2 : public prob_grad {
private:
    int n;
    vector<vector_d> y;
    vector_d a1;
    matrix_d P1;
    matrix_d Z;
    matrix_d R;
    matrix_d H;
    vector_d c;
    vector_d d;
public:
    model_linear_trend_ar2(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        current_statement_begin__ = -1;

        static const char* function__ = "model_linear_trend_ar2_namespace::model_linear_trend_ar2";
        (void) function__; // dummy call to supress warning
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        context__.validate_dims("data initialization", "n", "int", context__.to_vec());
        n = int(0);
        vals_i__ = context__.vals_i("n");
        pos__ = 0;
        n = vals_i__[pos__++];
        validate_non_negative_index("y", "n", n);
        validate_non_negative_index("y", "1", 1);
        y = std::vector<vector_d>(n,vector_d(static_cast<Eigen::VectorXd::Index>(1)));
        context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(n,1));
        vals_r__ = context__.vals_r("y");
        pos__ = 0;
        size_t y_i_vec_lim__ = 1;
        for (size_t i_vec__ = 0; i_vec__ < y_i_vec_lim__; ++i_vec__) {
            size_t y_limit_0__ = n;
            for (size_t i_0__ = 0; i_0__ < y_limit_0__; ++i_0__) {
                y[i_0__][i_vec__] = vals_r__[pos__++];
            }
        }
        validate_non_negative_index("a1", "4", 4);
        a1 = vector_d(static_cast<Eigen::VectorXd::Index>(4));
        context__.validate_dims("data initialization", "a1", "vector_d", context__.to_vec(4));
        vals_r__ = context__.vals_r("a1");
        pos__ = 0;
        size_t a1_i_vec_lim__ = 4;
        for (size_t i_vec__ = 0; i_vec__ < a1_i_vec_lim__; ++i_vec__) {
            a1[i_vec__] = vals_r__[pos__++];
        }
        context__.validate_dims("data initialization", "P1", "matrix_d", context__.to_vec(4,4));
        validate_non_negative_index("P1", "4", 4);
        validate_non_negative_index("P1", "4", 4);
        P1 = matrix_d(static_cast<Eigen::VectorXd::Index>(4),static_cast<Eigen::VectorXd::Index>(4));
        vals_r__ = context__.vals_r("P1");
        pos__ = 0;
        size_t P1_k_mat_lim__ = 4;
        for (size_t n_mat__ = 0; n_mat__ < P1_k_mat_lim__; ++n_mat__) {
            for (size_t m_mat__ = 0; m_mat__ < P1_k_mat_lim__; ++m_mat__) {
                P1(m_mat__,n_mat__) = vals_r__[pos__++];
            }
        }

        // validate data
        check_greater_or_equal(function__,"n",n,1);
        stan::math::check_cov_matrix(function__,"P1",P1);
        validate_non_negative_index("Z", "1", 1);
        validate_non_negative_index("Z", "4", 4);
        Z = matrix_d(static_cast<Eigen::VectorXd::Index>(1),static_cast<Eigen::VectorXd::Index>(4));
        validate_non_negative_index("R", "4", 4);
        validate_non_negative_index("R", "3", 3);
        R = matrix_d(static_cast<Eigen::VectorXd::Index>(4),static_cast<Eigen::VectorXd::Index>(3));
        validate_non_negative_index("H", "1", 1);
        validate_non_negative_index("H", "1", 1);
        H = matrix_d(static_cast<Eigen::VectorXd::Index>(1),static_cast<Eigen::VectorXd::Index>(1));
        validate_non_negative_index("c", "4", 4);
        c = vector_d(static_cast<Eigen::VectorXd::Index>(4));
        validate_non_negative_index("d", "1", 1);
        d = vector_d(static_cast<Eigen::VectorXd::Index>(1));

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning


        // initialize transformed variables to avoid seg fault on val access
        stan::math::fill(Z,DUMMY_VAR__);
        stan::math::fill(R,DUMMY_VAR__);
        stan::math::fill(H,DUMMY_VAR__);
        stan::math::fill(c,DUMMY_VAR__);
        stan::math::fill(d,DUMMY_VAR__);

        try {
            current_statement_begin__ = 2262;
            stan::math::assign(d, rep_vector(0.0,1));
            current_statement_begin__ = 2263;
            stan::math::assign(c, rep_vector(0.0,4));
            current_statement_begin__ = 2264;
            stan::math::assign(R, rep_matrix(0.0,4,3));
            current_statement_begin__ = 2265;
            for (int i = 1; i <= 3; ++i) {
                current_statement_begin__ = 2266;
                stan::math::assign(get_base1_lhs(R,i,i,"R",1), 1.0);
            }
            current_statement_begin__ = 2268;
            stan::math::assign(get_base1_lhs(Z,1,1,"Z",1), 1.0);
            current_statement_begin__ = 2269;
            stan::math::assign(get_base1_lhs(Z,1,2,"Z",1), 0.0);
            current_statement_begin__ = 2270;
            stan::math::assign(get_base1_lhs(Z,1,3,"Z",1), 1.0);
            current_statement_begin__ = 2271;
            stan::math::assign(get_base1_lhs(Z,1,4,"Z",1), 0.0);
            current_statement_begin__ = 2272;
            stan::math::assign(H, rep_matrix(0.0,1,1));
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed data

        // set parameter ranges
        num_params_r__ = 0U;
        param_ranges_i__.clear();
        num_params_r__ += 3;
        num_params_r__ += 2;
    }

    ~model_linear_trend_ar2() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("sigma_eta")))
            throw std::runtime_error("variable sigma_eta missing");
        vals_r__ = context__.vals_r("sigma_eta");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_eta", "vector_d", context__.to_vec(3));
        vector_d sigma_eta(static_cast<Eigen::VectorXd::Index>(3));
        for (int j1__ = 0U; j1__ < 3; ++j1__)
            sigma_eta(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0.0,sigma_eta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_eta: ") + e.what());
        }

        if (!(context__.contains_r("phi_raw")))
            throw std::runtime_error("variable phi_raw missing");
        vals_r__ = context__.vals_r("phi_raw");
        pos__ = 0U;
        context__.validate_dims("initialization", "phi_raw", "vector_d", context__.to_vec(2));
        vector_d phi_raw(static_cast<Eigen::VectorXd::Index>(2));
        for (int j1__ = 0U; j1__ < 2; ++j1__)
            phi_raw(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(phi_raw);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable phi_raw: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);

        Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma_eta;
        (void) sigma_eta;  // dummy to suppress unused var warning
        if (jacobian__)
            sigma_eta = in__.vector_lb_constrain(0.0,3,lp__);
        else
            sigma_eta = in__.vector_lb_constrain(0.0,3);

        Eigen::Matrix<T__,Eigen::Dynamic,1>  phi_raw;
        (void) phi_raw;  // dummy to suppress unused var warning
        if (jacobian__)
            phi_raw = in__.vector_constrain(2,lp__);
        else
            phi_raw = in__.vector_constrain(2);


        // transformed parameters
        Eigen::Matrix<T__,Eigen::Dynamic,1>  phi(static_cast<Eigen::VectorXd::Index>(2));
        (void) phi;  // dummy to suppress unused var warning

        // initialize transformed variables to avoid seg fault on val access
        stan::math::fill(phi,DUMMY_VAR__);

        try {
            current_statement_begin__ = 2280;
            stan::math::assign(phi, constrain_stationary(phi_raw, pstream__));
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters
        for (int i0__ = 0; i0__ < 2; ++i0__) {
            if (stan::math::is_uninitialized(phi(i0__))) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: phi" << '[' << i0__ << ']';
                throw std::runtime_error(msg__.str());
            }
        }

        const char* function__ = "validate transformed params";
        (void) function__;  // dummy to suppress unused var warning

        // model body
        try {
            {
                Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  T(static_cast<Eigen::VectorXd::Index>(4),static_cast<Eigen::VectorXd::Index>(4));
                (void) T;  // dummy to suppress unused var warning
                Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  Q(static_cast<Eigen::VectorXd::Index>(3),static_cast<Eigen::VectorXd::Index>(3));
                (void) Q;  // dummy to suppress unused var warning
                stan::math::initialize(T, DUMMY_VAR__);
                stan::math::initialize(Q, DUMMY_VAR__);
                current_statement_begin__ = 2285;
                stan::math::assign(Q, rep_matrix(0.0,3,3));
                current_statement_begin__ = 2286;
                stan::math::assign(T, rep_matrix(0.0,4,4));
                current_statement_begin__ = 2287;
                stan::math::assign(get_base1_lhs(T,1,1,"T",1), 1.0);
                current_statement_begin__ = 2288;
                stan::math::assign(get_base1_lhs(T,1,2,"T",1), 1.0);
                current_statement_begin__ = 2289;
                stan::math::assign(get_base1_lhs(T,2,2,"T",1), 1.0);
                current_statement_begin__ = 2290;
                stan::math::assign(get_base1_lhs(T,3,3,"T",1), get_base1(phi,1,"phi",1));
                current_statement_begin__ = 2291;
                stan::math::assign(get_base1_lhs(T,4,3,"T",1), get_base1(phi,2,"phi",1));
                current_statement_begin__ = 2292;
                for (int i = 1; i <= 3; ++i) {
                    current_statement_begin__ = 2293;
                    stan::math::assign(get_base1_lhs(Q,i,i,"Q",1), pow(get_base1(sigma_eta,i,"sigma_eta",1),2));
                }
                current_statement_begin__ = 2295;
                lp_accum__.add(ssm_constant_log(y,c,Z,H,d,T,R,Q,a1,P1));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("sigma_eta");
        names__.push_back("phi_raw");
        names__.push_back("phi");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(3);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(2);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_linear_trend_ar2_namespace::write_array";
        (void) function__; // dummy call to supress warning
        // read-transform, write parameters
        vector_d sigma_eta = in__.vector_lb_constrain(0.0,3);
        vector_d phi_raw = in__.vector_constrain(2);
        for (int k_0__ = 0; k_0__ < 3; ++k_0__) {
            vars__.push_back(sigma_eta[k_0__]);
        }
        for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(phi_raw[k_0__]);
        }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__; // dummy call to supress warning
        stan::math::accumulator<double> lp_accum__;

        vector_d phi(static_cast<Eigen::VectorXd::Index>(2));
        (void) phi;  // dummy to suppress unused var warning

        try {
            current_statement_begin__ = 2280;
            stan::math::assign(phi, constrain_stationary(phi_raw, pstream__));
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate transformed parameters

        // write transformed parameters
        for (int k_0__ = 0; k_0__ < 2; ++k_0__) {
            vars__.push_back(phi[k_0__]);
        }

        if (!include_gqs__) return;
        // declare and define generated quantities

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning


        // initialize transformed variables to avoid seg fault on val access

        try {
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        // validate generated quantities

        // write generated quantities
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_linear_trend_ar2";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma_eta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi_raw" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= 3; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma_eta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi_raw" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= 2; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
    }

}; // model

} // namespace

typedef model_linear_trend_ar2_namespace::model_linear_trend_ar2 stan_model;

