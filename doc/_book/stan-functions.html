<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>State Space Models in Stan</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="Documentation for State Space Models in Stan.">
  <meta name="generator" content="bookdown 0.1 and GitBook 2.6.7">

  <meta property="og:title" content="State Space Models in Stan" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Documentation for State Space Models in Stan." />
  <meta name="github-repo" content="rstudio/bookdown-demo" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="State Space Models in Stan" />
  
  <meta name="twitter:description" content="Documentation for State Space Models in Stan." />
  

<meta name="author" content="Jeffrey B. Arnold">

<meta name="date" content="2016-07-16">

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="placeholder-1.html">
<link rel="next" href="other-software.html">

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />










<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>

$$
\DeclareMathOperator{\E}{E}
\DeclareMathOperator{\mean}{mean}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\Cor}{Cor}
\DeclareMathOperator{\Bias}{Bias}
\DeclareMathOperator{\MSE}{MSE}
\DeclareMathOperator{\sd}{sd}
\DeclareMathOperator{\se}{se}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\VEC}{vec}

\newcommand{\mat}[1]{\boldsymbol{#1}}
\newcommand{\vec}[1]{\boldsymbol{#1}}
\newcommand{\T}{'}

\newcommand{\distr}[1]{\mathcal{#1}}
\newcommand{\dnorm}{\distr{N}}
\newcommand{\dmvnorm}[1]{\distr{N}_{#1}}
\newcommand{\dt}[1]{\distr{T}_{#1}}

\newcommand{\cia}{\perp\!\!\!\perp}
\DeclareMathOperator*{\plim}{plim}
$$

  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">State Space Models in Stan</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Introduction</a></li>
<li class="chapter" data-level="2" data-path="the-linear-state-space-model.html"><a href="the-linear-state-space-model.html"><i class="fa fa-check"></i><b>2</b> The Linear State Space Model</a></li>
<li class="chapter" data-level="3" data-path="filtering-and-smoothing.html"><a href="filtering-and-smoothing.html"><i class="fa fa-check"></i><b>3</b> Filtering and Smoothing</a></li>
<li class="chapter" data-level="4" data-path="parameter-estimation.html"><a href="parameter-estimation.html"><i class="fa fa-check"></i><b>4</b> Parameter Estimation</a></li>
<li class="chapter" data-level="5" data-path="example-models.html"><a href="example-models.html"><i class="fa fa-check"></i><b>5</b> Example Models</a></li>
<li class="chapter" data-level="6" data-path="example-models-1.html"><a href="example-models-1.html"><i class="fa fa-check"></i><b>6</b> Example Models</a></li>
<li class="chapter" data-level="7" data-path="placeholder.html"><a href="placeholder.html"><i class="fa fa-check"></i><b>7</b> Placeholder</a></li>
<li class="chapter" data-level="8" data-path="placeholder-1.html"><a href="placeholder-1.html"><i class="fa fa-check"></i><b>8</b> Placeholder</a></li>
<li class="chapter" data-level="9" data-path="stan-functions.html"><a href="stan-functions.html"><i class="fa fa-check"></i><b>9</b> Stan Functions</a><ul>
<li class="chapter" data-level="9.1" data-path="stan-functions.html"><a href="stan-functions.html#utility-functions"><i class="fa fa-check"></i><b>9.1</b> Utility Functions</a><ul>
<li class="chapter" data-level="9.1.1" data-path="stan-functions.html"><a href="stan-functions.html#to_symmetric_matrix"><i class="fa fa-check"></i><b>9.1.1</b> to_symmetric_matrix</a></li>
<li class="chapter" data-level="9.1.2" data-path="stan-functions.html"><a href="stan-functions.html#to_matrix_colwise"><i class="fa fa-check"></i><b>9.1.2</b> to_matrix_colwise</a></li>
<li class="chapter" data-level="9.1.3" data-path="stan-functions.html"><a href="stan-functions.html#matrix_pow"><i class="fa fa-check"></i><b>9.1.3</b> matrix_pow</a></li>
<li class="chapter" data-level="9.1.4" data-path="stan-functions.html"><a href="stan-functions.html#symmat_size"><i class="fa fa-check"></i><b>9.1.4</b> symmat_size</a></li>
<li class="chapter" data-level="9.1.5" data-path="stan-functions.html"><a href="stan-functions.html#find_symmat_dim"><i class="fa fa-check"></i><b>9.1.5</b> find_symmat_dim</a></li>
<li class="chapter" data-level="9.1.6" data-path="stan-functions.html"><a href="stan-functions.html#vector_to_symmat"><i class="fa fa-check"></i><b>9.1.6</b> vector_to_symmat</a></li>
<li class="chapter" data-level="9.1.7" data-path="stan-functions.html"><a href="stan-functions.html#symmat_to_vector"><i class="fa fa-check"></i><b>9.1.7</b> symmat_to_vector</a></li>
<li class="chapter" data-level="9.1.8" data-path="stan-functions.html"><a href="stan-functions.html#rep_lower_triangular_matrix"><i class="fa fa-check"></i><b>9.1.8</b> rep_lower_triangular_matrix</a></li>
<li class="chapter" data-level="9.1.9" data-path="stan-functions.html"><a href="stan-functions.html#rep_upper_triangular_matrix"><i class="fa fa-check"></i><b>9.1.9</b> rep_upper_triangular_matrix</a></li>
<li class="chapter" data-level="9.1.10" data-path="stan-functions.html"><a href="stan-functions.html#rep_diagonal_matrix"><i class="fa fa-check"></i><b>9.1.10</b> rep_diagonal_matrix</a></li>
<li class="chapter" data-level="9.1.11" data-path="stan-functions.html"><a href="stan-functions.html#fill_matrix"><i class="fa fa-check"></i><b>9.1.11</b> fill_matrix</a></li>
<li class="chapter" data-level="9.1.12" data-path="stan-functions.html"><a href="stan-functions.html#fill_vector"><i class="fa fa-check"></i><b>9.1.12</b> fill_vector</a></li>
<li class="chapter" data-level="9.1.13" data-path="stan-functions.html"><a href="stan-functions.html#int_sum_true"><i class="fa fa-check"></i><b>9.1.13</b> int_sum_true</a></li>
<li class="chapter" data-level="9.1.14" data-path="stan-functions.html"><a href="stan-functions.html#int_sum_false"><i class="fa fa-check"></i><b>9.1.14</b> int_sum_false</a></li>
<li class="chapter" data-level="9.1.15" data-path="stan-functions.html"><a href="stan-functions.html#mask_indexes"><i class="fa fa-check"></i><b>9.1.15</b> mask_indexes</a></li>
<li class="chapter" data-level="9.1.16" data-path="stan-functions.html"><a href="stan-functions.html#select_indexes"><i class="fa fa-check"></i><b>9.1.16</b> select_indexes</a></li>
<li class="chapter" data-level="9.1.17" data-path="stan-functions.html"><a href="stan-functions.html#normal2_rng"><i class="fa fa-check"></i><b>9.1.17</b> normal2_rng</a></li>
<li class="chapter" data-level="9.1.18" data-path="stan-functions.html"><a href="stan-functions.html#cholesky_decompose2"><i class="fa fa-check"></i><b>9.1.18</b> cholesky_decompose2</a></li>
<li class="chapter" data-level="9.1.19" data-path="stan-functions.html"><a href="stan-functions.html#multi_normal2_rng"><i class="fa fa-check"></i><b>9.1.19</b> multi_normal2_rng</a></li>
<li class="chapter" data-level="9.1.20" data-path="stan-functions.html"><a href="stan-functions.html#multi_normal_cholesky2_rng"><i class="fa fa-check"></i><b>9.1.20</b> multi_normal_cholesky2_rng</a></li>
</ul></li>
<li class="chapter" data-level="9.2" data-path="stan-functions.html"><a href="stan-functions.html#filtering"><i class="fa fa-check"></i><b>9.2</b> Filtering</a><ul>
<li class="chapter" data-level="9.2.1" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_a"><i class="fa fa-check"></i><b>9.2.1</b> ssm_update_a</a></li>
<li class="chapter" data-level="9.2.2" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_a_u1"><i class="fa fa-check"></i><b>9.2.2</b> ssm_update_a_u1</a></li>
<li class="chapter" data-level="9.2.3" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_a_u2"><i class="fa fa-check"></i><b>9.2.3</b> ssm_update_a_u2</a></li>
<li class="chapter" data-level="9.2.4" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_p"><i class="fa fa-check"></i><b>9.2.4</b> ssm_update_P</a></li>
<li class="chapter" data-level="9.2.5" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_p_u1"><i class="fa fa-check"></i><b>9.2.5</b> ssm_update_P_u1</a></li>
<li class="chapter" data-level="9.2.6" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_p_u2"><i class="fa fa-check"></i><b>9.2.6</b> ssm_update_P_u2</a></li>
<li class="chapter" data-level="9.2.7" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_v"><i class="fa fa-check"></i><b>9.2.7</b> ssm_update_v</a></li>
<li class="chapter" data-level="9.2.8" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_v_u"><i class="fa fa-check"></i><b>9.2.8</b> ssm_update_v_u</a></li>
<li class="chapter" data-level="9.2.9" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_v_miss"><i class="fa fa-check"></i><b>9.2.9</b> ssm_update_v_miss</a></li>
<li class="chapter" data-level="9.2.10" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_f"><i class="fa fa-check"></i><b>9.2.10</b> ssm_update_F</a></li>
<li class="chapter" data-level="9.2.11" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_finv"><i class="fa fa-check"></i><b>9.2.11</b> ssm_update_Finv</a></li>
<li class="chapter" data-level="9.2.12" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_f_u"><i class="fa fa-check"></i><b>9.2.12</b> ssm_update_F_u</a></li>
<li class="chapter" data-level="9.2.13" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_finv_u"><i class="fa fa-check"></i><b>9.2.13</b> ssm_update_Finv_u</a></li>
<li class="chapter" data-level="9.2.14" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_finv_miss"><i class="fa fa-check"></i><b>9.2.14</b> ssm_update_Finv_miss</a></li>
<li class="chapter" data-level="9.2.15" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_k"><i class="fa fa-check"></i><b>9.2.15</b> ssm_update_K</a></li>
<li class="chapter" data-level="9.2.16" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_k_u"><i class="fa fa-check"></i><b>9.2.16</b> ssm_update_K_u</a></li>
<li class="chapter" data-level="9.2.17" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_l"><i class="fa fa-check"></i><b>9.2.17</b> ssm_update_L</a></li>
<li class="chapter" data-level="9.2.18" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_l_u"><i class="fa fa-check"></i><b>9.2.18</b> ssm_update_L_u</a></li>
<li class="chapter" data-level="9.2.19" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_loglik"><i class="fa fa-check"></i><b>9.2.19</b> ssm_update_loglik</a></li>
<li class="chapter" data-level="9.2.20" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_loglik_miss"><i class="fa fa-check"></i><b>9.2.20</b> ssm_update_loglik_miss</a></li>
<li class="chapter" data-level="9.2.21" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_loglik_u"><i class="fa fa-check"></i><b>9.2.21</b> ssm_update_loglik_u</a></li>
</ul></li>
<li class="chapter" data-level="9.3" data-path="stan-functions.html"><a href="stan-functions.html#filtering-1"><i class="fa fa-check"></i><b>9.3</b> Filtering</a><ul>
<li class="chapter" data-level="9.3.1" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_idx"><i class="fa fa-check"></i><b>9.3.1</b> ssm_filter_idx</a></li>
<li class="chapter" data-level="9.3.2" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_size"><i class="fa fa-check"></i><b>9.3.2</b> ssm_filter_size</a></li>
<li class="chapter" data-level="9.3.3" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_get_loglik"><i class="fa fa-check"></i><b>9.3.3</b> ssm_filter_get_loglik</a></li>
<li class="chapter" data-level="9.3.4" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_get_v"><i class="fa fa-check"></i><b>9.3.4</b> ssm_filter_get_v</a></li>
<li class="chapter" data-level="9.3.5" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_get_finv"><i class="fa fa-check"></i><b>9.3.5</b> ssm_filter_get_Finv</a></li>
<li class="chapter" data-level="9.3.6" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_get_k"><i class="fa fa-check"></i><b>9.3.6</b> ssm_filter_get_K</a></li>
<li class="chapter" data-level="9.3.7" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_get_a"><i class="fa fa-check"></i><b>9.3.7</b> ssm_filter_get_a</a></li>
<li class="chapter" data-level="9.3.8" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_get_p"><i class="fa fa-check"></i><b>9.3.8</b> ssm_filter_get_P</a></li>
<li class="chapter" data-level="9.3.9" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter"><i class="fa fa-check"></i><b>9.3.9</b> ssm_filter</a></li>
<li class="chapter" data-level="9.3.10" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_miss"><i class="fa fa-check"></i><b>9.3.10</b> ssm_filter_miss</a></li>
<li class="chapter" data-level="9.3.11" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_states_size"><i class="fa fa-check"></i><b>9.3.11</b> ssm_filter_states_size</a></li>
<li class="chapter" data-level="9.3.12" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_states_get_a"><i class="fa fa-check"></i><b>9.3.12</b> ssm_filter_states_get_a</a></li>
<li class="chapter" data-level="9.3.13" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_states_get_p"><i class="fa fa-check"></i><b>9.3.13</b> ssm_filter_states_get_P</a></li>
<li class="chapter" data-level="9.3.14" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_states_update_a"><i class="fa fa-check"></i><b>9.3.14</b> ssm_filter_states_update_a</a></li>
<li class="chapter" data-level="9.3.15" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_states_update_p"><i class="fa fa-check"></i><b>9.3.15</b> ssm_filter_states_update_P</a></li>
<li class="chapter" data-level="9.3.16" data-path="stan-functions.html"><a href="stan-functions.html#ssm_filter_states"><i class="fa fa-check"></i><b>9.3.16</b> ssm_filter_states</a></li>
</ul></li>
<li class="chapter" data-level="9.4" data-path="stan-functions.html"><a href="stan-functions.html#log-likelihood"><i class="fa fa-check"></i><b>9.4</b> Log-likelihood</a><ul>
<li class="chapter" data-level="9.4.1" data-path="stan-functions.html"><a href="stan-functions.html#ssm_lpdf"><i class="fa fa-check"></i><b>9.4.1</b> ssm_lpdf</a></li>
<li class="chapter" data-level="9.4.2" data-path="stan-functions.html"><a href="stan-functions.html#ssm_miss_lpdf"><i class="fa fa-check"></i><b>9.4.2</b> ssm_miss_lpdf</a></li>
<li class="chapter" data-level="9.4.3" data-path="stan-functions.html"><a href="stan-functions.html#ssm_ufilter_lpdf"><i class="fa fa-check"></i><b>9.4.3</b> ssm_ufilter_lpdf</a></li>
</ul></li>
<li class="chapter" data-level="9.5" data-path="stan-functions.html"><a href="stan-functions.html#time-invariant-kalman-filter"><i class="fa fa-check"></i><b>9.5</b> Time-Invariant Kalman Filter</a><ul>
<li class="chapter" data-level="9.5.1" data-path="stan-functions.html"><a href="stan-functions.html#matrix_diff"><i class="fa fa-check"></i><b>9.5.1</b> matrix_diff</a></li>
<li class="chapter" data-level="9.5.2" data-path="stan-functions.html"><a href="stan-functions.html#ssm_constant_lpdf"><i class="fa fa-check"></i><b>9.5.2</b> ssm_constant_lpdf</a></li>
</ul></li>
<li class="chapter" data-level="9.6" data-path="stan-functions.html"><a href="stan-functions.html#common-smoother-functions"><i class="fa fa-check"></i><b>9.6</b> Common Smoother Functions</a><ul>
<li class="chapter" data-level="9.6.1" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_r"><i class="fa fa-check"></i><b>9.6.1</b> ssm_update_r</a></li>
</ul></li>
<li class="chapter" data-level="9.7" data-path="stan-functions.html"><a href="stan-functions.html#common-smoother-functions-1"><i class="fa fa-check"></i><b>9.7</b> Common Smoother Functions</a><ul>
<li class="chapter" data-level="9.7.1" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_r_u1"><i class="fa fa-check"></i><b>9.7.1</b> ssm_update_r_u1</a></li>
<li class="chapter" data-level="9.7.2" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_r_u2"><i class="fa fa-check"></i><b>9.7.2</b> ssm_update_r_u2</a></li>
<li class="chapter" data-level="9.7.3" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_n"><i class="fa fa-check"></i><b>9.7.3</b> ssm_update_N</a></li>
<li class="chapter" data-level="9.7.4" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_n_u1"><i class="fa fa-check"></i><b>9.7.4</b> ssm_update_N_u1</a></li>
<li class="chapter" data-level="9.7.5" data-path="stan-functions.html"><a href="stan-functions.html#ssm_update_n_u2"><i class="fa fa-check"></i><b>9.7.5</b> ssm_update_N_u2</a></li>
<li class="chapter" data-level="9.7.6" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_state_size"><i class="fa fa-check"></i><b>9.7.6</b> ssm_smooth_state_size</a></li>
<li class="chapter" data-level="9.7.7" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_state_get_mean"><i class="fa fa-check"></i><b>9.7.7</b> ssm_smooth_state_get_mean</a></li>
<li class="chapter" data-level="9.7.8" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_state_get_var"><i class="fa fa-check"></i><b>9.7.8</b> ssm_smooth_state_get_var</a></li>
<li class="chapter" data-level="9.7.9" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_state"><i class="fa fa-check"></i><b>9.7.9</b> ssm_smooth_state</a></li>
<li class="chapter" data-level="9.7.10" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eps_size"><i class="fa fa-check"></i><b>9.7.10</b> ssm_smooth_eps_size</a></li>
<li class="chapter" data-level="9.7.11" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eps_get_mean"><i class="fa fa-check"></i><b>9.7.11</b> ssm_smooth_eps_get_mean</a></li>
<li class="chapter" data-level="9.7.12" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eps_get_var"><i class="fa fa-check"></i><b>9.7.12</b> ssm_smooth_eps_get_var</a></li>
<li class="chapter" data-level="9.7.13" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eps"><i class="fa fa-check"></i><b>9.7.13</b> ssm_smooth_eps</a></li>
<li class="chapter" data-level="9.7.14" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eta_size"><i class="fa fa-check"></i><b>9.7.14</b> ssm_smooth_eta_size</a></li>
<li class="chapter" data-level="9.7.15" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eta_get_mean"><i class="fa fa-check"></i><b>9.7.15</b> ssm_smooth_eta_get_mean</a></li>
<li class="chapter" data-level="9.7.16" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eta_get_var"><i class="fa fa-check"></i><b>9.7.16</b> ssm_smooth_eta_get_var</a></li>
<li class="chapter" data-level="9.7.17" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_eta"><i class="fa fa-check"></i><b>9.7.17</b> ssm_smooth_eta</a></li>
<li class="chapter" data-level="9.7.18" data-path="stan-functions.html"><a href="stan-functions.html#ssm_smooth_state_mean"><i class="fa fa-check"></i><b>9.7.18</b> ssm_smooth_state_mean</a></li>
</ul></li>
<li class="chapter" data-level="9.8" data-path="stan-functions.html"><a href="stan-functions.html#simulators-and-smoothing-simulators"><i class="fa fa-check"></i><b>9.8</b> Simulators and Smoothing Simulators</a><ul>
<li class="chapter" data-level="9.8.1" data-path="stan-functions.html"><a href="stan-functions.html#ssm_sim_idx"><i class="fa fa-check"></i><b>9.8.1</b> ssm_sim_idx</a></li>
<li class="chapter" data-level="9.8.2" data-path="stan-functions.html"><a href="stan-functions.html#ssm_sim_size"><i class="fa fa-check"></i><b>9.8.2</b> ssm_sim_size</a></li>
<li class="chapter" data-level="9.8.3" data-path="stan-functions.html"><a href="stan-functions.html#ssm_sim_get_y"><i class="fa fa-check"></i><b>9.8.3</b> ssm_sim_get_y</a></li>
<li class="chapter" data-level="9.8.4" data-path="stan-functions.html"><a href="stan-functions.html#ssm_sim_get_a"><i class="fa fa-check"></i><b>9.8.4</b> ssm_sim_get_a</a></li>
<li class="chapter" data-level="9.8.5" data-path="stan-functions.html"><a href="stan-functions.html#ssm_sim_get_eps"><i class="fa fa-check"></i><b>9.8.5</b> ssm_sim_get_eps</a></li>
<li class="chapter" data-level="9.8.6" data-path="stan-functions.html"><a href="stan-functions.html#ssm_sim_get_eta"><i class="fa fa-check"></i><b>9.8.6</b> ssm_sim_get_eta</a></li>
<li class="chapter" data-level="9.8.7" data-path="stan-functions.html"><a href="stan-functions.html#ssm_sim_rng"><i class="fa fa-check"></i><b>9.8.7</b> ssm_sim_rng</a></li>
</ul></li>
<li class="chapter" data-level="9.9" data-path="stan-functions.html"><a href="stan-functions.html#simulation-smoothers"><i class="fa fa-check"></i><b>9.9</b> Simulation Smoothers</a><ul>
<li class="chapter" data-level="9.9.1" data-path="stan-functions.html"><a href="stan-functions.html#ssm_simsmo_states_rng"><i class="fa fa-check"></i><b>9.9.1</b> ssm_simsmo_states_rng</a></li>
<li class="chapter" data-level="9.9.2" data-path="stan-functions.html"><a href="stan-functions.html#ssm_simsmo_states_miss_rng"><i class="fa fa-check"></i><b>9.9.2</b> ssm_simsmo_states_miss_rng</a></li>
<li class="chapter" data-level="9.9.3" data-path="stan-functions.html"><a href="stan-functions.html#ssm_simsmo_eta_rng"><i class="fa fa-check"></i><b>9.9.3</b> ssm_simsmo_eta_rng</a></li>
<li class="chapter" data-level="9.9.4" data-path="stan-functions.html"><a href="stan-functions.html#ssm_simsmo_eta_miss_rng"><i class="fa fa-check"></i><b>9.9.4</b> ssm_simsmo_eta_miss_rng</a></li>
<li class="chapter" data-level="9.9.5" data-path="stan-functions.html"><a href="stan-functions.html#ssm_simsmo_eps_rng"><i class="fa fa-check"></i><b>9.9.5</b> ssm_simsmo_eps_rng</a></li>
<li class="chapter" data-level="9.9.6" data-path="stan-functions.html"><a href="stan-functions.html#ssm_simsmo_eps_miss_rng"><i class="fa fa-check"></i><b>9.9.6</b> ssm_simsmo_eps_miss_rng</a></li>
</ul></li>
<li class="chapter" data-level="9.10" data-path="stan-functions.html"><a href="stan-functions.html#stationary"><i class="fa fa-check"></i><b>9.10</b> Stationary</a><ul>
<li class="chapter" data-level="9.10.1" data-path="stan-functions.html"><a href="stan-functions.html#pacf_to_acf"><i class="fa fa-check"></i><b>9.10.1</b> pacf_to_acf</a></li>
<li class="chapter" data-level="9.10.2" data-path="stan-functions.html"><a href="stan-functions.html#constrain_stationary"><i class="fa fa-check"></i><b>9.10.2</b> constrain_stationary</a></li>
<li class="chapter" data-level="9.10.3" data-path="stan-functions.html"><a href="stan-functions.html#acf_to_pacf"><i class="fa fa-check"></i><b>9.10.3</b> acf_to_pacf</a></li>
<li class="chapter" data-level="9.10.4" data-path="stan-functions.html"><a href="stan-functions.html#unconstrain_stationary"><i class="fa fa-check"></i><b>9.10.4</b> unconstrain_stationary</a></li>
<li class="chapter" data-level="9.10.5" data-path="stan-functions.html"><a href="stan-functions.html#kronecker_prod"><i class="fa fa-check"></i><b>9.10.5</b> kronecker_prod</a></li>
<li class="chapter" data-level="9.10.6" data-path="stan-functions.html"><a href="stan-functions.html#stationary_cov"><i class="fa fa-check"></i><b>9.10.6</b> stationary_cov</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="10" data-path="other-software.html"><a href="other-software.html"><i class="fa fa-check"></i><b>10</b> Other Software</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">State Space Models in Stan</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="stan-functions" class="section level1">
<h1><span class="header-section-number">Chapter 9</span> Stan Functions</h1>
<p>State space functionality for Stan is provided as a set of user-defined functions.</p>
<p>Add the following line to the Stan model file in which depends on these functions.</p>
<pre class="stan"><code>functions {
  #include ssm.stan
  // other functions ...
}</code></pre>
<p>To actually include the functions in the model, you need to use the function <code>stanc_builder</code>, instead of <code>stan</code> or <code>stanc</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">model &lt;-<span class="st"> </span><span class="kw">stanc_builder</span>(<span class="st">&quot;yourmodel.stan&quot;</span>, <span class="dt">isystem =</span> <span class="st">&quot;path/to/ssm/&quot;</span>)
<span class="kw">stan</span>(<span class="dt">model_code =</span> model$model_code)</code></pre></div>
<div id="utility-functions" class="section level2">
<h2><span class="header-section-number">9.1</span> Utility Functions</h2>
<div id="to_symmetric_matrix" class="section level3">
<h3><span class="header-section-number">9.1.1</span> to_symmetric_matrix</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: An <span class="math inline">\(n \times n\)</span> matrix</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(n \times n\)</span> symmetric matrix, <span class="math inline">\(0.5 (x + x&#39;)\)</span>.</p>
<p>Ensure a matrix is symmetric</p>
<pre class="stan"><code>matrix to_symmetric_matrix(matrix x) {
  return 0.5 * (x + x &#39;);
}

</code></pre>
</div>
<div id="to_matrix_colwise" class="section level3">
<h3><span class="header-section-number">9.1.2</span> to_matrix_colwise</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>v</code>: An <span class="math inline">\(n \times m\)</span> vector.</li>
<li><code>m</code>: Number of rows in the vector</li>
<li><code>n</code>: Number of columns in the vector</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(m \times n\)</span> matrix containting the elements from <code>v</code></p>
<p>Convert vector to a matrix (column-major).</p>
<pre class="stan"><code>matrix to_matrix_colwise(vector v, int m, int n) {
  matrix[m, n] res;
  int k;
  k = 1;
  // by col
  for (j in 1:n) {
    // by row
    for (i in 1:m) {
      res[i, j] = v[k];
      k = k + 1;
    }
  }
  return res;
}

</code></pre>
</div>
<div id="matrix_pow" class="section level3">
<h3><span class="header-section-number">9.1.3</span> matrix_pow</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A</code>: The matrix to take the power of</li>
<li><code>n</code>: The order of the power</li>
</ul>
<p><strong>returns</strong> None</p>
<p>Calculate the power of a matrix, <span class="math inline">\(\mat{A}^n\)</span>.</p>
<pre class="stan"><code>matrix matrix_pow(matrix A, int n);

matrix matrix_pow(matrix A, int n) {
  if (n == 0) {
    return diag_matrix(rep_vector(1., rows(A)));
  } else if (n == 1) {
    return A;
  } else if (n &gt; 1) {
    # recurively this is n log n.
    if (n % 2 == 0) {
      return matrix_pow(A, n / 2) * matrix_pow(A, n / 2);
    } else {
      return A * matrix_pow(A, n - 1);
    }
  } else {
    return A;
  }
}

</code></pre>
</div>
<div id="symmat_size" class="section level3">
<h3><span class="header-section-number">9.1.4</span> symmat_size</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>n</code>: The number of rows and columns in the matrix.</li>
</ul>
<p><strong>returns</strong> The number of unique elements</p>
<p>Calculate the number of unique elements in a symmetric matrix</p>
<p>The number of unique elements in an <span class="math inline">\(m \times m\)</span> matrix is <span class="math inline">\((m \times (m + 1)) / 2\)</span>.</p>
<pre class="stan"><code>
int symmat_size(int n) {
  int sz;
  // This is calculated iteratively to avoid the Stan warning for
  // integer division
  sz = 0;
  for (i in 1:n) {
    sz = sz + i;
  }
  return sz;
}

</code></pre>
</div>
<div id="find_symmat_dim" class="section level3">
<h3><span class="header-section-number">9.1.5</span> find_symmat_dim</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>n</code>: The number of unique elements in a symmetric matrix.</li>
</ul>
<p><strong>returns</strong> The dimension of the associated symmetric matrix.</p>
<p>Given vector with <span class="math inline">\(n\)</span> elements containing the <span class="math inline">\(m (m + 1) / 2\)</span> elements of a symmetric matrix, return <span class="math inline">\(m\)</span>.</p>
<pre class="stan"><code>int find_symmat_dim(int n) {
  // This could be solved by finding the positive root of $m = m (m + 1)/2 but
  // Stan doesn&#39;t support all the functions necessary to do this.
  int i;
  int remainder;
  remainder = n;
  i = 0;
  while (remainder &gt; 0) {
    i = i + 1;
    remainder = remainder - i;
  }
  return i;
}

</code></pre>
</div>
<div id="vector_to_symmat" class="section level3">
<h3><span class="header-section-number">9.1.6</span> vector_to_symmat</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: The vector with the unique elements</li>
<li><code>n</code>: The dimensions of the returned matrix, <span class="math inline">\(n \times n\)</span>.</li>
</ul>
<p><strong>returns</strong> matrix An <span class="math inline">\(n \times n\)</span> symmetric matrix.</p>
<p>Convert a vector to a symmetric matrix</p>
<pre class="stan"><code>matrix vector_to_symmat(vector x, int n) {
  matrix[n, n] m;
  int k;
  k = 1;
  // for column
  for (j in 1:n) {
    // for row
    for (i in j:n) {
      m[i, j] = x[k];
      if (i != j) {
        m[j, i] = m[i, j];
      }
      k = k + 1;
    }
  }
  return m;
}

</code></pre>
</div>
<div id="symmat_to_vector" class="section level3">
<h3><span class="header-section-number">9.1.7</span> symmat_to_vector</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: An <span class="math inline">\(n \times n\)</span> matrix.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(n (n + 1) / 2\)</span> vector with the unique elements in <span class="math inline">\(x\)</span>.</p>
<p>Convert an <span class="math inline">\(n \times n\)</span> symmetric matrix to a length <span class="math inline">\(n (n + 1) / 2\)</span> vector containing its unique elements.</p>
<pre class="stan"><code>
vector symmat_to_vector(matrix x) {
  vector[symmat_size(min(rows(x), cols(x)))] v;
  int m;
  int k;
  k = 1;
  m = min(rows(x), cols(x));
  // if x is m x n symmetric, then this will return
  // only parts of an m x m matrix.
  for (j in 1:m) {
    for (i in j:m) {
      v[k] = x[i, j];
      k = k + 1;
    }
  }
  return v;
}

</code></pre>
</div>
<div id="rep_lower_triangular_matrix" class="section level3">
<h3><span class="header-section-number">9.1.8</span> rep_lower_triangular_matrix</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: Value used for the non-zero elements of the matrix.</li>
<li><code>m</code>: number of rows</li>
<li><code>n</code>: number of columns</li>
<li><code>diag</code>: If true, then include 1’s on the diagonal.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times n\)</span> lower triangular matrix</p>
<p>Fill in an lower triangular matrix.</p>
<pre class="stan"><code>
matrix rep_lower_triangular_matrix(real x, int m, int n, int diag) {
  matrix[m, n] A;
  for (i in 1:m) {
    for (j in 1:n) {
      if (i &gt; j) {
        A[i, j] = x;
      } else if (i == j) {
        if (diag) {
          A[i, j] = x;
        } else {
          A[i, j] = 0.;
        }
      } else {
        A[i, j] = 0.;
      }
    }
  }
  return A;
}

</code></pre>
</div>
<div id="rep_upper_triangular_matrix" class="section level3">
<h3><span class="header-section-number">9.1.9</span> rep_upper_triangular_matrix</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: Value used for the non-zero elements of the matrix.</li>
<li><code>m</code>: number of rows</li>
<li><code>n</code>: number of columns</li>
<li><code>diag</code>: If true, then include 1’s on the diagonal.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times n\)</span> upper triangular matrix</p>
<p>Fill in an upper triangular matrix</p>
<pre class="stan"><code>
matrix rep_upper_triangular_matrix(real x, int m, int n, int diag) {
  matrix[m, n] A;
  for (i in 1:m) {
    for (j in 1:n) {
      # if row less than column
      if (i &lt; j) {
        A[i, j] = x;
      } else if (i == j) {
        if (diag) {
          A[i, j] = x;
        } else {
          A[i, j] = 0.;
        }
      } else {
        A[i, j] = 0.;
      }
    }
  }
  return A;
}

</code></pre>
</div>
<div id="rep_diagonal_matrix" class="section level3">
<h3><span class="header-section-number">9.1.10</span> rep_diagonal_matrix</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: Value used for the non-zero elements of the matrix.</li>
<li><code>m</code>: number of rows</li>
<li><code>n</code>: number of columns</li>
<li><code>k</code>: Index of the diagonal</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times n\)</span> upper triangular matrix</p>
<p>Create a diagonal <span class="math inline">\(m \times n\)</span> matrix with values <span class="math inline">\(x\)</span> on the <span class="math inline">\(k\)</span>-th diagonal.</p>
<pre class="stan"><code>
matrix rep_diagonal_matrix(real x, int m, int n, int k) {
  matrix[m, n] A;
  int mn;
  A = rep_matrix(0., m, n);
  mn = min(m, n);
  if (k &gt;= 0) {
    for (i in 1:min(m, n - k)) {
      A[i, i + k] = x;
    }
  } else {
    for (i in 1:min(m + k, n)) {
      A[i - k, i] = x;
    }
  }
  return A;
}

</code></pre>
</div>
<div id="fill_matrix" class="section level3">
<h3><span class="header-section-number">9.1.11</span> fill_matrix</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: A <span class="math inline">\(p \times q\)</span>, <span class="math inline">\(p \leq m\)</span>, <span class="math inline">\(\q \leq n\)</span> matrix</li>
<li><code>m</code>: Number of rows in the returned matrix</li>
<li><code>n</code>: Number of columns in the returned matrix</li>
<li><code>i</code>: Indices mapping the rows of <span class="math inline">\(A\)</span> to the rows in the output matrix</li>
<li><code>j</code>: Indices mapping the columns of <span class="math inline">\(A\)</span> to the columns of the output matrix</li>
<li><code>a</code>: The default value in the returned matrix</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(m \times n\)</span> matrix</p>
<p>Given a <span class="math inline">\(p \times q\)</span> matrix <span class="math inline">\(\mat{X}\)</span>, default value <span class="math inline">\(a\)</span>, and indexes <span class="math inline">\(\vec{I} = i_1, ..., i_p\)</span>, and <span class="math inline">\(\vec{J} = j_1, ...j_q\)</span>, return a <span class="math inline">\(m \times n\)</span> matrix where <span class="math inline">\(m \geq p\)</span>, <span class="math inline">\(n \geq q\)</span>, where <span class="math display">\[
Y_{k, l} =
\begin{cases}
X_{i, j} &amp; \text{if $k = i$, $l = j$, for some $i \in \vec{I}$, $j \in \vec{J}$,} \
a &amp; \text{otherwise} .
\end{cases}
\]</span></p>
<pre class="stan"><code>
matrix fill_matrix(matrix x, int m, int n, int[] i, int[] j, real a) {
  matrix[m, n] ret;
  ret = rep_matrix(a, m, n);
  ret[i, j] = x;
  return ret;
}

</code></pre>
</div>
<div id="fill_vector" class="section level3">
<h3><span class="header-section-number">9.1.12</span> fill_vector</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: A <span class="math inline">\(p \times q\)</span>, <span class="math inline">\(p \leq m\)</span>, <span class="math inline">\(\q \leq n\)</span> matrix</li>
<li><code>n</code>: Number of elements in the returned vector</li>
<li><code>i</code>: Indices mapping the rows of <span class="math inline">\(A\)</span> to the rows in the output matrix</li>
<li><code>a</code>: The default value in the returned vector</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(n \times 1\)</span> matrix</p>
Given an <span class="math inline">\(m \times 1\)</span> vector <span class="math inline">\(\vec{x}\)</span>, an integer <span class="math inline">\(n \geq m\)</span>, a default value <span class="math inline">\(a\)</span>, and indexes <span class="math inline">\(\vec{I} = i_1, ..., i_m \in 1:n\)</span>, return a <span class="math inline">\(n \times 1\)</span> vector where y_{j} =
\begin{cases}
x_{i} &amp; \text{if $j = i$ for some $i \in \vec{I}$,} \
a &amp; \text{otherwise}
\end{cases}
<p>. $$</p>
<pre class="stan"><code>
vector fill_vector(vector x, int n, int[] i, real a) {
  vector[n] ret;
  ret = rep_vector(a, n);
  ret[i] = x;
  return ret;
}

</code></pre>
</div>
<div id="int_sum_true" class="section level3">
<h3><span class="header-section-number">9.1.13</span> int_sum_true</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: An array of length <span class="math inline">\(n\)</span> of integers</li>
</ul>
<p><strong>returns</strong> An integer between 0 and <span class="math inline">\(n\)</span>.</p>
<p>For an array of integers, return the indexes where it is greater than zero.</p>
<pre class="stan"><code>
int int_sum_true(int[] x) {
  int n;
  n = 0;
  for (i in 1:num_elements(x)) {
    if (int_step(x[i])) {
      n = n + 1;
    }
  }
  return n;
}

</code></pre>
</div>
<div id="int_sum_false" class="section level3">
<h3><span class="header-section-number">9.1.14</span> int_sum_false</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: An array of length <span class="math inline">\(n\)</span> of integers</li>
</ul>
<p><strong>returns</strong> An integer between 0 and <span class="math inline">\(n\)</span>.</p>
<p>For an array of integers, return the indexes where it is less than or equal to zero.</p>
<pre class="stan"><code>
int int_sum_false(int[] x) {
  int n;
  n = 0;
  for (i in 1:num_elements(x)) {
    if (! int_step(x[i])) {
      n = n + 1;
    }
  }
  return n;
}


</code></pre>
</div>
<div id="mask_indexes" class="section level3">
<h3><span class="header-section-number">9.1.15</span> mask_indexes</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: An array of length <span class="math inline">\(n\)</span> of integers</li>
<li><code>n</code>: The number of false values in <code>x</code>.</li>
</ul>
<p><strong>returns</strong> An array of integers with elements having values between 1 and <span class="math inline">\(m\)</span>.</p>
<p>For an array of integers, <code>x</code>, return the indexes where mask is not true (<code>x[i] &lt;= 0</code>). The primary use of this function is where <code>x</code> represents indicators for missing values, and it is used to extract the indexes of non-missing values.</p>
<pre class="stan"><code>
int[] mask_indexes(int[] x, int n) {
  int idx[n];
  int j;
  j = 1;
  if (n &gt; 0) {
    for (i in 1:num_elements(x)) {
      if (! int_step(x[i]) &amp;&amp; j &lt;= n) {
        idx[j] = i;
        j = j + 1;
      }
    }
  }
  return idx;
}


</code></pre>
</div>
<div id="select_indexes" class="section level3">
<h3><span class="header-section-number">9.1.16</span> select_indexes</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: An array of length <span class="math inline">\(m\)</span> of integers</li>
<li><code>n</code>: The number of true values in <code>x</code>.</li>
</ul>
<p><strong>returns</strong> An array of integers with elements having values between 1 and <span class="math inline">\(m\)</span>.</p>
<p>For an array of integers, <code>x</code>, return the indexes where the elements are true (<code>x[i] &gt; 0</code>). The primary use of this function is where <code>x</code> represents indicators for non-missing values, and it is used to extract the indexes of non-missing values.</p>
<pre class="stan"><code>
int[] select_indexes(int[] x, int n) {
  int idx[n];
  int j;
  j = 1;
  if (n &gt; 0) {
    for (i in 1:num_elements(x)) {
      if (int_step(x[i]) &amp;&amp; j &lt;= n) {
        idx[j] = i;
        j = j + 1;
      }
    }
  }
  return idx;
}

</code></pre>
</div>
<div id="normal2_rng" class="section level3">
<h3><span class="header-section-number">9.1.17</span> normal2_rng</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu</code>: mean</li>
<li><code>sigma</code>: variance</li>
</ul>
<p><strong>returns</strong> A value drawn from the specified normal distribution.</p>
<p>Draw samples from a normal distribution with mean <code>mu</code> and scale <code>sigma</code>. Unlike the built-in <code>normal_rng()</code>, this allows for <code>sigma = 0</code>.</p>
<pre class="stan"><code>
real normal2_rng(real mu, real sigma) {
  real y;
  if (sigma &lt;= 0) {
    y = mu;
  } else {
    y = normal_rng(mu, sigma);
  }
  return y;
}

</code></pre>
</div>
<div id="cholesky_decompose2" class="section level3">
<h3><span class="header-section-number">9.1.18</span> cholesky_decompose2</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A</code>: An <span class="math inline">\(n \times n\)</span> matrix</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(n \times n\)</span> lower-triangular matrix</p>
<p>Calculate the Cholesky decomposition of a matrix. Unlike the built-in function, this handles cases in which the matrix has 0’s on the diagonal.</p>
<pre class="stan"><code>
matrix cholesky_decompose2(matrix A) {
  matrix[rows(A), cols(A)] L;
  int n;
  int nonzero[rows(A)];
  int num_nonzero;
  n = rows(A);
  for (i in 1:n) {
    nonzero[i] = (A[i, i] &gt; 0);
  }
  num_nonzero = sum(nonzero);
  if (num_nonzero == n) {
    L = cholesky_decompose(A);
  } else if (num_nonzero == 0) {
    L = rep_matrix(0.0, n, n);
  } else {
    int idx[num_nonzero];
    vector[n] eps;
    idx = select_indexes(nonzero, num_nonzero);
    L = rep_matrix(0.0, n, n);
    L[idx, idx] = cholesky_decompose(A[idx, idx]);
  }
  return L;
}


</code></pre>
</div>
<div id="multi_normal2_rng" class="section level3">
<h3><span class="header-section-number">9.1.19</span> multi_normal2_rng</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu</code>: An <span class="math inline">\(n \times 1\)</span> vector of the means</li>
<li><code>Sigma</code>: An <span class="math inline">\(n \times n\)</span> lower triangular matrix with covariance matrix.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(n \times 1\)</span> vector drawn from the specified multivariate normal distribution.</p>
<p>Sample from a multivariate normal distribution. Unlike the built-in <code>multi_normal_rng</code>, this function will still draw samples for deterministic elements in the vector.</p>
<pre class="stan"><code>
vector multi_normal2_rng(vector mu, matrix Sigma) {
  vector[num_elements(mu)] y;
  int n;
  int nonzero[num_elements(mu)];
  int num_nonzero;
  n = num_elements(mu);
  for (i in 1:n) {
    nonzero[i] = (Sigma[i, i] &gt; 0);
  }
  num_nonzero = sum(nonzero);
  if (num_nonzero == n) {
    y = multi_normal_rng(mu, Sigma);
  } else if (num_nonzero == 0) {
    y = mu;
  } else {
    int idx[num_nonzero];
    vector[n] eps;
    idx = select_indexes(nonzero, num_nonzero);
    eps = rep_vector(0.0, n);
    eps[idx] = multi_normal_rng(rep_vector(0.0, num_nonzero), Sigma[idx, idx]);
    y = mu + eps;
  }
  return y;
}

</code></pre>
</div>
<div id="multi_normal_cholesky2_rng" class="section level3">
<h3><span class="header-section-number">9.1.20</span> multi_normal_cholesky2_rng</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>mu</code>: An <span class="math inline">\(n \times 1\)</span> vector of the means</li>
<li><code>L</code>: An <span class="math inline">\(n \times n\)</span> lower triangular matrix with the Cholesky decomposition of the covariance matrix.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(n \times 1\)</span> vector drawn from the specified multivariate normal distribution.</p>
<p>Sample from a multivariate normal distribution, parameterized with the Cholesky decomposition of the covariance matrix. Unlike the built-in <code>multi_normal_cholesky_rng</code>, this function will still draw samples for deterministic elements in the vector.</p>
<pre class="stan"><code>
vector multi_normal_cholesky2_rng(vector mu, matrix L) {
  vector[num_elements(mu)] y;
  int n;
  int nonzero[num_elements(mu)];
  int num_nonzero;
  n = num_elements(mu);
  for (i in 1:n) {
    nonzero[i] = (L[i, i] &gt; 0);
  }
  num_nonzero = sum(nonzero);
  if (num_nonzero == n) {
    y = multi_normal_cholesky_rng(mu, L);
  } else if (num_nonzero == 0) {
    y = mu;
  } else {
    int idx[num_nonzero];
    vector[n] eps;
    idx = select_indexes(nonzero, num_nonzero);
    eps = rep_vector(0.0, n);
    eps[idx] = multi_normal_cholesky_rng(rep_vector(0.0, num_nonzero),
                                         L[idx, idx]);
    y = mu + eps;
  }
  return y;
}


</code></pre>
</div>
</div>
<div id="filtering" class="section level2">
<h2><span class="header-section-number">9.2</span> Filtering</h2>
<p>Functions used in filtering and log-likelihood calculations.</p>
<div id="ssm_update_a" class="section level3">
<h3><span class="header-section-number">9.2.1</span> ssm_update_a</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a</code>: An <span class="math inline">\(m \times 1\)</span> vector with the predicted state, <span class="math inline">\(\vec{a}_t\)</span>.</li>
<li><code>c</code>: An <span class="math inline">\(m \times 1\)</span> vector with the system intercept, <span class="math inline">\(\vec{c}_t\)</span></li>
<li><code>T</code>: An <span class="math inline">\(m \times m\)</span> matrix with the transition matrix, <span class="math inline">\(\mat{T}_t\)</span>.</li>
<li><code>v</code>: A <span class="math inline">\(p \times 1\)</span> vector with the forecast error, <span class="math inline">\(\vec{v}_t\)</span>.</li>
<li><code>K</code>: An <span class="math inline">\(m \times p\)</span> matrix with the Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(m \times 1\)</span> vector with the predicted state at <span class="math inline">\(t + 1\)</span>, <span class="math inline">\(\vec{a}_{t + 1}\)</span>.</p>
<p>Update the expected value of the predicted state, <span class="math inline">\(\vec{a}_{t + 1} = \E(\vec{\alpha}_{t + 1} | \vec{y}_{1:t})\)</span>,</p>
<p>The predicted state <span class="math inline">\(\vec{a}_{t + 1}\)</span> is, <span class="math display">\[
\vec{a}_{t + 1} = \mat{T}_t \vec{a}_t + \mat{K}_t \vec{v}_t + \vec{c}_t .
\]</span></p>
<pre class="stan"><code>
vector ssm_update_a(vector a, vector c, matrix T, vector v, matrix K) {
  vector[num_elements(a)] a_new;
  a_new = T * a + K * v + c;
  return a_new;
}

</code></pre>
</div>
<div id="ssm_update_a_u1" class="section level3">
<h3><span class="header-section-number">9.2.2</span> ssm_update_a_u1</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a</code>: An <span class="math inline">\(m \times 1\)</span> vector with the predicted state, <span class="math inline">\(\vec{a}_{t, i}\)</span>.</li>
<li><code>v</code>: The forecast error, <span class="math inline">\(v_{t, i}\)</span>.</li>
<li><code>K</code>: A <span class="math inline">\(m \times 1\)</span> vector with the Kalman gain, <span class="math inline">\(\vec{K}_{t,i}\)</span>, for element <span class="math inline">\(i\)</span> of <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times 1\)</span> vector with the predicted state <span class="math inline">\(\vec{a}_{t, i + 1}\)</span>.</p>
<p>Update <span class="math inline">\(\vec{a}_{t,i + 1}\)</span> from <span class="math inline">\(\vec{a}_{t, i}\)</span> in the unvariate filter.</p>
<pre class="stan"><code>vector ssm_update_a_u1(vector a, real v, vector K) {
  vector[num_elements(a)] a_new;
  a_new = a + K * v;
  return a_new;
}

</code></pre>
</div>
<div id="ssm_update_a_u2" class="section level3">
<h3><span class="header-section-number">9.2.3</span> ssm_update_a_u2</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a</code>: An <span class="math inline">\(m \times 1\)</span> vector with the predicted state, <span class="math inline">\(\vec{a}_{t, p + 1}\)</span>.</li>
<li><code>c</code>: An <span class="math inline">\(m \times 1\)</span> vector with the system intercept, <span class="math inline">\(\vec{c}_t\)</span></li>
<li><code>T</code>: An <span class="math inline">\(m \times m\)</span> matrix with the transition matrix, <span class="math inline">\(\mat{T}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times 1\)</span> vector with the predicted state at <span class="math inline">\(t + 1\)</span>, <span class="math inline">\(\vec{a}_{t + 1,1}\)</span>.</p>
<p>Update the predicted state to the next time period, <span class="math inline">\(\vec{a}_{t + 1,1}\)</span> from <span class="math inline">\(\vec{a}_{t, p + 1}\)</span>.</p>
<pre class="stan"><code>vector ssm_update_a_u2(vector a, vector c, matrix T) {
  vector[num_elements(a)] a_new;
  a_new = T * a + c;
  return a_new;
}



</code></pre>
</div>
<div id="ssm_update_p" class="section level3">
<h3><span class="header-section-number">9.2.4</span> ssm_update_P</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>P</code>: An <span class="math inline">\(m \times m\)</span> vector with the variance of the predicted state, <span class="math inline">\(\mat{P}_t\)</span>.</li>
<li><code>Z</code>: A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
<li><code>T</code>: An <span class="math inline">\(m \times m\)</span> matrix with the transition matrix, <span class="math inline">\(\mat{T}_t\)</span>.</li>
<li><code>RQR</code>: A <span class="math inline">\(m \times m\)</span> matrix with the system covariance matrix, <span class="math inline">\(\mat{R}_t \mat{Q}_t \mat{R}_t&#39;\)</span>.</li>
<li><code>K</code>: An <span class="math inline">\(m \times p\)</span> matrix with the Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times m\)</span> matrix with the variance of the state, <span class="math inline">\(\vec{P}_{t + 1}\)</span>.</p>
<p>Update the variance of the state in <span class="math inline">\(t + 1\)</span>, <span class="math inline">\(\mat{P}_{t + 1} = \Var(\alpha_{t + 1} | \vec{y}_{1:t})\)</span>,</p>
<p>The predicted state variance <span class="math inline">\(\mat{P}_{t + 1}\)</span> is, <span class="math display">\[
\mat{P}_{t + 1} = \mat{T}_t \mat{P}_t (\mat{T}_t - \mat{K}_t \mat{Z}_t)&#39; + \mat{R}_t \mat{Q}_t \mat{R}_t&#39; .
\]</span></p>
<pre class="stan"><code>
matrix ssm_update_P(matrix P, matrix Z, matrix T,
                           matrix RQR, matrix K) {
  matrix[rows(P), cols(P)] P_new;
  P_new = to_symmetric_matrix(T * P * (T - K * Z)&#39; + RQR);
  return P_new;
}

</code></pre>
</div>
<div id="ssm_update_p_u1" class="section level3">
<h3><span class="header-section-number">9.2.5</span> ssm_update_P_u1</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>P</code>: An <span class="math inline">\(m \times m\)</span> vector with the variance of the predicted state, <span class="math inline">\(\mat{P}_t\)</span>.</li>
<li><code>Finv</code>: The forecast precision, <span class="math inline">\(F_{t,i}^{-1}\)</span>.</li>
<li><code>K</code>: An <span class="math inline">\(m \times p\)</span> matrix with the Kalman gain, <span class="math inline">\(\mat{K}_{t,i}\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times m\)</span> matrix with the variance of the state, <span class="math inline">\(\vec{P}_{t, i + 1}\)</span>.</p>
<p>Update the variance of the state in a univariate filter after observing <span class="math inline">\(y_{t,i}\)</span>, <span class="math inline">\(\mat{P}_{t, i + 1} = \Var(\alpha_{t} | \vec{y}_{1:t - 1}, y_{t,i}, \dots, y_{t,i})\)</span>.</p>
<pre class="stan"><code>matrix ssm_update_P_u1(matrix P, real Finv, vector K) {
  matrix[rows(P), cols(P)] P_new;
  P_new = to_symmetric_matrix(P -  tcrossprod(to_matrix(K)) / Finv);
  return P_new;
}

</code></pre>
</div>
<div id="ssm_update_p_u2" class="section level3">
<h3><span class="header-section-number">9.2.6</span> ssm_update_P_u2</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>P</code>: An <span class="math inline">\(m \times m\)</span> vector with the variance of the state, <span class="math inline">\(\mat{P}_{t, p + 1}\)</span>.</li>
<li><code>T</code>: An <span class="math inline">\(m \times m\)</span> matrix with the transition matrix, <span class="math inline">\(\mat{T}_t\)</span>.</li>
<li><code>RQR</code>: A <span class="math inline">\(m \times m\)</span> matrix with the system covariance matrix, <span class="math inline">\(\mat{R}_t \mat{Q}_t \mat{R}_t&#39;\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times m\)</span> matrix with the variance of the state at <span class="math inline">\(t + 1\)</span> after observing <span class="math inline">\(\vec{y_t}\)</span>, <span class="math inline">\(\mat{P}_{t + 1,1}\)</span>.</p>
<p>Update the variance of the state in <span class="math inline">\(t + 1\)</span> in a univariate filter after observing <span class="math inline">\(y_{t}\)</span>, <span class="math inline">\(\mat{P}_{t, 1} = \Var(\alpha_{t + 1} | \vec{y}_{1:t})\)</span>.</p>
<pre class="stan"><code>matrix ssm_update_P_u2(matrix P, matrix T, matrix RQR) {
  matrix[rows(P), cols(P)] P_new;
  P_new = to_symmetric_matrix(quad_form(P, T&#39;) + RQR);
  return P_new;
}

</code></pre>
</div>
<div id="ssm_update_v" class="section level3">
<h3><span class="header-section-number">9.2.7</span> ssm_update_v</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>y</code>: A <span class="math inline">\(p \times 1\)</span> vector of the observations, <span class="math inline">\(\vec{y}_t\)</span>.</li>
<li><code>a</code>: A <span class="math inline">\(m \times 1\)</span> vector of the states, <span class="math inline">\(\vec{a}_t\)</span>.</li>
<li><code>d</code>: A <span class="math inline">\(p \times 1\)</span> vector with the observation intercept, <span class="math inline">\(\vec{d}_t\)</span>.</li>
<li><code>Z</code>: A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(p \times 1\)</span> vector of the forecast errors, <span class="math inline">\(\vec{v}_t\)</span>.</p>
<p>Update the forcast error, <span class="math inline">\(\vec{v}_t = \vec{y}_t - \E(\vec{y}_t | \vec{y_{1:(t - 1)}})\)</span></p>
<p>The forecast error <span class="math inline">\(\vec{v}_t\)</span> is <span class="math display">\[
\vec{v}_t =\vec{y}_t - \mat{Z}_t \vec{a}_t - \vec{d}_t .
\]</span></p>
<pre class="stan"><code>
vector ssm_update_v(vector y, vector a, vector d, matrix Z) {
  vector[num_elements(y)] v;
  v = y - Z * a - d;
  return v;
}


</code></pre>
</div>
<div id="ssm_update_v_u" class="section level3">
<h3><span class="header-section-number">9.2.8</span> ssm_update_v_u</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>y</code>: An observation, <span class="math inline">\(y_{t, j}\)</span>.</li>
<li><code>a</code>: A <span class="math inline">\(m \times 1\)</span> vector of the states, <span class="math inline">\(\vec{a}_t\)</span>.</li>
<li><code>d</code>: The observation intercept, <span class="math inline">\(d_{t,j}\)</span>.</li>
<li><code>Z</code>: A <span class="math inline">\(1 \times m\)</span> vector from the design matrix, <span class="math inline">\(\vec{Z}_{t, j}\)</span>.</li>
</ul>
<p><strong>returns</strong> The forecast errors, <span class="math inline">\(v_{t,j}\)</span>.</p>
<p>Update the forcast error in univariate filtering.</p>
<pre class="stan"><code>real ssm_update_v_u(real y, vector a, real d, row_vector Z) {
  real v;
  v = y - dot_product(Z, a) - d;
  return v;
}

</code></pre>
</div>
<div id="ssm_update_v_miss" class="section level3">
<h3><span class="header-section-number">9.2.9</span> ssm_update_v_miss</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>y</code>: A <span class="math inline">\(p \times 1\)</span> vector of the observations, <span class="math inline">\(\vec{y}_t\)</span>.</li>
<li><code>a</code>: A <span class="math inline">\(m \times 1\)</span> vector of the states, <span class="math inline">\(\vec{a}_t\)</span>.</li>
<li><code>d</code>: A <span class="math inline">\(p \times 1\)</span> vector with the observation intercept, <span class="math inline">\(\vec{d}_t\)</span>.</li>
<li><code>Z</code>: A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
<li><code>p_t</code>: The number of non-missing elements of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
<li><code>y_idx</code>: A length <span class="math inline">\(p\)</span> array of integers indexes with the indexes of thenon-missing values of <span class="math inline">\(y\)</span>. Elements <span class="math inline">\(1:p_t\)</span> should be between <span class="math inline">\(1\)</span> and <span class="math inline">\(p\)</span>; elements <span class="math inline">\(p_t:p\)</span> are zero, and are not used.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(p \times 1\)</span> vector of the forecast errors, <span class="math inline">\(\vec{v}_t\)</span>.</p>
<p>Update the forcast error, but unlike <code>ssm_update_v</code>, allow for missing values in <span class="math inline">\(\vec{y}_t\)</span>.</p>
<p>The elements of the forecast error <span class="math inline">\(\vec{v}_t\)</span> is <span class="math display">\[
\vec{v}_t =
\begin{cases}
  y_{j,t} - \vec{Z}_{j,.,t} \vec{a}_t - d_{j,t} &amp; \text{if $y_{j,t} not missing.} \
  0 &amp; \text{if $y_{j,t}$ is missing.}
\end{cases}
\]</span></p>
<pre class="stan"><code>
vector ssm_update_v_miss(vector y, vector a, vector d, matrix Z,
                                int p_t, int[] y_idx) {
  vector[num_elements(y)] v;
  int p;
  p = num_elements(y);
  if (p_t &lt; p) {
    v = rep_vector(0., p);
    if (p_t &gt; 0) {
      int idx[p_t];
      vector[p_t] y_star;
      vector[p_t] d_star;
      matrix[p_t, cols(Z)] Z_star;
      idx = y_idx[1:p_t];
      y_star = y[idx];
      d_star = d[idx];
      Z_star = Z[idx, :];
      v[idx] = ssm_update_v(y_star, a, d_star, Z_star);
    }
  } else {
    v = ssm_update_v(y, a, d, Z);
  }
  return v;
}

</code></pre>
</div>
<div id="ssm_update_f" class="section level3">
<h3><span class="header-section-number">9.2.10</span> ssm_update_F</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>P</code>: An <span class="math inline">\(m \times m\)</span> vector with the variance of the predicted state, <span class="math inline">\(\mat{P}_t\)</span>.</li>
<li><code>Z</code>: A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
<li><code>H</code>: A <span class="math inline">\(p \times p\)</span> matrix with the observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(p \times p\)</span> vector with <span class="math inline">\(\mat{F}_t\)</span>.</p>
<p>Update the variance of the forcast error, <span class="math inline">\(\mat{F}_t = \Var(\vec{y}_t - \E(\vec{y}_t | \vec{y_{1:(t - 1)}}))\)</span></p>
<p>The variance of the forecast error <span class="math inline">\(\mat{F}_t\)</span> is <span class="math display">\[
\mat{F}_t = \mat{Z}_t \mat{P}_t \mat{Z}_t + \mat{H}_t .
\]</span></p>
<pre class="stan"><code>
matrix ssm_update_F(matrix P, matrix Z, matrix H) {
  matrix[rows(H), cols(H)] F;
  F = to_symmetric_matrix(quad_form(P, Z&#39;) + H);
  return F;
}

</code></pre>
</div>
<div id="ssm_update_finv" class="section level3">
<h3><span class="header-section-number">9.2.11</span> ssm_update_Finv</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>P</code>: An <span class="math inline">\(m \times m\)</span> vector with the variance of the predicted state, <span class="math inline">\(\mat{P}_t\)</span>.</li>
<li><code>Z</code>: A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
<li><code>H</code>: A <span class="math inline">\(p \times p\)</span> matrix with the observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(p \times p\)</span> vector with <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</p>
<p>Update the precision of the forcast error, <span class="math inline">\(\mat{F}^{-1}_t = \Var(\vec{y}_t - \E(\vec{y}_t | \vec{y_{1:(t - 1)}}))^{-1}\)</span></p>
<p>This is the inverse of <span class="math inline">\(\mat{F}_t\)</span>.</p>
<pre class="stan"><code>
matrix ssm_update_Finv(matrix P, matrix Z, matrix H) {
  matrix[rows(H), cols(H)] Finv;
  // if can guarantee that F is spd, then take spd inverse.
  Finv = inverse_spd(to_symmetric_matrix(quad_form(P, Z&#39;) + H));
  // Finv = inverse(quad_form(P, Z&#39;) + H);
  return Finv;
}

</code></pre>
</div>
<div id="ssm_update_f_u" class="section level3">
<h3><span class="header-section-number">9.2.12</span> ssm_update_F_u</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>P</code>: An <span class="math inline">\(m \times m\)</span> vector with the variance of the predicted state, <span class="math inline">\(\mat{P}_t\)</span>.</li>
<li><code>Z</code>: A <span class="math inline">\(p \times 1\)</span> row vector from the design matrix, <span class="math inline">\(\mat{Z}_{t,i}\)</span>.</li>
<li><code>H</code>: A <span class="math inline">\(p \times p\)</span> matrix with the observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> The univariate forecast error, <span class="math inline">\(f_{t,j}\)</span>.</p>
<p>Update the variance of the univariate forcast error, <span class="math inline">\(f^{-1}_{t,i}\)</span>.</p>
<pre class="stan"><code>real ssm_update_F_u(matrix P, row_vector Z, real H) {
  return quad_form(P, Z&#39;) + H;
}


</code></pre>
</div>
<div id="ssm_update_finv_u" class="section level3">
<h3><span class="header-section-number">9.2.13</span> ssm_update_Finv_u</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>P</code>: An <span class="math inline">\(m \times m\)</span> vector with the variance of the predicted state, <span class="math inline">\(\mat{P}_t\)</span>.</li>
<li><code>Z</code>: A <span class="math inline">\(p \times 1\)</span> row vector from the design matrix, <span class="math inline">\(\mat{Z}_{t,j}\)</span>.</li>
<li><code>H</code>: A <span class="math inline">\(p \times p\)</span> matrix with the observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> The univariate forecast precision, <span class="math inline">\(f^{-1}_{t,j}\)</span>.</p>
<p>Update the precision of the univariate forcast error, <span class="math inline">\(f^{-1}_{t,j}\)</span>.</p>
<pre class="stan"><code>real ssm_update_Finv_u(matrix P, row_vector Z, real H) {
  return 1. / (quad_form(P, Z&#39;) + H);
}

</code></pre>
</div>
<div id="ssm_update_finv_miss" class="section level3">
<h3><span class="header-section-number">9.2.14</span> ssm_update_Finv_miss</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>P</code>: An <span class="math inline">\(m \times m\)</span> vector with the variance of the predicted state, <span class="math inline">\(\mat{P}_t\)</span>.</li>
<li><code>Z</code>: A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
<li><code>H</code>: A <span class="math inline">\(p \times p\)</span> matrix with the observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>.</li>
<li><code>p_t</code>: The number of non-missing elements in the observation vector, <span class="math inline">\(\vec{y}_t\)</span>.</li>
<li><code>y_idx</code>: A length <span class="math inline">\(p\)</span> array of integers. The first <span class="math inline">\(p_t\)</span> elments of this array indexes of thenon-missing values of <span class="math inline">\(y\)</span>. Elements <span class="math inline">\(1:p_t\)</span> should be between <span class="math inline">\(1\)</span> and <span class="math inline">\(p\)</span>; elements <span class="math inline">\(p_t:p\)</span> are zero, and are not used.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(p \times p\)</span> vector with <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</p>
<p>Update the precision of the forcast error. Unlike <code>ssm_update_Finv</code>, this allows for missing values in <code>\vec{y}_{t}</code>. If <span class="math inline">\(y_{k,t}\)</span> is missing, then <span class="math inline">\(F^{-1}_{i,j,t} = 0\)</span> for any <span class="math inline">\(i = k\)</span> or <span class="math inline">\(j = k\)</span>, otherwise it is the same as <span class="math inline">\(\mat{F}^{-1}\)</span> calculated after removing missing values.</p>
<p>This is the inverse of <span class="math inline">\(\mat{F}_t\)</span>.</p>
<pre class="stan"><code>
matrix ssm_update_Finv_miss(matrix P, matrix Z, matrix H,
                                   int p_t, int[] y_idx) {
  matrix[rows(H), cols(H)] Finv;
  int p;
  int m;
  p = rows(H);
  m = cols(Z);
  if (p_t &lt; p) {
    Finv = rep_matrix(0., p, p);
    if (p_t &gt; 0) {
      matrix[p_t, m] Z_star;
      matrix[p_t, p_t] H_star;
      int idx[p_t];
      idx = y_idx[1:p_t];
      Z_star = Z[idx, :];
      H_star = H[idx, idx];
      Finv[idx, idx] = ssm_update_Finv(P, Z_star, H_star);
    }
  } else {
    Finv = ssm_update_Finv(P, Z, H);
  }
  return Finv;
}

</code></pre>
</div>
<div id="ssm_update_k" class="section level3">
<h3><span class="header-section-number">9.2.15</span> ssm_update_K</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>P</code>: An <span class="math inline">\(m \times m\)</span> vector with the variance of the predicted state, <span class="math inline">\(P_t\)</span>.</li>
<li><code>Z</code>: A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
<li><code>T</code>: An <span class="math inline">\(m \times m\)</span> matrix with the transition matrix, <span class="math inline">\(\mat{T}_t\)</span>.</li>
<li><code>Finv</code>: A <span class="math inline">\(p \times p\)</span> matrix</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times p\)</span> matrix with the Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</p>
<p>Update the Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</p>
<p>The Kalman gain is <span class="math display">\[
\mat{K}_t = \mat{T}_t \mat{P}_t \mat{Z}_t&#39; \mat{F}^{-1}_t .
\]</span></p>
<pre class="stan"><code>
matrix ssm_update_K(matrix P, matrix Z, matrix T, matrix Finv) {
  matrix[cols(Z), rows(Z)] K;
  K = T * P * Z&#39; * Finv;
  return K;
}

</code></pre>
</div>
<div id="ssm_update_k_u" class="section level3">
<h3><span class="header-section-number">9.2.16</span> ssm_update_K_u</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>P</code>: An <span class="math inline">\(m \times m\)</span> vector with the variance of the predicted state, <span class="math inline">\(P_t\)</span>.</li>
<li><code>Z</code>: A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
<li><code>Finv</code>: $ matrix</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times p\)</span> matrix with the Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</p>
<p>Update the Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>, in univiariate filtering.</p>
<pre class="stan"><code>
vector ssm_update_K_u(matrix P, row_vector Z, real Finv) {
  vector[num_elements(Z)] K;
  K = P * Z&#39; * Finv;
  return K;
}


</code></pre>
</div>
<div id="ssm_update_l" class="section level3">
<h3><span class="header-section-number">9.2.17</span> ssm_update_L</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>Z</code>: A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span></li>
<li><code>T</code>: An <span class="math inline">\(m \times m\)</span> matrix with the transition matrix, <span class="math inline">\(\mat{T}_t\)</span>.</li>
<li><code>K</code>: An <span class="math inline">\(m \times p\)</span> matrix with the Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times m\)</span> matrix, <span class="math inline">\(\mat{L}_t\)</span>.</p>
<p>Update <span class="math inline">\(L_t\)</span></p>
<p><span class="math display">\[
\mat{L}_t = \mat{T}_t - \mat{K}_t \mat{Z}_t .
\]</span></p>
<pre class="stan"><code>
matrix ssm_update_L(matrix Z, matrix T, matrix K) {
  matrix[rows(T), cols(T)] L;
  L = T - K * Z;
  return L;
}

</code></pre>
</div>
<div id="ssm_update_l_u" class="section level3">
<h3><span class="header-section-number">9.2.18</span> ssm_update_L_u</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>Z</code>: A <span class="math inline">\(1 \times m\)</span> row vector from the design matrix, <span class="math inline">\(\vec{Z}_{t,i}\)</span></li>
<li><code>K</code>: An <span class="math inline">\(m \times 1\)</span> matrix with the Kalman gain, <span class="math inline">\(\vec{K}_{t,i}\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times m\)</span> matrix, <span class="math inline">\(\mat{L}_{t,i}\)</span>.</p>
<p>Update <span class="math inline">\(L_t\)</span> for univariate filtering, <span class="math display">\[
\mat{L}_t = \mat{I}_m - \vec{K}_{t,i}\vec{Z}_{t,i}
\]</span> See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, 157)</span></p>
<pre class="stan"><code>
matrix ssm_update_L_u(row_vector Z, vector K) {
  matrix[num_elements(Z), num_elements(Z)] L;
  int m;
  m = num_elements(Z);
  L = diag_matrix(rep_vector(1., m)) - K * Z;
  return L;
}

</code></pre>
</div>
<div id="ssm_update_loglik" class="section level3">
<h3><span class="header-section-number">9.2.19</span> ssm_update_loglik</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>v</code>: A <span class="math inline">\(p \times 1\)</span> matrix with the forecast error, <span class="math inline">\(\vec{v}_t\)</span>.</li>
<li><code>Finv</code>: A <span class="math inline">\(p \times p\)</span> matrix with variance of the forecast error, <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> The log-likelihood</p>
<p>Calculate the log-likelihood of a single observation in a State-space model</p>
<p>The log-likehood of a single observation in a state-space model is <span class="math display">\[
\ell_t = - \frac{1}{2} p \log(2 \pi) - \frac{1}{2} \left(\log|\mat{F}_t| + \vec{v}_t&#39; \mat{F}^{-1}_t \vec{v}_t  \right)
\]</span></p>
<pre class="stan"><code>
real ssm_update_loglik(vector v, matrix Finv) {
  real ll;
  int p;
  p = num_elements(v);
  // det(A^{-1}) = 1 / det(A) -&gt; log det(A^{-1}) = - log det(A)
  ll = (- 0.5 *
        (p * log(2 * pi())
         - log_determinant(Finv)
         + quad_form_sym(Finv, v)
       ));
  return ll;
}

</code></pre>
</div>
<div id="ssm_update_loglik_miss" class="section level3">
<h3><span class="header-section-number">9.2.20</span> ssm_update_loglik_miss</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>v</code>: A <span class="math inline">\(p \times 1\)</span> matrix with the forecast error, <span class="math inline">\(\vec{v}_t\)</span>.</li>
<li><code>Finv</code>: A <span class="math inline">\(p \times p\)</span> matrix with variance of the forecast error, <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</li>
<li><code>p_t</code>: The number of non-missing elements in the observation vector, <span class="math inline">\(\vec{y}_t\)</span>.</li>
<li><code>y_idx</code>: A length <span class="math inline">\(p\)</span> array of integers. The first <span class="math inline">\(p_t\)</span> elments of this array indexes of thenon-missing values of <span class="math inline">\(y\)</span>. Elements <span class="math inline">\(1:p_t\)</span> should be between <span class="math inline">\(1\)</span> and <span class="math inline">\(p\)</span>; elements <span class="math inline">\(p_t:p\)</span> are zero, and are not used.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(p \times p\)</span> vector with <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</p>
<p>Calculate the log-likelihood of a single observation in a State-space model</p>
<p>Unlike <code>ssm_update_loglik</code>, this allows for missing values.</p>
<pre class="stan"><code>
real ssm_update_loglik_miss(vector v, matrix Finv, int p_t, int[] y_idx) {
  real ll;
  int p;
  p = num_elements(v);
  if (p_t == 0) {
    ll = 0.;
  } else if (p_t == p) {
    ll = ssm_update_loglik(v, Finv);
  } else {
    int idx[p_t];
    matrix[p_t, p_t] Finv_star;
    vector[p_t] v_star;
    idx = y_idx[1:p_t];
    Finv_star = Finv[idx, idx];
    v_star = v[idx];
    ll = ssm_update_loglik(v_star, Finv_star);
  }
  return ll;
}

</code></pre>
</div>
<div id="ssm_update_loglik_u" class="section level3">
<h3><span class="header-section-number">9.2.21</span> ssm_update_loglik_u</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>v</code>: The forecast error, <span class="math inline">\(v_{t,i}\)</span>.</li>
<li><code>Finv</code>: The forecast error, <span class="math inline">\(f^{-1}_{t,i}\)</span>.</li>
</ul>
<p><strong>returns</strong> The log-likelihood</p>
<p>Calculate the log-likelihood of a single observation using univariate filtering.</p>
<pre class="stan"><code>
real ssm_update_loglik_u(real v, real Finv) {
  real ll;
  // det(A^{-1}) = 1 / det(A) -&gt; log det(A^{-1}) = - log det(A)
  ll = (- 0.5 * (
         log(2 * pi())
         - log(Finv)
         + Finv * pow(v, 2)
       ));
  return ll;
}


</code></pre>
</div>
</div>
<div id="filtering-1" class="section level2">
<h2><span class="header-section-number">9.3</span> Filtering</h2>
<div id="ssm_filter_idx" class="section level3">
<h3><span class="header-section-number">9.3.1</span> ssm_filter_idx</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>m</code>: The number of states</li>
<li><code>p</code>: The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(6 \times 3\)</span> integer array containing the indexes of the return values of the Kalman filter.</p>
<p>Indexes of the return values of the Kalman filter functions: <code>ssm_filter</code>.</p>
<p><code>ssm_filter_idx</code> returns a <span class="math inline">\(6 \times 3\)</span> integer array with the (length, start index, stop index) of (<span class="math inline">\(\ell_t\)</span>, <span class="math inline">\(\vec{v}\)</span>, <span class="math inline">\(\vec{F}^-1\)</span>, <span class="math inline">\(\mat{K}\)</span>, <span class="math inline">\(\vec{a}\)</span>, <span class="math inline">\(\mat{P}\)</span>).</p>
<table>
<thead>
<tr class="header">
<th align="left">value</th>
<th align="left">length</th>
<th align="left">start</th>
<th align="left">stop</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(\ell_t\)</span></td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left"><span class="math inline">\(1\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\vec{v}\)</span></td>
<td align="left"><span class="math inline">\(p\)</span></td>
<td align="left"><span class="math inline">\(2\)</span></td>
<td align="left"><span class="math inline">\(1 + p\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\mat{F}^{-1}\)</span></td>
<td align="left"><span class="math inline">\(p (p + 1) / 2\)</span></td>
<td align="left"><span class="math inline">\(2 + p\)</span></td>
<td align="left"><span class="math inline">\(1 + p + p (p + 1) / 2\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mat{K}\)</span></td>
<td align="left"><span class="math inline">\(mp\)</span></td>
<td align="left"><span class="math inline">\(2 + p + p (p + 1) / 2\)</span></td>
<td align="left"><span class="math inline">\(1 + p + p (p + 1) / 2 + mp\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\vec{a}_t\)</span></td>
<td align="left"><span class="math inline">\(m\)</span></td>
<td align="left"><span class="math inline">\(2 + p + p (p + 1) / 2 + mp\)</span></td>
<td align="left"><span class="math inline">\(1 + p + p (p + 1) / 2 + mp + m\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mat{P}^t\)</span></td>
<td align="left"><span class="math inline">\(m (m + 1) / 2\)</span></td>
<td align="left"><span class="math inline">\(2 + p + p (p + 1) / 2 + mp + m\)</span></td>
<td align="left"><span class="math inline">\(1 + p + p (p + 1) / 2 + mp + m (m + 1) / 2\)</span></td>
</tr>
</tbody>
</table>
<pre class="stan"><code>
int[,] ssm_filter_idx(int m, int p) {
  int sz[6, 3];
  // loglike
  sz[1, 1] = 1;
  // v
  sz[2, 1] = p;
  // Finv
  sz[3, 1] = symmat_size(p);
  // K
  sz[4, 1] = m * p;
  // a
  sz[5, 1] = m;
  // P
  sz[6, 1] = symmat_size(m);
  // Fill in start and stop points
  sz[1, 2] = 1;
  sz[1, 3] = sz[1, 2] + sz[1, 1] - 1;
  for (i in 2:6) {
    sz[i, 2] = sz[i - 1, 3] + 1;
    sz[i, 3] = sz[i, 2] + sz[i, 1] - 1;
  }
  return sz;
}

</code></pre>
</div>
<div id="ssm_filter_size" class="section level3">
<h3><span class="header-section-number">9.3.2</span> ssm_filter_size</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>m</code>: The number of states</li>
<li><code>p</code>: The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> The number of elements in the vector.</p>
<p>Number of elements in vector containing filter results</p>
<pre class="stan"><code>
int ssm_filter_size(int m, int p) {
  int sz;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  sz = idx[6, 3];
  return sz;
}

</code></pre>
</div>
<div id="ssm_filter_get_loglik" class="section level3">
<h3><span class="header-section-number">9.3.3</span> ssm_filter_get_loglik</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: A vector with results from <code>ssm_filter</code>.</li>
<li><code>m</code>: The number of states</li>
<li><code>p</code>: The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> The log-likelihood <span class="math inline">\(\ell_t\)</span></p>
<p>Get the log-likehood from the results of <code>ssm_filter</code>.</p>
<pre class="stan"><code>
real ssm_filter_get_loglik(vector x, int m, int p) {
  real y;
  y = x[1];
  return y;
}

</code></pre>
</div>
<div id="ssm_filter_get_v" class="section level3">
<h3><span class="header-section-number">9.3.4</span> ssm_filter_get_v</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: vector with results from <code>ssm_filter</code>.</li>
<li><code>m</code>: The number of states</li>
<li><code>p</code>: The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(p \times 1\)</span> vector with the forecast error, <span class="math inline">\(\vec{v}_t\)</span>.</p>
<p>Get the forecast error from the results of <code>ssm_filter</code>.</p>
<pre class="stan"><code>
vector ssm_filter_get_v(vector x, int m, int p) {
  vector[p] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = segment(x, idx[2, 2], idx[2, 1]);
  return y;
}

</code></pre>
</div>
<div id="ssm_filter_get_finv" class="section level3">
<h3><span class="header-section-number">9.3.5</span> ssm_filter_get_Finv</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: vector with results from <code>ssm_filter</code>.</li>
<li><code>m</code>: The number of states</li>
<li><code>p</code>: The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(p \times p\)</span> matrix with the forecast precision, <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</p>
<p>Get the forecast precision from the results of <code>ssm_filter</code>.</p>
<pre class="stan"><code>
matrix ssm_filter_get_Finv(vector x, int m, int p) {
  matrix[p, p] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = vector_to_symmat(segment(x, idx[3, 2], idx[3, 1]), p);
  return y;
}

</code></pre>
</div>
<div id="ssm_filter_get_k" class="section level3">
<h3><span class="header-section-number">9.3.6</span> ssm_filter_get_K</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: vector with results from <code>ssm_filter</code>.</li>
<li><code>m</code>: The number of states</li>
<li><code>p</code>: The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(m \times p\)</span> matrix with the Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</p>
<p>Get the Kalman gain from the results of <code>ssm_filter</code>.</p>
<pre class="stan"><code>
matrix ssm_filter_get_K(vector x, int m, int p) {
  matrix[m, p] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = to_matrix_colwise(segment(x, idx[4, 2], idx[4, 1]), m, p);
  return y;
}

</code></pre>
</div>
<div id="ssm_filter_get_a" class="section level3">
<h3><span class="header-section-number">9.3.7</span> ssm_filter_get_a</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: vector with results from <code>ssm_filter</code>.</li>
<li><code>m</code>: The number of states</li>
<li><code>p</code>: The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times 1\)</span> vector with the expected value of the predicted state, <span class="math inline">\(\E(\vec{\alpha}_t | \vec{y}_{1:(t-1)}) = \vec{a}_t\)</span>.</p>
<p>Get the expected value of the predicted state from the results of <code>ssm_filter</code>.</p>
<pre class="stan"><code>
vector ssm_filter_get_a(vector x, int m, int p) {
  vector[m] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = segment(x, idx[5, 2], idx[5, 1]);
  return y;
}

</code></pre>
</div>
<div id="ssm_filter_get_p" class="section level3">
<h3><span class="header-section-number">9.3.8</span> ssm_filter_get_P</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: vector with results from <code>ssm_filter</code>.</li>
<li><code>m</code>: The number of states</li>
<li><code>p</code>: The size of the observation vector <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times m\)</span> matrix with the variance of the predicted state, <span class="math inline">\(\Var(\vec{\alpha}_t | \vec{y}_{1:(t-1)}) = \mat{P}_t\)</span>.</p>
<p>Get the variance of the predicted state from the results of <code>ssm_filter</code>.</p>
<pre class="stan"><code>
matrix ssm_filter_get_P(vector x, int m, int p) {
  matrix[m, m] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = vector_to_symmat(segment(x, idx[6, 2], idx[6, 1]), m);
  return y;
}

</code></pre>
</div>
<div id="ssm_filter" class="section level3">
<h3><span class="header-section-number">9.3.9</span> ssm_filter</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>y</code>: Observations, <span class="math inline">\(\vec{y}_t\)</span>. An array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>d</code>: Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>H</code>: Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>c</code>: State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>a1</code>: Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>P1</code>: Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>returns</strong> Array of size <span class="math inline">\(n\)</span> of <span class="math inline">\((1 + p + p (p + 1) / 2 + mp + m + m (m + 1) / 2) \times 1\)</span> vectors in the format described in <code>ssm_filter_idx</code>.</p>
<p>Kalman filter</p>
<p>For <code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>d</code>, <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p><code>ssm_filter</code> runs a forward filter on the state space model and calculates,</p>
<ul>
<li>log-likelihood for each observation, <span class="math inline">\(\ell_t\)</span>.</li>
<li>Forecast error, <span class="math inline">\(\vec{v}_t = \vec{y}_t - \E(\vec{y}_t | \vec{y}_{1:(t -1)})\)</span>.</li>
<li>Forecast precision, <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</li>
<li>Kalman gain, <span class="math inline">\(\mat{K}_t\)</span>.</li>
<li>Predicted states, <span class="math inline">\(\vec{a}_t = \E(\vec{\alpha}_t | \vec{y}_{1:(t -1)})\)</span>.</li>
<li>Variance of the predicted states, <span class="math inline">\(\mat{P}_t = \Var(\vec{\alpha}_t | \vec{y}_{1:(t -1)})\)</span>.</li>
</ul>
<p>The results of Kalman filter for a given are returned as a <span class="math inline">\(1 + p + p (p + 1) / 2 + m p + m (m + 1) / 2\)</span> vector for each time period, where <span class="math display">\[
(\ell_t, \vec{v}_t&#39;, \VEC(\mat{F}^{-1}_t)&#39;, \VEC(\mat{K}_t)&#39;, \vec{a}_t&#39;, \VEC(\mat{P}_t)&#39; )&#39;.
\]</span></p>
<pre class="stan"><code>
vector[] ssm_filter(vector[] y,
                    vector[] d, matrix[] Z, matrix[] H,
                    vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                    vector a1, matrix P1) {

  // returned data
  vector[ssm_filter_size(dims(Z)[3], dims(Z)[2])] res[size(y)];
  int q;
  int n;
  int p;
  int m;

  // sizes
  n = size(y); // number of obs
  m = dims(Z)[3]; // number of states
  p = dims(Z)[2]; // obs size
  q = dims(Q)[2]; // number of state disturbances

  //print(&quot;Sizes: n = &quot;, m, &quot;, p = &quot;, n, &quot;, m = &quot;, m, &quot;, q = &quot;, q);
  {
    // system matrices for current iteration
    vector[p] d_t;
    matrix[p, m] Z_t;
    matrix[p, p] H_t;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // result matricees for each iteration
    vector[m] a;
    matrix[m, m] P;
    vector[p] v;
    matrix[p, p] Finv;
    matrix[m, p] K;
    real ll;
    int idx[6, 3];

    idx = ssm_filter_idx(m, p);

    d_t = d[1];
    Z_t = Z[1];
    H_t = H[1];
    c_t = c[1];
    T_t = T[1];
    R_t = R[1];
    Q_t = Q[1];
    RQR = quad_form_sym(Q_t, R_t &#39;);
    a = a1;
    P = P1;
    for (t in 1:n) {
      if (t &gt; 1) {
        if (size(d) &gt; 1) {
          d_t = d[t];
        }
        if (size(Z) &gt; 1) {
          Z_t = Z[t];
        }
        if (size(H) &gt; 1) {
          H_t = H[t];
        }
        if (size(c) &gt; 1) {
          c_t = c[t];
        }
        if (size(T) &gt; 1) {
          T_t = T[t];
        }
        if (size(R) &gt; 1) {
          R_t = R[t];
        }
        if (size(Q) &gt; 1) {
          Q_t = Q[t];
        }
        if (size(R) &gt; 1 || size(Q) &gt; 1) {
          RQR = quad_form_sym(Q_t, R_t &#39;);
        }
      }
      // updating
      v = ssm_update_v(y[t], a, d_t, Z_t);
      Finv = ssm_update_Finv(P, Z_t, H_t);
      K = ssm_update_K(P, Z_t, T_t, Finv);
      ll = ssm_update_loglik(v, Finv);
      // saving
      res[t, 1] = ll;
      res[t, idx[2, 2]:idx[2, 3]] = v;
      res[t, idx[3, 2]:idx[3, 3]] = symmat_to_vector(Finv);
      res[t, idx[4, 2]:idx[4, 3]] = to_vector(K);
      res[t, idx[5, 2]:idx[5, 3]] = a;
      res[t, idx[6, 2]:idx[6, 3]] = symmat_to_vector(P);
      // predict a_{t + 1}, P_{t + 1}
      if (t &lt; n) {
        a = ssm_update_a(a, c_t, T_t, v, K);
        P = ssm_update_P(P, Z_t, T_t, RQR, K);
      }
    }
  }
  return res;
}

</code></pre>
</div>
<div id="ssm_filter_miss" class="section level3">
<h3><span class="header-section-number">9.3.10</span> ssm_filter_miss</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>y</code>: Observations, <span class="math inline">\(\vec{y}_t\)</span>. An array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>d</code>: Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>H</code>: Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>c</code>: State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>a1</code>: Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>P1</code>: Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
<li><code>p_t</code>: A length <span class="math inline">\(n\)</span> array with the number of non-missing elements in the observation vector, <span class="math inline">\(\vec{y}_t\)</span>, at each <span class="math inline">\(t \in 1, \dots, n\)</span>.</li>
<li><code>y_idx</code>: A length <span class="math inline">\(n \times p\)</span> array of integers. The first <span class="math inline">\(p_t\)</span> elments of this array indexes of thenon-missing values of <span class="math inline">\(y\)</span>. Elements <span class="math inline">\(1:p_t\)</span> should be between <span class="math inline">\(1\)</span> and <span class="math inline">\(p\)</span>; elements <span class="math inline">\(p_t:p\)</span> are zero, and are not used.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(p \times p\)</span> vector with <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</p>
<p>The function <code>ssm_filter_miss</code> runs a Kalman filter like <code>ssm_filter</code>, except that it allows for missing values.</p>
<p>In the Kalman filter with missing values, the observation equation is, <span class="math display">\[
\begin{aligned}[t]
\vec{y}^*_{t} &amp;= \vec{d}^*_{t} + \mat{Z}^*_{t} \vec{\alpha}_t + \vec{\varepsilon}^*_t \\
\vec{\varepsilon}^*_t &amp;\sim N(\vec{0}, \mat{H}^*_t)
\end{aligned}
\]</span> where <span class="math inline">\(\vec{y}^*_{t} = \mat{W}_t \vec{y}_t\)</span>, <span class="math inline">\(\vec{d}^*_t = \mat{W}_t \vec{d}_t\)</span>, <span class="math inline">\(\mat{Z}^*_t = \mat{W}_t \mat{Z}_t\)</span>, <span class="math inline">\(\mat{H}^*_t = \mat{W}_t \mat{H}_t \mat{W}_t\T\)</span>, where <span class="math inline">\(\mat{W}_t\)</span> selects the non-missing rows of <span class="math inline">\(\vec{y}_t\)</span>.</p>
<p>If all observations</p>
<p>If <span class="math inline">\(y_{t,j}\)</span> is missing, then</p>
<ul>
<li><span class="math inline">\(v_{t,j} = 0\)</span></li>
<li><span class="math inline">\(F^{-1}_{t,.,j} = \vec{0}_{p}\)</span> and F^{-1}<em>{t,j,.} = </em>{p}$ if either $i</li>
<li><span class="math inline">\(K_{t,.,j} = \vec{0}_{m}\)</span></li>
</ul>
<pre class="stan"><code>
vector[] ssm_filter_miss(vector[] y,
                          vector[] d, matrix[] Z, matrix[] H,
                          vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                          vector a1, matrix P1, int[] p_t, int[,] y_idx) {

  // returned data
  vector[ssm_filter_size(dims(Z)[3], dims(Z)[2])] res[size(y)];
  int q;
  int n;
  int p;
  int m;

  // sizes
  n = size(y); // number of obs
  m = dims(Z)[3]; // number of states
  p = dims(Z)[2]; // obs size
  q = dims(Q)[2]; // number of state disturbances

  //print(&quot;Sizes: n = &quot;, m, &quot;, p = &quot;, n, &quot;, m = &quot;, m, &quot;, q = &quot;, q);
  {
    // system matrices for current iteration
    vector[p] d_t;
    matrix[p, m] Z_t;
    matrix[p, p] H_t;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // result matricees for each iteration
    vector[m] a;
    matrix[m, m] P;
    vector[p] v;
    matrix[p, p] Finv;
    matrix[m, p] K;
    real ll;
    int idx[6, 3];
    idx = ssm_filter_idx(m, p);
    d_t = d[1];
    Z_t = Z[1];
    H_t = H[1];
    c_t = c[1];
    T_t = T[1];
    R_t = R[1];
    Q_t = Q[1];
    RQR = quad_form_sym(Q_t, R_t &#39;);
    a = a1;
    P = P1;
    for (t in 1:n) {
      if (t &gt; 1) {
        if (size(d) &gt; 1) {
          d_t = d[t];
        }
        if (size(Z) &gt; 1) {
          Z_t = Z[t];
        }
        if (size(H) &gt; 1) {
          H_t = H[t];
        }
        if (size(c) &gt; 1) {
          c_t = c[t];
        }
        if (size(T) &gt; 1) {
          T_t = T[t];
        }
        if (size(R) &gt; 1) {
          R_t = R[t];
        }
        if (size(Q) &gt; 1) {
          Q_t = Q[t];
        }
        if (size(R) &gt; 1 || size(Q) &gt; 1) {
          RQR = quad_form_sym(Q_t, R_t &#39;);
        }
      }
      // updating
      v = ssm_update_v_miss(y[t], a, d_t, Z_t, p_t[t], y_idx[t]);
      Finv = ssm_update_Finv_miss(P, Z_t, H_t, p_t[t], y_idx[t]);
      K = ssm_update_K(P, Z_t, T_t, Finv);
      ll = ssm_update_loglik_miss(v, Finv, p_t[t], y_idx[t]);
      // saving
      res[t, 1] = ll;
      res[t, idx[2, 2]:idx[2, 3]] = v;
      res[t, idx[3, 2]:idx[3, 3]] = symmat_to_vector(Finv);
      res[t, idx[4, 2]:idx[4, 3]] = to_vector(K);
      res[t, idx[5, 2]:idx[5, 3]] = a;
      res[t, idx[6, 2]:idx[6, 3]] = symmat_to_vector(P);
      // predict a_{t + 1}, P_{t + 1}
      if (t &lt; n) {
        a = ssm_update_a(a, c_t, T_t, v, K);
        P = ssm_update_P(P, Z_t, T_t, RQR, K);
      }
    }
  }
  return res;
}

</code></pre>
</div>
<div id="ssm_filter_states_size" class="section level3">
<h3><span class="header-section-number">9.3.11</span> ssm_filter_states_size</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>m</code>: Number of states</li>
</ul>
<p><strong>returns</strong> The size of the vector</p>
<p>Length of the vectors returned by <code>ssm_filter_states</code>.</p>
<pre class="stan"><code>
int ssm_filter_states_size(int m) {
  int sz;
  sz = m + symmat_size(m);
  return sz;
}

</code></pre>
</div>
<div id="ssm_filter_states_get_a" class="section level3">
<h3><span class="header-section-number">9.3.12</span> ssm_filter_states_get_a</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: A vector returned by <code>ssm_filter_states</code></li>
<li><code>m</code>: Number of states</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times 1\)</span> vector with the filtered expected value of the state, <span class="math inline">\(\vec{a}_{t|t} = \E(\vec{\alpha}_t | \vec{y}_{1:t})\)</span>.</p>
<p>Extract <span class="math inline">\(a_{t|t}\)</span> from the results of <code>ssm_filter_states</code></p>
<pre class="stan"><code>
vector ssm_filter_states_get_a(vector x, int m) {
  vector[m] a;
  a = x[ :m];
  return a;
}

</code></pre>
</div>
<div id="ssm_filter_states_get_p" class="section level3">
<h3><span class="header-section-number">9.3.13</span> ssm_filter_states_get_P</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: A vector returned by <code>ssm_filter_states</code></li>
<li><code>m</code>: Number of states</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times m\)</span> matrix with the filtered variance of the state, <span class="math inline">\(\mat{P}_{t|t} = \Var(\vec{\alpha}_t | \vec{y}_{1:t})\)</span>.</p>
<p>Extract <span class="math inline">\(P_{t|t}\)</span> from the results of <code>ssm_filter_states</code></p>
<pre class="stan"><code>
matrix ssm_filter_states_get_P(vector x, int m) {
  matrix[m, m] P;
  P = vector_to_symmat(x[(m + 1): ], m);
  return P;
}

</code></pre>
</div>
<div id="ssm_filter_states_update_a" class="section level3">
<h3><span class="header-section-number">9.3.14</span> ssm_filter_states_update_a</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>a</code>: An <span class="math inline">\(m \times 1\)</span> vector with the expected value of the predicted state, <span class="math inline">\(\vec{a}_t\)</span>.</li>
<li><code>P</code>: An <span class="math inline">\(m \times m\)</span> vector with the variance of the predicted state, <span class="math inline">\(\mat{P}_t\)</span>.</li>
<li><code>Z</code>: A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
<li><code>v</code>: A <span class="math inline">\(p \times 1\)</span> vector with the forecast errors, <span class="math inline">\(\vec{v}_t\)</span></li>
<li><code>Finv</code>: A <span class="math inline">\(p \times p\)</span> matrix with the forecast prediction, <span class="math inline">\(\mat{F}_{t}^{-1}\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times 1\)</span> matrix the expected value of the fitered states, <span class="math inline">\(\E(\vec{alpha}_t | \vec{y}_{1:t}) = \vec{a}_{t|t}\)</span>.</p>
<p>Calculate filtered state values <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.3.2)</span>, <span class="math display">\[
\E(\vec{alpha}_t | \vec{y}_{1:t}) = \vec{a}_{t|t} = \mat{T}_t \vec{a}_t + \mat{K}_t \vec{v}_t .
\]</span></p>
<pre class="stan"><code>
vector ssm_filter_states_update_a(vector a, matrix P, matrix Z,
                                  vector v, matrix Finv) {
  vector[num_elements(a)] aa;
  aa = a + P * Z &#39; * Finv * v;
  return aa;
}

</code></pre>
</div>
<div id="ssm_filter_states_update_p" class="section level3">
<h3><span class="header-section-number">9.3.15</span> ssm_filter_states_update_P</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>P</code>: An <span class="math inline">\(m \times m\)</span> vector with the variance of the predicted state, <span class="math inline">\(\mat{P}_t\)</span>.</li>
<li><code>Z</code>: A <span class="math inline">\(p \times m\)</span> matrix with the design matrix, <span class="math inline">\(\mat{Z}_t\)</span>.</li>
<li><code>Finv</code>: A <span class="math inline">\(p \times p\)</span> matrix with the forecast prediction, <span class="math inline">\(\mat{F}_{t}^{-1}\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times m\)</span> matrix with variance of the filtered states, <span class="math inline">\(\Var(\vec{alpha}_t | \vec{y}_{1:t}) = \mat{P}_{t|t}\)</span>.</p>
<p>Calculate filtered state variance values <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.3.2)</span>, <span class="math display">\[
\Var(\vec{alpha}_t | \vec{y}_{1:t}) = \mat{P}_{t|t} = \mat{P}_t - \mat{P}_t \mat{Z}_t&#39; \mat{F}_t^{-1} \mat{Z}_t \mat{P}_t .
\]</span></p>
<pre class="stan"><code>
matrix ssm_filter_states_update_P(matrix P, matrix Z, matrix Finv) {
  matrix[rows(P), cols(P)] PP;
  PP = to_symmetric_matrix(P - P * quad_form_sym(Finv, Z) * P);
  return PP;
}


</code></pre>
</div>
<div id="ssm_filter_states" class="section level3">
<h3><span class="header-section-number">9.3.16</span> ssm_filter_states</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>filter</code>: Results from <code>ssm_filter</code></li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
</ul>
<p><strong>returns</strong> of size <span class="math inline">\(n\)</span> of vectors.</p>
<p>Calculate filtered expected values and variances of the states</p>
<p>The filtering function <code>ssm_filter</code> returns the mean and variance of the predicted states, <span class="math inline">\(\vec{a}_t = \E(\vec{\alpha}_t | \vec{y}_{1:(t -1)})\)</span> and <span class="math inline">\(\mat{P}_t = \Var(\vec{\alpha}_t | \vec{y}_{1:(t -1)})\)</span>.</p>
<p>The vectors returned by <code>ssm_filter_states</code> are of length <span class="math inline">\(m + m ^ 2\)</span>, with <span class="math display">\[
\vec{v}_t = (\vec{a}_{t|t}&#39;, \VEC(\vec{P}_{t|t})&#39; )&#39;
\]</span> Use the functions <code>ssm_filter_states_get_a</code> and <code>ssm_filter_states_get_P</code> to extract elements from the results.</p>
<p>For <code>Z</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n - 1\)</span> if it is time varying.</p>
<pre class="stan"><code>
vector[] ssm_filter_states(vector[] filter, matrix[] Z) {
  vector[ssm_filter_states_size(dims(Z)[3])] res[size(filter)];
  int n;
  int m;
  int p;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  {
    // system matrices for current iteration
    matrix[p, m] Z_t;
    // filter matrices
    vector[p] v;
    matrix[p, p] Finv;
    vector[m] a;
    matrix[m, m] P;

    Z_t = Z[1];
    for (t in 1:n) {
      if (t &gt; 1) {
        if (size(Z) &gt; 1) {
          Z_t = Z[t];
        }
      }
      // extract values from the filter
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      a = ssm_filter_get_a(filter[t], m, p);
      P = ssm_filter_get_P(filter[t], m, p);
      // calcualte filtered values
      a = ssm_filter_states_update_a(a, P, Z_t, v, Finv);
      P = ssm_filter_states_update_P(P, Z_t, Finv);
      // saving
      res[t, :m] = a;
      res[t, (m + 1): ] = symmat_to_vector(P);
    }
  }
  return res;
}

</code></pre>
</div>
</div>
<div id="log-likelihood" class="section level2">
<h2><span class="header-section-number">9.4</span> Log-likelihood</h2>
<div id="ssm_lpdf" class="section level3">
<h3><span class="header-section-number">9.4.1</span> ssm_lpdf</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>y</code>: Observations, <span class="math inline">\(\vec{y}_t\)</span>. An array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>d</code>: Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>H</code>: Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>c</code>: State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>a1</code>: Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>P1</code>: Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>returns</strong> The log-likelihood, <span class="math inline">\(p(\vec{y}_{1:n} | \vec{d}, \mat{Z}, \mat{H}, \vec{c}, \mat{T}, \mat{R}, \mat{Q})\)</span>, marginalized over the latent states.</p>
<p>Log-likelihood of a Linear Gaussian State Space Model</p>
<p>For <code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>d</code>, <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>The log-likelihood of a linear Gaussian state space model is, If the the system matrices and initial conditions are known, the log likelihood is <span class="math display">\[
\begin{aligned}[t]
\log L(\mat{Y}_n) &amp;= \log p(\vec{y}_1, \dots, \vec{y}_n) = \sum_{t = 1}^n \log p(\vec{y}_t | \mat{Y}_{t - 1}) \\
&amp;= - \frac{np}{2} \log 2 \pi - \frac{1}{2} \sum_{t = 1}^n \left( \log \left| \mat{F}_t \right| + \vec{v}\T \mat{F}_t^{-1} \vec{v}_t \right)
\end{aligned} ,
\]</span> where <span class="math inline">\(\mat{F}_t\)</span> and <span class="math inline">\(\mat{V}_t\)</span> come from a forward pass of the Kalman filter.</p>
<pre class="stan"><code>
real ssm_lpdf(vector[] y,
               vector[] d, matrix[] Z, matrix[] H,
               vector[] c, matrix[] T, matrix[] R, matrix[] Q,
               vector a1, matrix P1) {
  real ll;
  int n;
  int m;
  int p;
  int q;
  n = size(y); // number of obs
  m = dims(Z)[3];
  p = dims(Z)[2];
  q = dims(Q)[2];
  {
    // system matrices for current iteration
    vector[p] d_t;
    matrix[p, m] Z_t;
    matrix[p, p] H_t;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // result matricees for each iteration
    vector[n] ll_obs;
    vector[m] a;
    matrix[m, m] P;
    vector[p] v;
    matrix[p, p] Finv;
    matrix[m, p] K;

    d_t = d[1];
    Z_t = Z[1];
    H_t = H[1];
    c_t = c[1];
    T_t = T[1];
    R_t = R[1];
    Q_t = Q[1];
    RQR = quad_form_sym(Q_t, R_t &#39;);

    a = a1;
    P = P1;
    for (t in 1:n) {
      if (t &gt; 1) {
        if (size(d) &gt; 1) {
          d_t = d[t];
        }
        if (size(Z) &gt; 1) {
          Z_t = Z[t];
        }
        if (size(H) &gt; 1) {
          H_t = H[t];
        }
        if (size(c) &gt; 1) {
          c_t = c[t];
        }
        if (size(T) &gt; 1) {
          T_t = T[t];
        }
        if (size(R) &gt; 1) {
          R_t = R[t];
        }
        if (size(Q) &gt; 1) {
          Q_t = Q[t];
        }
        if (size(R) &gt; 1 || size(Q) &gt; 1) {
          RQR = quad_form_sym(Q_t, R_t &#39;);
        }
      }
      v = ssm_update_v(y[t], a, d_t, Z_t);
      Finv = ssm_update_Finv(P, Z_t, H_t);
      K = ssm_update_K(P, T_t, Z_t, Finv);
      ll_obs[t] = ssm_update_loglik(v, Finv);
      // don&#39;t save a, P for last iteration
      if (t &lt; n) {
        a = ssm_update_a(a, c_t, T_t, v, K);
        P = ssm_update_P(P, Z_t, T_t, RQR, K);
      }
    }
    ll = sum(ll_obs);
  }
  return ll;
}

</code></pre>
</div>
<div id="ssm_miss_lpdf" class="section level3">
<h3><span class="header-section-number">9.4.2</span> ssm_miss_lpdf</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>y</code>: Observations, <span class="math inline">\(\vec{y}_t\)</span>. An array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>d</code>: Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>H</code>: Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>c</code>: State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>a1</code>: Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>P1</code>: Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
<li><code>p_t</code>: A length <span class="math inline">\(n\)</span> array with the number of non-missing elements in the observation vector, <span class="math inline">\(\vec{y}_t\)</span>, at each <span class="math inline">\(t \in 1, \dots, n\)</span>.</li>
<li><code>y_idx</code>: A length <span class="math inline">\(n \times p\)</span> array of integers. The first <span class="math inline">\(p_t\)</span> elments of this array indexes of thenon-missing values of <span class="math inline">\(y\)</span>. Elements <span class="math inline">\(1:p_t\)</span> should be between <span class="math inline">\(1\)</span> and <span class="math inline">\(p\)</span>; elements <span class="math inline">\(p_t:p\)</span> are zero, and are not used.</li>
</ul>
<p><strong>returns</strong> The log-likelihood <span class="math inline">\(p(\vec{y}_{1:n} | \vec{d}_{1:n}, \mat{Z}_{1:n}, \mat{H}_{1:n}, \vec{c}_{1:n}, \mat{T}_{1:n}, \mat{R}_{1:n}, \mat{Q}_{1:n})\)</span>.</p>
<pre class="stan"><code>real ssm_miss_lpdf(vector[] y,
                   vector[] d, matrix[] Z, matrix[] H,
                   vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                   vector a1, matrix P1, int[] p_t, int[,] y_idx) {
  real ll;
  int n;
  int m;
  int p;
  int q;
  n = size(y); // number of obs
  m = dims(Z)[3];
  p = dims(Z)[2];
  q = dims(Q)[2];
  {
    // system matrices for current iteration
    vector[p] d_t;
    matrix[p, m] Z_t;
    matrix[p, p] H_t;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // result matricees for each iteration
    vector[n] ll_obs;
    vector[m] a;
    matrix[m, m] P;
    vector[p] v;
    matrix[p, p] Finv;
    matrix[m, p] K;

    d_t = d[1];
    Z_t = Z[1];
    H_t = H[1];
    c_t = c[1];
    T_t = T[1];
    R_t = R[1];
    Q_t = Q[1];
    RQR = quad_form_sym(Q_t, R_t &#39;);

    a = a1;
    P = P1;
    for (t in 1:n) {
      if (t &gt; 1) {
        if (size(d) &gt; 1) {
          d_t = d[t];
        }
        if (size(Z) &gt; 1) {
          Z_t = Z[t];
        }
        if (size(H) &gt; 1) {
          H_t = H[t];
        }
        if (size(c) &gt; 1) {
          c_t = c[t];
        }
        if (size(T) &gt; 1) {
          T_t = T[t];
        }
        if (size(R) &gt; 1) {
          R_t = R[t];
        }
        if (size(Q) &gt; 1) {
          Q_t = Q[t];
        }
        if (size(R) &gt; 1 || size(Q) &gt; 1) {
          RQR = quad_form_sym(Q_t, R_t &#39;);
        }
      }
      v = ssm_update_v_miss(y[t], a, d_t, Z_t, p_t[t], y_idx[t]);
      Finv = ssm_update_Finv_miss(P, Z_t, H_t, p_t[t], y_idx[t]);
      K = ssm_update_K(P, Z_t, T_t, Finv);
      ll_obs[t] = ssm_update_loglik_miss(v, Finv, p_t[t], y_idx[t]);
      // don&#39;t save a, P for last iteration
      if (t &lt; n) {
        a = ssm_update_a(a, c_t, T_t, v, K);
        P = ssm_update_P(P, Z_t, T_t, RQR, K);
      }
    }
    ll = sum(ll_obs);
  }
  return ll;
}

</code></pre>
</div>
<div id="ssm_ufilter_lpdf" class="section level3">
<h3><span class="header-section-number">9.4.3</span> ssm_ufilter_lpdf</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>y</code>: Observations, <span class="math inline">\(\vec{y}_t\)</span>. An array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>d</code>: Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>H</code>: Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>c</code>: State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>a1</code>: Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>P1</code>: Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>returns</strong> The log-likelihood, <span class="math inline">\(p(\vec{y}_{1:n} | \vec{d}, \mat{Z}, \mat{H}, \vec{c}, \mat{T}, \mat{R}, \mat{Q})\)</span>, marginalized over the latent states.</p>
<p>Log-likelihood of a Linear Gaussian State Space Model calculated using univariate filtering.</p>
<p>For <code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>d</code>, <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>The log-likelihood of a linear Gaussian state space model is, If the the system matrices and initial conditions are known, the log likelihood is <span class="math display">\[
\begin{aligned}[t]
\log L(\mat{Y}_n) &amp;= \log p(\vec{y}_1, \dots, \vec{y}_n) = \sum_{t = 1}^n \log p(\vec{y}_t | \mat{Y}_{t - 1}) \\
&amp;= - \frac{np}{2} \log 2 \pi - \frac{1}{2} \sum_{t = 1}^n \left( \log \left| \mat{F}_t \right| + \vec{v}\T \mat{F}_t^{-1} \vec{v}_t \right)
\end{aligned} ,
\]</span> where <span class="math inline">\(\mat{F}_t\)</span> and <span class="math inline">\(\mat{V}_t\)</span> come from a forward pass of the Kalman filter.</p>
<pre class="stan"><code>
real ssm_ufilter_lpdf(vector[] y,
                        vector[] d, matrix[] Z, vector[] H,
                        vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                        vector a1, matrix P1) {
  // returned data
  real ll;
  int q;
  int n;
  int p;
  int m;

  // sizes
  n = size(y); // number of obs
  m = dims(Z)[3]; // number of states
  p = dims(Z)[2]; // obs size
  q = dims(Q)[2]; // number of state disturbances

  //print(&quot;Sizes: n = &quot;, m, &quot;, p = &quot;, n, &quot;, m = &quot;, m, &quot;, q = &quot;, q);
  {
    // system matrices for current iteration
    vector[p] d_t;
    real d_ti;
    matrix[p, m] Z_t;
    row_vector[m] Z_ti;
    vector[p] H_t;
    real h_ti;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // result matricees for each iteration
    vector[m] a;
    matrix[m, m] P;
    real v;
    real Finv;
    vector[m] K;
    matrix[n, p] ll_obs;

    d_t = d[1];
    Z_t = Z[1];
    H_t = H[1];
    c_t = c[1];
    T_t = T[1];
    R_t = R[1];
    Q_t = Q[1];
    RQR = quad_form_sym(Q_t, R_t &#39;);
    a = a1;
    P = P1;
    for (t in 1:n) {
      if (t &gt; 1) {
        if (size(d) &gt; 1) {
          d_t = d[t];
        }
        if (size(Z) &gt; 1) {
          Z_t = Z[t];
        }
        if (size(H) &gt; 1) {
          H_t = H[t];
        }
        if (size(c) &gt; 1) {
          c_t = c[t];
        }
        if (size(T) &gt; 1) {
          T_t = T[t];
        }
        if (size(R) &gt; 1) {
          R_t = R[t];
        }
        if (size(Q) &gt; 1) {
          Q_t = Q[t];
        }
        if (size(R) &gt; 1 || size(Q) &gt; 1) {
          RQR = quad_form_sym(Q_t, R_t &#39;);
        }
      }
      // update step
      for (i in 1:p) {
        Z_ti = row(Z_t, i);
        v = ssm_update_v_u(y[t, i], a, d_t[i], Z_ti);
        Finv = ssm_update_Finv_u(P, Z_ti, H_t[i]);
        K = ssm_update_K_u(P, Z_ti, Finv);
        ll[t, i] = ssm_update_loglik_u(v, Finv);
        a = ssm_update_a_u1(a, v, K);
        P = ssm_update_P_u1(P, Finv, K);
      }
      // predict step
      if (t &lt; n) {
        a = ssm_update_a_u2(a, c_t, T_t);
        P = ssm_update_P_u2(P, T_t, RQR);
      }
    }
    ll = sum(ll_obs);
  }
  return ll;
}

real ssm_ufilter_miss_lpdf(vector[] y,
                          vector[] d, matrix[] Z, vector[] H,
                          vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                          vector a1, matrix P1, int[,] miss) {
  // returned data
  real ll;
  int q;
  int n;
  int p;
  int m;

  // sizes
  n = size(y); // number of obs
  m = dims(Z)[3]; // number of states
  p = dims(Z)[2]; // obs size
  q = dims(Q)[2]; // number of state disturbances

  //print(&quot;Sizes: n = &quot;, m, &quot;, p = &quot;, n, &quot;, m = &quot;, m, &quot;, q = &quot;, q);
  {
    // system matrices for current iteration
    vector[p] d_t;
    real d_ti;
    matrix[p, m] Z_t;
    row_vector[m] Z_ti;
    vector[p] H_t;
    real h_ti;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // result matricees for each iteration
    vector[m] a;
    matrix[m, m] P;
    real v;
    real Finv;
    vector[m] K;
    matrix[n, p] ll_obs;

    d_t = d[1];
    Z_t = Z[1];
    H_t = H[1];
    c_t = c[1];
    T_t = T[1];
    R_t = R[1];
    Q_t = Q[1];
    RQR = quad_form_sym(Q_t, R_t &#39;);
    a = a1;
    P = P1;
    for (t in 1:n) {
      if (t &gt; 1) {
        if (size(d) &gt; 1) {
          d_t = d[t];
        }
        if (size(Z) &gt; 1) {
          Z_t = Z[t];
        }
        if (size(H) &gt; 1) {
          H_t = H[t];
        }
        if (size(c) &gt; 1) {
          c_t = c[t];
        }
        if (size(T) &gt; 1) {
          T_t = T[t];
        }
        if (size(R) &gt; 1) {
          R_t = R[t];
        }
        if (size(Q) &gt; 1) {
          Q_t = Q[t];
        }
        if (size(R) &gt; 1 || size(Q) &gt; 1) {
          RQR = quad_form_sym(Q_t, R_t &#39;);
        }
      }
      // update step
      for (i in 1:p) {
        if (miss[i, p]) {
          ll_obs[t, i] = 0.;
        } else {
          Z_ti = row(Z_t, i);
          v = ssm_update_v_u(y[t, i], a, d_t[i], Z_ti);
          Finv = ssm_update_Finv_u(P, Z_ti, H_t[i]);
          K = ssm_update_K_u(P, Z_ti, Finv);
          ll_obs[t, i] = ssm_update_loglik_u(v, Finv);
          a = ssm_update_a_u1(a, v, K);
          P = ssm_update_P_u1(P, Finv, K);
        }
      }
      // predict step
      if (t &lt; n) {
        a = ssm_update_a_u2(a, c_t, T_t);
        P = ssm_update_P_u2(P, T_t, RQR);
      }
    }
    ll = sum(ll_obs);
  }
  return ll;
}


</code></pre>
</div>
</div>
<div id="time-invariant-kalman-filter" class="section level2">
<h2><span class="header-section-number">9.5</span> Time-Invariant Kalman Filter</h2>
<div id="matrix_diff" class="section level3">
<h3><span class="header-section-number">9.5.1</span> matrix_diff</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A</code>: An <span class="math inline">\(m \times n\)</span> matrix.</li>
<li><code>B</code>: An <span class="math inline">\(m \times n\)</span> matrix.</li>
</ul>
<p><strong>returns</strong> If converged, then 1, else 0.</p>
<p>The difference between <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is calculated as, <span class="math display">\[
d(A, B) = \max(A - B) / \max(A)
\]</span></p>
<pre class="stan"><code>
real matrix_diff(matrix A, matrix B) {
  real eps;
  real norm_AB;
  real norm_A;
  real a;
  real ab;
  int m;
  int n;
  m = rows(A);
  n = cols(A);
  eps = 0.0;
  norm_A = 0.0;
  norm_AB = 0.0;
  for (i in 1:m) {
    for (j in 1:n) {
      a = fabs(A[i, j]);
      ab = fabs(A[i, j] - B[i, j]);
      if (a &gt; norm_A) {
        norm_A = a;
      }
      if (ab &gt; norm_AB) {
        norm_AB = ab;
      }
    }
  }
  eps = norm_AB / norm_A;
  return eps;
}

</code></pre>
</div>
<div id="ssm_constant_lpdf" class="section level3">
<h3><span class="header-section-number">9.5.2</span> ssm_constant_lpdf</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>y</code>: Observations, <span class="math inline">\(\vec{y}_t\)</span>. An array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>d</code>: Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>H</code>: Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>c</code>: State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>a1</code>: Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>P1</code>: Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>returns</strong> The log-likelihood, <span class="math inline">\(p(\vec{y}_{1:n} | \vec{d}, \mat{Z}, \mat{H}, \vec{c}, \mat{T}, \mat{R}, \mat{Q})\)</span>, marginalized over the latent states.</p>
<p>Log-likelihood of a Time-Invariant Linear Gaussian State Space Model</p>
<p>Unlike <code>ssm_filter</code>, this function requires the system matrices (<code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) to all be time invariant (constant). When the state space model is time-invariant, then the Kalman recursion for <span class="math inline">\(\mat{P}_t\)</span> converges. This function takes advantage of this feature and stops updating <span class="math inline">\(\mat{P}_t\)</span> after it converges to a steady state.</p>
<pre class="stan"><code>
real ssm_constant_lpdf(vector[] y,
                      vector d, matrix Z, matrix H,
                      vector c, matrix T, matrix R, matrix Q,
                      vector a1, matrix P1) {
  real ll;
  int n;
  int m;
  int p;

  n = size(y); // number of obs
  m = cols(Z);
  p = rows(Z);
  {
    vector[n] ll_obs;
    vector[m] a;
    matrix[m, m] P;
    vector[p] v;
    matrix[p, p] Finv;
    matrix[m, p] K;
    matrix[m, m] RQR;
    // indicator for if the filter has converged
    // This only works for time-invariant state space models
    int converged;
    matrix[m, m] P_old;
    real tol;
    real matdiff;
    converged = 0;
    tol = 1e-7;

    RQR = quad_form_sym(Q, R &#39;);
    a = a1;
    P = P1;
    for (t in 1:n) {
      v = ssm_update_v(y[t], a, d, Z);
      if (converged &lt; 1) {
        Finv = ssm_update_Finv(P, Z, H);
        K = ssm_update_K(P, Z, T, Finv);
      }
      ll_obs[t] = ssm_update_loglik(v, Finv);
      // don&#39;t save a, P for last iteration
      if (t &lt; n) {
        a = ssm_update_a(a, c, T, v, K);
        // check for convergence
        // should only check for convergence if there are no missing values
        if (converged &lt; 1) {
          P_old = P;
          P = ssm_update_P(P, Z, T, RQR, K);
          matdiff = matrix_diff(P, P_old);
          if (matdiff &lt; tol) {
            converged = 1;
          }
        }
      }
    }
    ll = sum(ll_obs);
  }
  return ll;
}



</code></pre>
</div>
</div>
<div id="common-smoother-functions" class="section level2">
<h2><span class="header-section-number">9.6</span> Common Smoother Functions</h2>
<div id="ssm_update_r" class="section level3">
<h3><span class="header-section-number">9.6.1</span> ssm_update_r</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>r</code>: An <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\vec{r}_{t-1}\)</span></li>
<li><code>Z</code>: A <span class="math inline">\(p \times m\)</span> vector with <span class="math inline">\(\mat{Z}_{t}\)</span></li>
<li><code>v</code>: A <span class="math inline">\(p \times 1\)</span> vector of the forecast errors, <span class="math inline">\(\vec{v}_t\)</span>.</li>
<li><code>Finv</code>: A <span class="math inline">\(p \times p\)</span> matrix of the forecast precision, <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</li>
<li><code>L</code>: An <span class="math inline">\(m \times m\)</span> matrix with <span class="math inline">\(\mat{L}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\vec{r}_t\)</span>.</p>
<p>Update <span class="math inline">\(\vec{r}_t\)</span> in smoothing recursions</p>
<p>In smoothing recursions, the vector <span class="math inline">\(\vec{r}_t\)</span> is updated with, <span class="math display">\[
\vec{r}_{t - 1} = \mat{Z}&#39; \mat{F}^{-1}_t \vec{v}_t + \mat{L}&#39; \vec{r}_{t} .
\]</span></p>
<p>See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.4.4, p. 91)</span></p>
<pre class="stan"><code>
vector ssm_update_r(vector r, matrix Z, vector v, matrix Finv,
                           matrix L) {
  vector[num_elements(r)] r_new;
  r_new = Z &#39; * Finv * v + L &#39; * r;
  return r_new;
}

</code></pre>
</div>
</div>
<div id="common-smoother-functions-1" class="section level2">
<h2><span class="header-section-number">9.7</span> Common Smoother Functions</h2>
<div id="ssm_update_r_u1" class="section level3">
<h3><span class="header-section-number">9.7.1</span> ssm_update_r_u1</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>r</code>: An <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\vec{r}_{t,i}\)</span></li>
<li><code>Z</code>: A <span class="math inline">\(1 \times m\)</span> row vector of the design matix <span class="math inline">\(\mat{Z}_{t,i}\)</span></li>
<li><code>v</code>: The forecast error, <span class="math inline">\(\vec{v}_{t,i}\)</span>.</li>
<li><code>Finv</code>: The $forecast precision, <span class="math inline">\(\mat{F}^{-1}_{t,i}\)</span>.</li>
<li><code>L</code>: An <span class="math inline">\(m \times m\)</span> matrix with <span class="math inline">\(\mat{L}_{t,i}\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\vec{r}_{t,i-1}\)</span>.</p>
<p>Update <span class="math inline">\(\vec{r}_{t,i-1}\)</span> from <span class="math inline">\(\vec{r}_{t,i}\)</span> in univariate smoothing recursions.</p>
<p>See <span class="citation">(<span class="citeproc-not-found" data-reference-id="KoopmanDurbin2012"><strong>???</strong></span>)</span></p>
<pre class="stan"><code>
vector ssm_update_r_u1(vector r, row_vector Z, real v, real Finv, matrix L) {
  vector[num_elements(r)] r_new;
  r_new = Z &#39; * Finv * v + L &#39; * r;
  return r_new;
}

</code></pre>
</div>
<div id="ssm_update_r_u2" class="section level3">
<h3><span class="header-section-number">9.7.2</span> ssm_update_r_u2</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>r</code>: An <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\vec{r}_{t,i}\)</span></li>
<li><code>T</code>: A <span class="math inline">\(m \times m\)</span> row vector with the transition matrix <span class="math inline">\(\mat{T}_{t-1}\)</span></li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\vec{r}_{t - 1,p}\)</span>.</p>
<p>Update <span class="math inline">\(\vec{r}_{t-1,p}\)</span> from <span class="math inline">\(\vec{r}_{t,0}\)</span> in univariate smoothing recursions.</p>
<p>See <span class="citation">(<span class="citeproc-not-found" data-reference-id="KoopmanDurbin2012"><strong>???</strong></span>)</span></p>
<pre class="stan"><code>
vector ssm_update_r_u2(vector r, matrix T) {
  vector[num_elements(r)] r_new;
  r_new = T &#39; * r;
  return r_new;
}

</code></pre>
</div>
<div id="ssm_update_n" class="section level3">
<h3><span class="header-section-number">9.7.3</span> ssm_update_N</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>N</code>: An <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\vec{N}_{t-1}\)</span></li>
<li><code>Z</code>: A <span class="math inline">\(p \times m\)</span> vector with <span class="math inline">\(\mat{Z}_{t}\)</span></li>
<li><code>Finv</code>: A <span class="math inline">\(p \times p\)</span> matrix of the forecast precision, <span class="math inline">\(\mat{F}^{-1}_t\)</span>.</li>
<li><code>L</code>: An <span class="math inline">\(m \times m\)</span> matrix with <span class="math inline">\(\mat{L}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times m\)</span> matrix with <span class="math inline">\(\vec{N}_t\)</span>.</p>
<p>Update <span class="math inline">\(\mat{N}_t\)</span> in smoothing recursions</p>
<p>In smoothing recursions, the matrix <span class="math inline">\(\vec{N}_t\)</span> is updated with, <span class="math display">\[
\mat{N}_{t - 1} = \mat{Z}_t&#39; \mat{F}^{-1}_t \mat{Z}_t + \mat{L}_t&#39; \mat{N}_t \mat{L}_t .
\]</span></p>
<p>See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.4.4, p. 91)</span></p>
<pre class="stan"><code>
matrix ssm_update_N(matrix N, matrix Z, matrix Finv, matrix L) {
  matrix[rows(N), cols(N)] N_new;
  # may not need this to_symmetric_matrix
  N_new = quad_form_sym(Finv, Z) + quad_form_sym(N, L);
  return N_new;
}

</code></pre>
</div>
<div id="ssm_update_n_u1" class="section level3">
<h3><span class="header-section-number">9.7.4</span> ssm_update_N_u1</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>N</code>: An <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\vec{N}_{t,i}\)</span></li>
<li><code>Z</code>: A <span class="math inline">\(1 \times m\)</span> vector with <span class="math inline">\(\mat{Z}_{t,i}\)</span></li>
<li><code>Finv</code>: The forecast precision, <span class="math inline">\(\mat{F}^{-1}_{t,i}\)</span>.</li>
<li><code>L</code>: An <span class="math inline">\(m \times m\)</span> matrix with <span class="math inline">\(\mat{L}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times m\)</span> matrix with <span class="math inline">\(\vec{N}_t\)</span>.</p>
<p>Filter <span class="math inline">\(\mat{N}_{t,i}\)</span> after observing <span class="math inline">\(y_{t,i}\)</span> in univariate smoothing recursions, <span class="math display">\[
\mat{N}_{t,i-1} = \mat{Z}_{t,i}&#39; \mat{F}^{-1}_{t,i} \mat{Z}_{t,i} + \mat{L}_{t,i}&#39; \mat{N}_{t,i} \mat{L}_{t,i} .
\]</span></p>
<p>See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Eq. 6.15, p. 157)</span></p>
<pre class="stan"><code>
matrix ssm_update_N_u1(matrix N, row_vector Z, real Finv, matrix L) {
  matrix[rows(N), cols(N)] N_new;
  # may not need this to_symmetric_matrix
  N_new = crossprod(to_matrix(Z)) * Finv + quad_form_sym(N, L);
  return N_new;
}

</code></pre>
</div>
<div id="ssm_update_n_u2" class="section level3">
<h3><span class="header-section-number">9.7.5</span> ssm_update_N_u2</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>N</code>: An <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\vec{N}_{t,0}\)</span></li>
<li><code>T</code>: The <span class="math inline">\(m \times m\)</span> transition matrix <span class="math inline">\(\mat{T}_{t - 1}\)</span></li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times m\)</span> matrix with $_{t-1,p}</p>
<p>Update smoothing variance from <span class="math inline">\(t\)</span> to <span class="math inline">\(t - 1\)</span>, <span class="math inline">\(\mat{N}_{t,0}\)</span> to $_{t - 1, p} <span class="math display">\[
\mat{N}_{t,i-1} =  \mat{T}_{t-1}&#39; \mat{N}_{t,0} \mat{T}_{t-1} .
\]</span></p>
<p>See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Eq. 6.15, p. 157)</span></p>
<pre class="stan"><code>
matrix ssm_update_N_u2(matrix N, matrix T) {
  matrix[rows(N), cols(N)] N_new;
  # may not need this to_symmetric_matrix
  N_new = quad_form_sym(N, T);
  return N_new;
}


</code></pre>
</div>
<div id="ssm_smooth_state_size" class="section level3">
<h3><span class="header-section-number">9.7.6</span> ssm_smooth_state_size</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>m</code>: The number of states.</li>
</ul>
<p><strong>returns</strong> The size of the vectors is <span class="math inline">\(m + m (m + 1) / 2\)</span>.</p>
<p>The number of elements in vectors returned by <code>ssm_smooth_state</code></p>
<pre class="stan"><code>
int ssm_smooth_state_size(int m) {
  int sz;
  sz = m + symmat_size(m);
  return sz;
}

</code></pre>
</div>
<div id="ssm_smooth_state_get_mean" class="section level3">
<h3><span class="header-section-number">9.7.7</span> ssm_smooth_state_get_mean</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: A vector returned by <code>ssm_smooth_state</code></li>
<li><code>m</code>: The size of the state vector, <span class="math inline">\(\vec{\alpha}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\hat{\vec{\alpha}}_t\)</span>.</p>
<p>Extract <span class="math inline">\(\hat{\vec{\alpha}}_t\)</span> from vectors returned by <code>ssm_smooth_state</code></p>
<pre class="stan"><code>
vector ssm_smooth_state_get_mean(vector x, int m) {
  vector[m] alpha;
  alpha = x[ :m];
  return alpha;
}

</code></pre>
</div>
<div id="ssm_smooth_state_get_var" class="section level3">
<h3><span class="header-section-number">9.7.8</span> ssm_smooth_state_get_var</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: A vector returned by <code>ssm_smooth_state</code></li>
<li><code>m</code>: The number of states</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times m\)</span> matrix with <span class="math inline">\(\mat{V}_t\)</span>.</p>
<p>Extract <span class="math inline">\(mat{V}_t\)</span> from vectors returned by <code>ssm_smooth_state</code></p>
<pre class="stan"><code>
matrix ssm_smooth_state_get_var(vector x, int m) {
  matrix[m, m] V;
  V = vector_to_symmat(x[(m + 1): ], m);
  return V;
}


</code></pre>
</div>
<div id="ssm_smooth_state" class="section level3">
<h3><span class="header-section-number">9.7.9</span> ssm_smooth_state</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>filter</code>: Results of <code>ssm_filter</code></li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
</ul>
<p><strong>returns</strong> An array of vectors constaining <span class="math inline">\(\hat{\vec{\alpha}}_t\)</span> and <span class="math inline">\(\mat{V}_t = \Var(\vec{\alpha}_t | \vec{y}_{1:n})\)</span>.</p>
<p>The state smoother</p>
<p>This calculates the mean and variance of the states, <span class="math inline">\(\vec{\alpha}_t\)</span>, given the entire sequence, <span class="math inline">\(\vec{y}_{1:n}\)</span>.</p>
<p>in the format described below.</p>
<p>For <code>Z</code> and <code>T</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>Z</code>) or <span class="math inline">\(n - 1\)</span> (for <code>T</code>) if it is time varying.</p>
<p>The vectors returned by this function have <span class="math inline">\(m + m ^ 2\)</span> elements in this format, <span class="math display">\[
(\hat{\vec{\alpha}}_t&#39;, \VEC(\mat{V}_t)&#39; )&#39;.
\]</span> Use the <code>ssm_smooth_state_get_mean</code> and <code>ssm_smooth_state_get_var</code> to extract components from the returned vectors.</p>
<table>
<thead>
<tr class="header">
<th align="left">value</th>
<th align="left">length</th>
<th align="left">start</th>
<th align="left">end</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(\hat{\vec{\alpha}}_t\)</span> <span class="math inline">\(m\)</span></td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left"><span class="math inline">\(m\)</span></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\mat{V}_t\)</span> $</td>
<td align="left">m (m + 1) / 2$ $</td>
<td align="left">m + 1$ $</td>
<td align="left">m + m (m + 1) / 2$</td>
</tr>
</tbody>
</table>
<p>See <span class="citation">Durbin and Koopman (<a href="#ref-DurbinKoopman2012">2012</a>)</span>, Eq 4.44 and eq 4.69.</p>
<pre class="stan"><code>
vector[] ssm_smooth_state(vector[] filter, matrix[] Z, matrix[] T) {
  vector[ssm_smooth_state_size(dims(Z)[3])] res[size(filter)];
  int n;
  int m;
  int p;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  {
    // system matrices for current iteration
    matrix[p, m] Z_t;
    matrix[m, m] T_t;
    // smoother results
    vector[m] r;
    matrix[m, m] N;
    matrix[m, m] L;
    vector[m] alpha;
    matrix[m, m] V;
    // results
    vector[p] v;
    matrix[m, p] K;
    matrix[p, p] Finv;
    vector[m] a;
    matrix[m, m] P;

    if (size(Z) == 1) {
      Z_t = Z[1];
    }
    if (size(T) == 1) {
      T_t = T[1];
    }
    // initialize smoother
    // r and N go from n, n - 1, ..., 1, 0.
    // r_n and N_n
    r = rep_vector(0.0, m);
    N = rep_matrix(0.0, m, m);
    // move backwards in time: t, ..., 1
    for (i in 0:(n - 1)) {
      int t;
      t = n - i;
      // set time-varying system matrices
      if (size(Z) &gt; 1) {
        Z_t = Z[t];
      }
      if (size(T) &gt; 1) {
        T_t = T[t];
      }
      // get filtered values
      K = ssm_filter_get_K(filter[t], m, p);
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      a = ssm_filter_get_a(filter[t], m, p);
      P = ssm_filter_get_P(filter[t], m, p);
      // updating
      // L_t
      L = ssm_update_L(Z_t, T_t, K);
      // r_{t - 1} and N_{t - 1}
      r = ssm_update_r(r, Z_t, v, Finv, L);
      N = ssm_update_N(N, Z_t, Finv, L);
      // hat(alpha)_{t} and V_t which use r and N from (t - 1)
      alpha = a + P * r;
      V = to_symmetric_matrix(P - P * N * P);
      // saving
      res[t, :m] = alpha;
      res[t, (m + 1): ] = symmat_to_vector(V);
    }
  }
  return res;
}


</code></pre>
</div>
<div id="ssm_smooth_eps_size" class="section level3">
<h3><span class="header-section-number">9.7.10</span> ssm_smooth_eps_size</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>p</code>: The length of the observation vectors, <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> The size of the vectors is <span class="math inline">\(p + p (p + 1) / 2\)</span>.</p>
<p>The size of the vectors returned by <code>ssm_smooth_eps</code></p>
<pre class="stan"><code>
int ssm_smooth_eps_size(int p) {
  int sz;
  sz = p + symmat_size(p);
  return sz;
}

</code></pre>
</div>
<div id="ssm_smooth_eps_get_mean" class="section level3">
<h3><span class="header-section-number">9.7.11</span> ssm_smooth_eps_get_mean</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: vector from the results of <code>ssm_smooth_eps</code>.</li>
<li><code>p</code>: The length of the observation vectors, <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(p \times 1\)</span> vector with <span class="math inline">\(\hat{\vec{\varepsilon}}_t\)</span>.</p>
<p>Extract <span class="math inline">\(\hat{\vec{\varepsilon}}_t\)</span> from vectors returned by <code>ssm_smooth_eps</code></p>
<pre class="stan"><code>
vector ssm_smooth_eps_get_mean(vector x, int p) {
  vector[p] eps;
  eps = x[ :p];
  return eps;
}

</code></pre>
</div>
<div id="ssm_smooth_eps_get_var" class="section level3">
<h3><span class="header-section-number">9.7.12</span> ssm_smooth_eps_get_var</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: A vector returned by <code>ssm_smooth_eps</code></li>
<li><code>p</code>: The length of the observation vectors, <span class="math inline">\(\vec{y}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(p \times p\)</span> matrix with <span class="math inline">\(\Var(\vec{\varepsilon}_t | \vec{y}_{1:n})\)</span></p>
<p>Extract <span class="math inline">\(\Var(\varepsilon_t|\vec{y}_{1:n})\)</span> from vectors returned by <code>ssm_smooth_eps</code></p>
<pre class="stan"><code>
matrix ssm_smooth_eps_get_var(vector x, int p) {
  matrix[p, p] eps_var;
  eps_var = vector_to_symmat(x[(p + 1): ], p);
  return eps_var;
}

</code></pre>
</div>
<div id="ssm_smooth_eps" class="section level3">
<h3><span class="header-section-number">9.7.13</span> ssm_smooth_eps</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>filter</code>: Results of <code>ssm_filter</code></li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>H</code>: Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
</ul>
<p><strong>returns</strong> An array of vectors constaining <span class="math inline">\(\hat{\vec{\varepsilon}}_t\)</span> and <span class="math inline">\(\Var(\vec{\varepsilon}_t | \vec{y}_{1:n})\)</span> in the format described below.</p>
<p>The observation disturbance smoother</p>
<p>This calculates the mean and variance of the observation disturbances, <span class="math inline">\(\vec{\varepsilon}_t\)</span>, given the entire sequence, <span class="math inline">\(\vec{y}_{1:n}\)</span>.</p>
<p>For Z<code>,</code>H<code>, T</code>, the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>T</code>), if it is time varying.</p>
<p>The vectors returned by this function have <span class="math inline">\(p + p (p + 1) / 2\)</span> elements in this format, <span class="math display">\[
(\hat{\vec{\varepsilon}}_t&#39;, \VEC(\Var(\vec{\varepsilon}_t | \vec{y}_{1:n}))&#39; )&#39;
\]</span></p>
<table>
<thead>
<tr class="header">
<th align="left">value</th>
<th align="left">length</th>
<th align="left">start</th>
<th align="left">end</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(\hat{\vec{\varepsilon}}_t\)</span> <span class="math inline">\(p\)</span></td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left"><span class="math inline">\(p\)</span></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\Var(\vec{\varepsilon}_t | \vec{y}_{1:n})\)</span> $p (</td>
<td align="left">p + 1) / 2$ $p +</td>
<td align="left">1$ $p + p</td>
<td align="left">(p + 1) / 2$</td>
</tr>
</tbody>
</table>
<p>See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.5.3 (eq 4.69))</span></p>
<pre class="stan"><code>
vector[] ssm_smooth_eps(vector[] filter, matrix[] Z, matrix[] H, matrix[] T) {
  vector[ssm_smooth_eps_size(dims(Z)[2])] res[size(filter)];
  int n;
  int m;
  int p;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  {
    // smoother values
    vector[m] r;
    matrix[m, m] N;
    matrix[m, m] L;
    vector[p] eps;
    matrix[p, p] var_eps;
    // filter results
    vector[p] v;
    matrix[m, p] K;
    matrix[p, p] Finv;
    // system matrices
    matrix[p, m] Z_t;
    matrix[p, p] H_t;
    matrix[m, m] T_t;

    // set matrices if time-invariant
    if (size(Z) == 1) {
      Z_t = Z[1];
    }
    if (size(H) == 1) {
      H_t = H[1];
    }
    if (size(T) == 1) {
      T_t = T[1];
    }
    // initialize smoother
    // r and N go from n, n - 1, ..., 1, 0.
    // r_n and N_n
    r = rep_vector(0.0, m);
    N = rep_matrix(0.0, m, m);
    for (i in 1:n) {
      int t;
      // move backwards in time
      t = n - i + 1;
      // update time-varying system matrices
      if (size(Z) &gt; 1) {
        Z_t = Z[t];
      }
      if (size(H) &gt; 1) {
        H_t = H[t];
      }
      if (size(T) &gt; 1) {
        T_t = T[t];
      }
      // get values from filter
      K = ssm_filter_get_K(filter[t], m, p);
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      // updating
      L = ssm_update_L(Z_t, T_t, K);
      // r_{t - 1} and N_{t - 1}
      r = ssm_update_r(r, Z_t, v, Finv, L);
      N = ssm_update_N(N, Z_t, Finv, L);
      // eps_t and V(eps_t|y)
      eps = H_t * (Finv * v - K &#39; * r);
      var_eps = to_symmetric_matrix(H_t - H_t * (Finv + quad_form_sym(N, K)) * H_t);
      // saving
      res[t, :p] = eps;
      res[t, (p + 1): ] = symmat_to_vector(var_eps);
    }
  }
  return res;
}

</code></pre>
</div>
<div id="ssm_smooth_eta_size" class="section level3">
<h3><span class="header-section-number">9.7.14</span> ssm_smooth_eta_size</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>q</code>: The size of the state disurbance vector, <span class="math inline">\(\vec{\eta}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> The size of the vectors is <span class="math inline">\(q + q (q + 1) / 2\)</span>.</p>
<p>The size of the vectors returned by <code>ssm_smooth_eta</code></p>
<pre class="stan"><code>
int ssm_smooth_eta_size(int q) {
  int sz;
  sz = q + symmat_size(q);
  return sz;
}

</code></pre>
</div>
<div id="ssm_smooth_eta_get_mean" class="section level3">
<h3><span class="header-section-number">9.7.15</span> ssm_smooth_eta_get_mean</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: A vector returned by <code>ssm_smooth_eta</code></li>
<li><code>q</code>: The number of state disturbances, <span class="math inline">\(\vec{\eta}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(q \times 1\)</span> vector with <span class="math inline">\(\hat{\vec{\eta}}_t\)</span>.</p>
<p>Extract <span class="math inline">\(\hat{\vec{\varepsilon}}_t\)</span> from vectors returned by <code>ssm_smooth_eta</code></p>
<pre class="stan"><code>
vector ssm_smooth_eta_get_mean(vector x, int q) {
  vector[q] eta;
  eta = x[ :q];
  return eta;
}

</code></pre>
</div>
<div id="ssm_smooth_eta_get_var" class="section level3">
<h3><span class="header-section-number">9.7.16</span> ssm_smooth_eta_get_var</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: A vector returned by <code>ssm_smooth_eta</code></li>
<li><code>q</code>: The number of state disturbances, <span class="math inline">\(\vec{\eta}_t\)</span>.</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(q \times q\)</span> matrix with <span class="math inline">\(\Var(\vec{\eta}_t | \vec{y}_{1:n})\)</span>.</p>
<p>Extract <span class="math inline">\(\Var(\eta_t|\vec{y}_{1:n})\)</span> from vectors returned by <code>ssm_smooth_eta</code></p>
<pre class="stan"><code>
matrix ssm_smooth_eta_get_var(vector x, int q) {
  matrix[q, q] eta_var;
  eta_var = vector_to_symmat(x[(q + 1): ], q);
  return eta_var;
}

</code></pre>
</div>
<div id="ssm_smooth_eta" class="section level3">
<h3><span class="header-section-number">9.7.17</span> ssm_smooth_eta</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>filter</code>: Results of <code>ssm_filter</code></li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
</ul>
<p><strong>returns</strong> An array of vectors constaining <span class="math inline">\(\hat{\vec{\eta}}_t\)</span> and <span class="math inline">\(\Var(\vec{\eta}_t | \vec{y}_{1:n})\)</span> in the format described below.</p>
<p>The state disturbance smoother</p>
<p>This calculates the mean and variance of the observation disturbances, <span class="math inline">\(\vec{\eta}_t\)</span>, given the entire sequence, <span class="math inline">\(\vec{y}_{1:n}\)</span>.</p>
<p>For <code>Z</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>Z</code>) or <span class="math inline">\(n - 1\)</span> (for <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>The vectors returned by this function have <span class="math inline">\(q + q (q + 1) / 2\)</span> elements in this format, <span class="math display">\[
(\hat{\vec{\eta}}_t&#39;, \VEC(\Var(\vec{\eta}_t | \vec{y}_{1:n}))&#39; ).
\]</span> Use the <code>ssm_smooth_eta_get_mean</code> and <code>ssm_smooth_eta_get_var</code> to extract components from the returned vectors.</p>
<table>
<thead>
<tr class="header">
<th align="left">value</th>
<th align="left">length</th>
<th align="left">start</th>
<th align="left">end</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(\hat{\vec{\eta}}_t\)</span></td>
<td align="left"><span class="math inline">\(q\)</span></td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left"><span class="math inline">\(q\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\Var(\vec{\eta}_t | \vec{y}_{1:n})\)</span></td>
<td align="left"><span class="math inline">\(q (q + 1) / 2\)</span></td>
<td align="left"><span class="math inline">\(q + 1\)</span></td>
<td align="left"><span class="math inline">\(q + q (q + 1) / 2\)</span></td>
</tr>
</tbody>
</table>
<p>See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.5.3 (eq 4.69))</span></p>
<pre class="stan"><code>
vector[] ssm_smooth_eta(vector[] filter,
                        matrix[] Z, matrix[] T,
                        matrix[] R, matrix[] Q) {
  vector[ssm_smooth_eta_size(dims(Q)[2])] res[size(filter)];
  int n;
  int m;
  int p;
  int q;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  q = dims(Q)[2];
  {
    // smoother matrices
    vector[m] r;
    matrix[m, m] N;
    matrix[m, m] L;
    vector[q] eta;
    matrix[q, q] var_eta;
    // system matrices
    matrix[p, m] Z_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    // filter matrices
    vector[p] v;
    matrix[m, p] K;
    matrix[p, p] Finv;

    // set time-invariant matrices
    if (size(Z) == 1) {
      Z_t = Z[1];
    }
    if (size(T) == 1) {
      T_t = T[1];
    }
    if (size(R) == 1) {
      R_t = R[1];
    }
    if (size(Q) == 1) {
      Q_t = Q[1];
    }
    // initialize smoother
    r = rep_vector(0.0, m);
    N = rep_matrix(0.0, m, m);
    for (i in 0:(n - 1)) {
      int t;
      // move backwards in time
      t = n - i;
      // update time-varying system matrices
      if (size(Z) &gt; 1) {
        Z_t = Z[t];
      }
      if (size(T) &gt; 1) {
        T_t = T[t];
      }
      if (size(R) &gt; 1) {
        R_t = R[t];
      }
      if (size(Q) &gt; 1) {
        Q_t = Q[t];
      }
      // get values from filter
      K = ssm_filter_get_K(filter[t], m, p);
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      // update smoother
      L = ssm_update_L(Z_t, T_t, K);
      r = ssm_update_r(r, Z_t, v, Finv, L);
      N = ssm_update_N(N, Z_t, Finv, L);
      eta = Q_t * R_t &#39; * r;
      var_eta = to_symmetric_matrix(Q_t - Q_t * quad_form_sym(N, R_t) * Q_t);
      // saving
      res[t, :q] = eta;
      res[t, (q + 1): ] = symmat_to_vector(var_eta);
    }
  }
  return res;
}


</code></pre>
</div>
<div id="ssm_smooth_state_mean" class="section level3">
<h3><span class="header-section-number">9.7.18</span> ssm_smooth_state_mean</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>filter</code>: The results of <code>ssm_filter</code></li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>c</code>: State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
</ul>
<p><strong>returns</strong> An array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(m \times 1\)</span> vectors containing <span class="math inline">\(\hat{\vec{\alpha}}_t\)</span>.</p>
<p>The fast state smoother</p>
<p>The fast state smoother calculates <span class="math inline">\(\hat{\vec{\alpha}}_t = \E(\vec{\alpha}_t | \vec{y}_{1:n})\)</span>. <span class="math display">\[
\hat{\vec{\alpha}}_{t + 1} = \mat{T}_t \hat{\vec{\alpha}}_{t} + \mat{R}_t \mat{Q}_t \mat{R}&#39;_t \vec{r}_t ,
\]</span> where <span class="math inline">\(r_t\)</span> is calcualted from the state disturbance smoother. The smoother is initialized at <span class="math inline">\(t = 1\)</span> with <span class="math inline">\(\hat{\vec{\alpha}}_t = \vec{a}_1 + \mat{P}_1 \vec{r}_0\)</span>.</p>
<p>Unlike the normal state smoother, it does not calculate the variances of the smoothed state.</p>
<p>For <code>Z</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>Z</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.5.3 (eq 4.69))</span></p>
<pre class="stan"><code>
vector[] ssm_smooth_state_mean(vector[] filter,
                              matrix[] Z, vector[] c,
                              matrix[] T, matrix[] R, matrix[] Q) {
  vector[dims(Z)[3]] alpha[size(filter)];
  int n;
  int m;
  int p;
  int q;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  q = dims(Q)[2];
  {
    // smoother matrices
    vector[m] r[n + 1];
    matrix[m, m] L;
    vector[m] a1;
    matrix[m, m] P1;
    // filter matrices
    vector[p] v;
    matrix[m, p] K;
    matrix[p, p] Finv;
    // system matrices
    matrix[p, m] Z_t;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // set time-invariant matrices
    if (size(c) == 1) {
      c_t = c[1];
    }
    if (size(Z) == 1) {
      Z_t = Z[1];
    }
    if (size(T) == 1) {
      T_t = T[1];
    }
    if (size(R) == 1) {
      R_t = R[1];
    }
    if (size(Q) == 1) {
      Q_t = Q[1];
    }
    if (size(Q) == 1 &amp;&amp; size(R) == 1) {
      RQR = quad_form_sym(Q[1], R[1]&#39;);
    }
    // find smoothed state disturbances
    // Since I don&#39;t need to calculate the
    // variances of the smoothed disturbances,
    // I reimplement the state distrurbance smoother here
    // removing extraneous parts.
    // r goes from t = n, ..., 1, 0.
    // r_n
    r[n + 1] = rep_vector(0.0, m);
    for (i in 0:(n - 1)) {
      int t;
      // move backwards in time
      t = n - i;
      // update time varying system matrices
      if (size(Z) &gt; 1) {
        Z_t = Z[t];
      }
      if (size(T) &gt; 1) {
        T_t = T[t];
      }
      // get filter values
      K = ssm_filter_get_K(filter[t], m, p);
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      // updating smoother
      L = ssm_update_L(Z_t, T_t, K);
      // r_{t - 1}
      r[t] = ssm_update_r(r[t + 1], Z_t, v, Finv, L);
    }
    // calculate smoothed states
    a1 = ssm_filter_get_a(filter[1], m, p);
    P1 = ssm_filter_get_P(filter[1], m, p);
    // r[1] = r_0
    alpha[1] = a1 + P1 * r[1];
    // 1:(n - 1) -&gt; \alpha_{2}:\alpha_{n}
    for (t in 1:(n - 1)) {
      if (size(c) &gt; 1) {
        c_t = c[t];
      }
      if (size(T) &gt; 1) {
        T_t = T[t];
      }
      if (size(Q) &gt; 1) {
        Q_t = Q[t];
      }
      if (size(R) &gt; 1) {
        R_t = R[t];
      }
      if (size(Q) &gt; 1 || size(R) &gt; 1) {
        RQR = quad_form_sym(Q_t, R_t&#39;);
      }
      // `r[t + 1]` = $r_{t}$
      // alpha_{t + 1} = c_t + T_t * \alpha_t + R_t Q_t R&#39;_t r_t
      alpha[t + 1] = c_t + T_t * alpha[t] + RQR * r[t + 1];
    }
  }
  return alpha;
}




</code></pre>
</div>
</div>
<div id="simulators-and-smoothing-simulators" class="section level2">
<h2><span class="header-section-number">9.8</span> Simulators and Smoothing Simulators</h2>
<div id="ssm_sim_idx" class="section level3">
<h3><span class="header-section-number">9.8.1</span> ssm_sim_idx</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>m</code>: The number of states</li>
<li><code>p</code>: The length of the observation vector</li>
<li><code>q</code>: The number of state disturbances</li>
</ul>
<p><strong>returns</strong> A 4 x 3 array of integers</p>
<p>Indexes of each component of <code>ssm_sim_rng</code> results.</p>
<p>The returned array has columns (length, start location, and end location) for rows: <span class="math inline">\(\vec{y}_t\)</span>, <span class="math inline">\(\vec{\alpha}_t\)</span>, <span class="math inline">\(\vec{\varepsilon}_t\)</span>, and <span class="math inline">\(\vec{\eta}_t\)</span> in the results of <code>ssm_sim_rng</code>.</p>
<pre class="stan"><code>
int[,] ssm_sim_idx(int m, int p, int q) {
  int sz[4, 3];
  // y
  sz[1, 1] = p;
  // a
  sz[2, 1] = m;
  // eps
  sz[3, 1] = p;
  // eta
  sz[4, 1] = q;
  // Fill in start and stop points
  sz[1, 2] = 1;
  sz[1, 3] = sz[1, 2] + sz[1, 1] - 1;
  for (i in 2:4) {
    sz[i, 2] = sz[i - 1, 3] + 1;
    sz[i, 3] = sz[i, 2] + sz[i, 1] - 1;
  }
  return sz;
}

</code></pre>
</div>
<div id="ssm_sim_size" class="section level3">
<h3><span class="header-section-number">9.8.2</span> ssm_sim_size</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>m</code>: The number of states</li>
<li><code>p</code>: The length of the observation vector</li>
<li><code>q</code>: The number of state disturbances</li>
</ul>
<p><strong>returns</strong> The number of elements</p>
<p>The number of elements in vectors returned by <code>ssm_sim_rng</code> results.</p>
<pre class="stan"><code>
int ssm_sim_size(int m, int p, int q) {
  int sz;
  sz = ssm_sim_idx(m, p, q)[4, 3];
  return sz;
}

</code></pre>
</div>
<div id="ssm_sim_get_y" class="section level3">
<h3><span class="header-section-number">9.8.3</span> ssm_sim_get_y</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: vector of results from <code>ssm_sim_rng</code></li>
<li><code>m</code>: The number of states</li>
<li><code>p</code>: The length of the observation vector</li>
<li><code>q</code>: The number of state disturbances</li>
</ul>
<p><strong>returns</strong> vector A <span class="math inline">\(p \times 1\)</span> vector with <span class="math inline">\(\vec{y}_t\)</span>.</p>
<p>Extract <span class="math inline">\(\vec{y}_t\)</span> from vectors returned by <code>ssm_sim_rng</code>.</p>
<pre class="stan"><code>
vector ssm_sim_get_y(vector x, int m, int p, int q) {
  vector[p] y;
  int idx[4, 3];
  idx = ssm_sim_idx(m, p, q);
  y = x[idx[1, 2]:idx[1, 3]];
  return y;
}

</code></pre>
</div>
<div id="ssm_sim_get_a" class="section level3">
<h3><span class="header-section-number">9.8.4</span> ssm_sim_get_a</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: vector of results from <code>ssm_sim_rng</code></li>
<li><code>m</code>: The number of states</li>
<li><code>p</code>: The length of the observation vector</li>
<li><code>q</code>: The number of state disturbances</li>
</ul>
<p><strong>returns</strong> A <span class="math inline">\(m \times 1\)</span> vector with <span class="math inline">\(\vec{\alpha}_t\)</span>.</p>
<p>Extract <span class="math inline">\(\vec{\alpha}_t\)</span> from vectors returne by <code>ssm_sim_rng</code>.</p>
<pre class="stan"><code>
vector ssm_sim_get_a(vector x, int m, int p, int q) {
  vector[m] a;
  int idx[4, 3];
  idx = ssm_sim_idx(m, p, q);
  a = x[idx[2, 2]:idx[2, 3]];
  return a;
}

</code></pre>
</div>
<div id="ssm_sim_get_eps" class="section level3">
<h3><span class="header-section-number">9.8.5</span> ssm_sim_get_eps</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: vector of results from <code>ssm_sim_rng</code></li>
<li><code>m</code>: The number of states</li>
<li><code>p</code>: The length of the observation vector</li>
<li><code>q</code>: The number of state disturbances</li>
</ul>
<p><strong>returns</strong> vector A <span class="math inline">\(p \times 1\)</span> vector with <span class="math inline">\(\vec{\varepsilon}_t\)</span>.</p>
<p>Extract <span class="math inline">\(\vec{\varepsilon}_t\)</span> from vectors returne by <code>ssm_sim_rng</code>.</p>
<pre class="stan"><code>
vector ssm_sim_get_eps(vector x, int m, int p, int q) {
  vector[p] eps;
  int idx[4, 3];
  idx = ssm_sim_idx(m, p, q);
  eps = x[idx[3, 2]:idx[3, 3]];
  return eps;
}

</code></pre>
</div>
<div id="ssm_sim_get_eta" class="section level3">
<h3><span class="header-section-number">9.8.6</span> ssm_sim_get_eta</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: vector of results from <code>ssm_sim_rng</code></li>
<li><code>m</code>: The number of states</li>
<li><code>p</code>: The length of the observation vector</li>
<li><code>q</code>: The number of state disturbances</li>
</ul>
<p><strong>returns</strong> vector A <span class="math inline">\(q \times 1\)</span> vector with <span class="math inline">\(\vec{\eta}_t\)</span>.</p>
<p>Extract <span class="math inline">\(\vec{\eta}_t\)</span> from vectors returne by <code>ssm_sim_rng</code>.</p>
<pre class="stan"><code>
vector ssm_sim_get_eta(vector x, int m, int p, int q) {
  vector[q] eta;
  int idx[4, 3];
  idx = ssm_sim_idx(m, p, q);
  eta = x[idx[4, 2]:idx[4, 3]];
  return eta;
}

</code></pre>
</div>
<div id="ssm_sim_rng" class="section level3">
<h3><span class="header-section-number">9.8.7</span> ssm_sim_rng</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>n</code>: Number of time observations to draw, <span class="math inline">\(t = 1, \dots, n\)</span>.</li>
<li><code>d</code>: Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>H</code>: Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>c</code>: State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>a1</code>: Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>P1</code>: Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>returns</strong> of size <span class="math inline">\(n\)</span> of vectors with Draw <span class="math inline">\(\vec{y}_t\)</span>, <span class="math inline">\(\vec{\alpha}_t\)</span>, <span class="math inline">\(\vec{\eta}_t\)</span> and <span class="math inline">\(\vec{\varepsilon}_t\)</span>. See the description.</p>
<p>Simulate from a Linear Gaussian State Space model.</p>
<p>For <code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>d</code>, <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>Draw <span class="math inline">\(\vec{y}_t\)</span>, <span class="math inline">\(\vec{\alpha}_t\)</span>, <span class="math inline">\(\vec{\eta}_t\)</span> and <span class="math inline">\(\vec{\varepsilon}_t\)</span> from the state space model, <span class="math display">\[
\begin{aligned}[t]
\vec{y}_t &amp;= \vec{d}_t + \mat{Z}_t \vec{\alpha}_t + \vec{\varepsilon}_t,  &amp;
\vec{\varepsilon}_t &amp; \sim N(0, \mat{H}_t), \\
\vec{\alpha}_{t + 1} &amp;= \vec{c}_t + \mat{T}_t \vec{\alpha}_t + \mat{R}_t \vec{\eta}_t,  &amp;
\vec{\eta}_t &amp; \sim N(0, \mat{Q}_t), \\
&amp;&amp; \vec{\alpha}_1 &amp;\sim N(\vec{a}_1, \mat{P}_1) .
\end{aligned}
\]</span></p>
<p>The returned vectors are of length <span class="math inline">\(2 p + m + q\)</span>, in the format, <span class="math display">\[
(\vec{y}_t&#39;, \vec{\alpha}_t&#39;, \vec{\varepsilon}_t&#39;, \vec{\eta}_t&#39;) .
\]</span> Note that <span class="math inline">\(\eta_n = \vec{0}_q\)</span>. Use the functions <code>ssm_sim_get_y</code>, <code>ssm_sim_get_a</code>, <code>ssm_sim_get_eps</code>, and <code>ssm_sim_get_eta</code> to extract values from the vector.</p>
<table>
<thead>
<tr class="header">
<th align="left">element</th>
<th align="left">length</th>
<th align="left">start</th>
<th align="left">end</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(y_t\)</span></td>
<td align="left"><span class="math inline">\(p\)</span></td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left"><span class="math inline">\(p\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\alpha\)</span>_t</td>
<td align="left"><span class="math inline">\(m\)</span></td>
<td align="left"><span class="math inline">\(p + 1\)</span></td>
<td align="left"><span class="math inline">\(p + m\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(\varepsilon_t\)</span></td>
<td align="left"><span class="math inline">\(p\)</span></td>
<td align="left"><span class="math inline">\(p + m + 1\)</span></td>
<td align="left"><span class="math inline">\(2 p + m\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(\eta_t\)</span></td>
<td align="left"><span class="math inline">\(q\)</span></td>
<td align="left"><span class="math inline">\(2 p + m + 1\)</span></td>
<td align="left"><span class="math inline">\(2 p + m + q\)</span></td>
</tr>
</tbody>
</table>
<p>It is preferrable to use <code>ssm_sim_get_y</code>, <code>ssm_sim_get_a</code>, <code>ssm_sim_get_eps</code>, and <code>ssm_sim_get_eta</code> to extract values from these vectors.</p>
<pre class="stan"><code>
vector[] ssm_sim_rng(int n,
                    vector[] d, matrix[] Z, matrix[] H,
                    vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                    vector a1, matrix P1) {
  vector[ssm_sim_size(dims(Z)[3], dims(Z)[2], dims(Q)[2])] ret[n];
  int p;
  int m;
  int q;
  m = dims(Z)[3];
  p = dims(Z)[2];
  q = dims(Q)[2];
  {
    // system matrices for current iteration
    vector[p] d_t;
    matrix[p, m] Z_t;
    matrix[p, p] H_t;
    matrix[p, p] HL;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    matrix[q, q] QL;
    // outputs
    vector[p] y;
    vector[p] eps;
    vector[m] a;
    vector[q] eta;
    // constants
    vector[p] zero_p;
    vector[q] zero_q;
    vector[m] zero_m;
    int idx[4, 3];

    d_t = d[1];
    Z_t = Z[1];
    H_t = H[1];
    HL = cholesky_decompose2(H_t);
    c_t = c[1];
    T_t = T[1];
    R_t = R[1];
    Q_t = Q[1];
    QL = cholesky_decompose2(Q_t);

    idx = ssm_sim_idx(m, p, q);
    zero_p = rep_vector(0.0, p);
    zero_q = rep_vector(0.0, q);
    zero_m = rep_vector(0.0, m);
    a = multi_normal2_rng(a1, P1);
    for (t in 1:n) {
      // save alpha
      ret[t, idx[2, 2]:idx[2, 3]] = a;
      // set system matrices
      if (t &gt; 1) {
        if (size(d) &gt; 1) {
          d_t = d[t];
        }
        if (size(Z) &gt; 1) {
          Z_t = Z[t];
        }
        if (size(H) &gt; 1) {
          H_t = H[t];
          HL = cholesky_decompose2(H_t);
        }
      }
      // draw forecast error and observed value
      eps = multi_normal_cholesky2_rng(zero_p, HL);
      y = d_t + Z_t * a + eps;
      // save
      ret[t, idx[1, 2]:idx[1, 3]] = y;
      ret[t, idx[3, 2]:idx[3, 3]] = eps;
      // calculate eta_{t} and a_{t + 1}
      if (t &lt; n) {
        if (size(c) &gt; 1) {
          c_t = c[t];
        }
        if (size(T) &gt; 1) {
          T_t = T[t];
        }
        if (size(R) &gt; 1) {
          R_t = R[t];
        }
        if (size(Q) &gt; 1) {
          Q_t = Q[t];
          QL = cholesky_decompose2(Q_t);
        }
        eta = multi_normal_cholesky2_rng(zero_q, QL);
        a = c_t + T_t * a + R_t * eta;
      } else {
        // don&#39;t forecast alpha_{t + 1}, so don&#39;t draw eta_t
        eta = zero_q;
      }
      // save eta_t; alpha is saved at the start of the loop.
      ret[t, idx[4, 2]:idx[4, 3]] = eta;
    }
  }
  return ret;
}

</code></pre>
</div>
</div>
<div id="simulation-smoothers" class="section level2">
<h2><span class="header-section-number">9.9</span> Simulation Smoothers</h2>
<div id="ssm_simsmo_states_rng" class="section level3">
<h3><span class="header-section-number">9.9.1</span> ssm_simsmo_states_rng</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>filter</code>: A length <span class="math inline">\(n\)</span> array with results from <code>ssm_filter</code>.</li>
<li><code>d</code>: Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>H</code>: Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>c</code>: State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>a1</code>: Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>P1</code>: Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>returns</strong> Array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(m \times 1\)</span> vectors containing a single draw from <span class="math inline">\((\vec{\alpha}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>State simulation smoother</p>
<p>Draw samples from the posterior distribution of the states, <span class="math inline">\(\tilde{\vec{\alpha}}_{1:n} \sim p(\vec{\alpha}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>For <code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>d</code>, <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>This draws samples using mean-correction simulation smoother of <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2002">2002</a>)</span>. See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.9)</span>.</p>
<pre class="stan"><code>
vector[] ssm_simsmo_states_rng(vector[] filter,
                      vector[] d, matrix[] Z, matrix[] H,
                      vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                      vector a1, matrix P1) {
    vector[dims(Z)[3]] draws[size(filter)];
    int n;
    int p;
    int m;
    int q;
    n = size(filter);
    m = dims(Z)[3];
    p = dims(Z)[2];
    q = dims(Q)[2];
    {
      vector[ssm_filter_size(m, p)] filter_plus[n];
      vector[ssm_sim_size(m, p, q)] sims[n];
      vector[p] y[n];
      vector[m] alpha_hat_plus[n];
      vector[m] alpha_hat[n];
      // Smooth states
      alpha_hat = ssm_smooth_state_mean(filter, Z, c, T, R, Q);
      // simulate unconditional disturbances and observations
      sims = ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1);
      for (i in 1:n) {
        y[i] = ssm_sim_get_y(sims[i], m, p, q);
      }
      // filter with simulated y&#39;s
      filter_plus = ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1);
      // mean correct epsilon samples
      alpha_hat_plus = ssm_smooth_state_mean(filter_plus, Z, c, T, R, Q);
      for (i in 1:n) {
        draws[i] = (ssm_sim_get_a(sims[i], m, p, q)
                    - alpha_hat_plus[i]
                    + alpha_hat[i]);
      }
    }
    return draws;
}


</code></pre>
</div>
<div id="ssm_simsmo_states_miss_rng" class="section level3">
<h3><span class="header-section-number">9.9.2</span> ssm_simsmo_states_miss_rng</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>filter</code>: A length <span class="math inline">\(n\)</span> array with results from <code>ssm_filter</code>.</li>
<li><code>d</code>: Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>H</code>: Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>c</code>: State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>a1</code>: Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>P1</code>: Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
<li><code>p_t</code>: A length <span class="math inline">\(n\)</span> array with the number of non-missing elements in the observation vector, <span class="math inline">\(\vec{y}_t\)</span>, at each <span class="math inline">\(t \in 1, \dots, n\)</span>.</li>
<li><code>y_idx</code>: A length <span class="math inline">\(n \times p\)</span> array of integers. The first <span class="math inline">\(p_t\)</span> elments of this array indexes of thenon-missing values of <span class="math inline">\(y\)</span>. Elements <span class="math inline">\(1:p_t\)</span> should be between <span class="math inline">\(1\)</span> and <span class="math inline">\(p\)</span>; elements <span class="math inline">\(p_t:p\)</span> are zero, and are not used.</li>
</ul>
<p><strong>returns</strong> Array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(m \times 1\)</span> vectors containing a single draw from <span class="math inline">\((\vec{\alpha}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>State simulation smoother, as in <code>ssm_simsmo_states_rng</code>, allowing for missing values.</p>
<pre class="stan"><code>
vector[] ssm_simsmo_states_miss_rng(vector[] filter,
                      vector[] d, matrix[] Z, matrix[] H,
                      vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                      vector a1, matrix P1, int[] p_t, int[,] y_idx) {
    vector[dims(Z)[3]] draws[size(filter)];
    int n;
    int p;
    int m;
    int q;
    n = size(filter);
    m = dims(Z)[3];
    p = dims(Z)[2];
    q = dims(Q)[2];
    {
      vector[ssm_filter_size(m, p)] filter_plus[n];
      vector[ssm_sim_size(m, p, q)] sims[n];
      vector[p] y[n];
      vector[m] alpha_hat_plus[n];
      vector[m] alpha_hat[n];
      // Smooth states
      alpha_hat = ssm_smooth_state_mean(filter, Z, c, T, R, Q);
      // simulate unconditional disturbances and observations
      sims = ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1);
      for (i in 1:n) {
        y[i] = ssm_sim_get_y(sims[i], m, p, q);
      }
      // filter with simulated y&#39;s
      filter_plus = ssm_filter_miss(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx);
      // mean correct epsilon samples
      alpha_hat_plus = ssm_smooth_state_mean(filter_plus, Z, c, T, R, Q);
      for (i in 1:n) {
        draws[i] = (ssm_sim_get_a(sims[i], m, p, q)
                    - alpha_hat_plus[i]
                    + alpha_hat[i]);
      }
    }
    return draws;
}

</code></pre>
</div>
<div id="ssm_simsmo_eta_rng" class="section level3">
<h3><span class="header-section-number">9.9.3</span> ssm_simsmo_eta_rng</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>filter</code>: A length <span class="math inline">\(n\)</span> array with results from <code>ssm_filter</code>.</li>
<li><code>d</code>: Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>H</code>: Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>c</code>: State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>a1</code>: Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>P1</code>: Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>returns</strong> Array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(q \times 1\)</span> vectors containing a single draw from <span class="math inline">\((\vec{\eta}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>State disturbance simulation smoother</p>
<p>Draw samples from the posterior distribution of the observation disturbances, <span class="math inline">\(\tilde{\vec{\eta}}_{1:n} \sim p(\vec{\eta}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>For <code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>d</code>, <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>This draws samples using mean-correction simulation smoother of <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2002">2002</a>)</span>. See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.9)</span>.</p>
<pre class="stan"><code>
vector[] ssm_simsmo_eta_rng(vector[] filter,
                            vector[] d, matrix[] Z, matrix[] H,
                            vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                            vector a1, matrix P1) {
    vector[dims(Q)[2]] draws[size(filter)];
    int n;
    int p;
    int m;
    int q;
    n = size(filter);
    m = dims(Z)[3];
    p = dims(Z)[2];
    q = dims(Q)[2];
    {
      vector[ssm_filter_size(m, p)] filter_plus[n];
      vector[p] y[n];
      vector[ssm_sim_size(m, p, q)] sims[n];
      vector[ssm_smooth_eta_size(q)] eta_hat[n];
      vector[ssm_smooth_eta_size(q)] eta_hat_plus[n];
      // get smoothed etas
      eta_hat = ssm_smooth_eta(filter, Z, T, R, Q);
      // simulate unconditional disturbances and observations
      sims = ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1);
      for (i in 1:n) {
        y[i] = ssm_sim_get_y(sims[i], m, p, q);
      }
      // filter simulated y&#39;s
      filter_plus = ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1);
      // mean correct eta samples
      eta_hat_plus = ssm_smooth_eta(filter_plus, Z, T, R, Q);
      for (i in 1:n) {
        draws[i] = (ssm_sim_get_eta(sims[i], m, p, q)
                    - ssm_smooth_eta_get_mean(eta_hat_plus[i], q)
                    + ssm_smooth_eta_get_mean(eta_hat[i], q));
      }
    }
    return draws;
}


</code></pre>
</div>
<div id="ssm_simsmo_eta_miss_rng" class="section level3">
<h3><span class="header-section-number">9.9.4</span> ssm_simsmo_eta_miss_rng</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>filter</code>: A length <span class="math inline">\(n\)</span> array with results from <code>ssm_filter</code>.</li>
<li><code>d</code>: Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>H</code>: Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>c</code>: State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>a1</code>: Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>P1</code>: Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
<li><code>p_t</code>: A length <span class="math inline">\(n\)</span> array with the number of non-missing elements in the observation vector, <span class="math inline">\(\vec{y}_t\)</span>, at each <span class="math inline">\(t \in 1, \dots, n\)</span>.</li>
<li><code>y_idx</code>: A length <span class="math inline">\(n \times p\)</span> array of integers. The first <span class="math inline">\(p_t\)</span> elments of this array indexes of thenon-missing values of <span class="math inline">\(y\)</span>. Elements <span class="math inline">\(1:p_t\)</span> should be between <span class="math inline">\(1\)</span> and <span class="math inline">\(p\)</span>; elements <span class="math inline">\(p_t:p\)</span> are zero, and are not used.</li>
</ul>
<p><strong>returns</strong> Array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(q \times 1\)</span> vectors containing a single draw from <span class="math inline">\((\vec{\eta}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>State disturbance simulation smoother, as in <code>ssm_simsmo_eta_rng</code>, but allowing for missing values in <span class="math inline">\(\vec{y}_t\)</span>.</p>
<pre class="stan"><code>
vector[] ssm_simsmo_eta_miss_rng(vector[] filter,
                            vector[] d, matrix[] Z, matrix[] H,
                            vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                            vector a1, matrix P1, int[] p_t, int[,] y_idx) {
    vector[dims(Q)[2]] draws[size(filter)];
    int n;
    int p;
    int m;
    int q;
    n = size(filter);
    m = dims(Z)[3];
    p = dims(Z)[2];
    q = dims(Q)[2];
    {
      vector[ssm_filter_size(m, p)] filter_plus[n];
      vector[p] y[n];
      vector[ssm_sim_size(m, p, q)] sims[n];
      vector[ssm_smooth_eta_size(q)] eta_hat[n];
      vector[ssm_smooth_eta_size(q)] eta_hat_plus[n];
      // get smoothed etas
      eta_hat = ssm_smooth_eta(filter, Z, T, R, Q);
      // simulate unconditional disturbances and observations
      sims = ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1);
      for (i in 1:n) {
        y[i] = ssm_sim_get_y(sims[i], m, p, q);
      }
      // filter simulated y&#39;s
      filter_plus = ssm_filter_miss(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx);
      // mean correct eta samples
      eta_hat_plus = ssm_smooth_eta(filter_plus, Z, T, R, Q);
      for (i in 1:n) {
        draws[i] = (ssm_sim_get_eta(sims[i], m, p, q)
                    - ssm_smooth_eta_get_mean(eta_hat_plus[i], q)
                    + ssm_smooth_eta_get_mean(eta_hat[i], q));
      }
    }
    return draws;
}

</code></pre>
</div>
<div id="ssm_simsmo_eps_rng" class="section level3">
<h3><span class="header-section-number">9.9.5</span> ssm_simsmo_eps_rng</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>filter</code>: A length <span class="math inline">\(n\)</span> array with results from <code>ssm_filter</code>.</li>
<li><code>d</code>: Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>H</code>: Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>c</code>: State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>a1</code>: Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>P1</code>: Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
</ul>
<p><strong>returns</strong> Array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(p \times 1\)</span> vectors containing a single draw from <span class="math inline">\((\vec{\varepsilon}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>Observation disturbance simulation smoother.</p>
<p>Draw samples from the posterior distribution of the observation disturbances, <span class="math inline">\(\tilde{\vec{\varepsilon}}_{1:n} \sim p(\vec{\varepsilon}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>For <code>d</code>, <code>Z</code>, <code>H</code>, <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code> the array can have a size of 1, if it is not time-varying, or a size of <span class="math inline">\(n\)</span> (for <code>d</code>, <code>Z</code>, <code>H</code>) or <span class="math inline">\(n - 1\)</span> (for <code>c</code>, <code>T</code>, <code>R</code>, <code>Q</code>) if it is time varying.</p>
<p>This draws samples using mean-correction simulation smoother of <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2002">2002</a>)</span>. See <span class="citation">(Durbin and Koopman <a href="#ref-DurbinKoopman2012">2012</a>, Sec 4.9)</span>.</p>
<pre class="stan"><code>
vector[] ssm_simsmo_eps_rng(vector[] filter,
                      vector[] d, matrix[] Z, matrix[] H,
                      vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                      vector a1, matrix P1) {
    vector[dims(Z)[2]] draws[size(filter)];
    int n;
    int p;
    int m;
    int q;
    n = size(filter);
    m = dims(Z)[3];
    p = dims(Z)[2];
    q = dims(Q)[2];
    {
      vector[ssm_filter_size(m, p)] filter_plus[n];
      vector[p] y[n];
      vector[ssm_sim_size(m, p, q)] sims[n];
      vector[ssm_smooth_eps_size(p)] eps_hat_plus[n];
      vector[ssm_smooth_eps_size(p)] eps_hat[n];

      // get smoothed values of epsilon
      eps_hat = ssm_smooth_eps(filter, Z, H, T);
      // simulate unconditional disturbances and observations
      sims = ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1);
      for (i in 1:n) {
        y[i] = ssm_sim_get_y(sims[i], m, p, q);
      }
      // filter simulated y&#39;s
      filter_plus = ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1);
      // mean correct epsilon samples
      eps_hat_plus = ssm_smooth_eps(filter_plus, Z, H, T);
      for (i in 1:n) {
        draws[i] = (ssm_sim_get_eps(sims[i], m, p, q)
                    - ssm_smooth_eps_get_mean(eps_hat_plus[i], p)
                    + ssm_smooth_eps_get_mean(eps_hat[i], p));
      }
    }
    return draws;
}


</code></pre>
</div>
<div id="ssm_simsmo_eps_miss_rng" class="section level3">
<h3><span class="header-section-number">9.9.6</span> ssm_simsmo_eps_miss_rng</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>filter</code>: A length <span class="math inline">\(n\)</span> array with results from <code>ssm_filter</code>.</li>
<li><code>d</code>: Observation intercept, <span class="math inline">\(\vec{d}_t\)</span>. An array of <span class="math inline">\(p \times 1\)</span> vectors.</li>
<li><code>Z</code>: Design matrix, <span class="math inline">\(\mat{Z}_t\)</span>. An array of <span class="math inline">\(p \times m\)</span> matrices.</li>
<li><code>H</code>: Observation covariance matrix, <span class="math inline">\(\mat{H}_t\)</span>. An array of <span class="math inline">\(p \times p\)</span> matrices.</li>
<li><code>c</code>: State intercept, <span class="math inline">\(\vec{c}_t\)</span>. An array of <span class="math inline">\(m \times 1\)</span> vectors.</li>
<li><code>T</code>: Transition matrix, <span class="math inline">\(\mat{T}_t\)</span>. An array of <span class="math inline">\(m \times m\)</span> matrices.</li>
<li><code>R</code>: State covariance selection matrix, <span class="math inline">\(\mat{R} _t\)</span>. An array of <span class="math inline">\(p \times q\)</span> matrices.</li>
<li><code>Q</code>: State covariance matrix, <span class="math inline">\(\mat{Q}_t\)</span>. An array of <span class="math inline">\(q \times q\)</span> matrices.</li>
<li><code>a1</code>: Expected value of the intial state, <span class="math inline">\(a_1 = \E(\alpha_1)\)</span>. An <span class="math inline">\(m \times 1\)</span> matrix.</li>
<li><code>P1</code>: Variance of the initial state, <span class="math inline">\(P_1 = \Var(\alpha_1)\)</span>. An <span class="math inline">\(m \times m\)</span> matrix.</li>
<li><code>p_t</code>: A length <span class="math inline">\(n\)</span> array with the number of non-missing elements in the observation vector, <span class="math inline">\(\vec{y}_t\)</span>, at each <span class="math inline">\(t \in 1, \dots, n\)</span>.</li>
<li><code>y_idx</code>: A length <span class="math inline">\(n \times p\)</span> array of integers. The first <span class="math inline">\(p_t\)</span> elments of this array indexes of thenon-missing values of <span class="math inline">\(y\)</span>. Elements <span class="math inline">\(1:p_t\)</span> should be between <span class="math inline">\(1\)</span> and <span class="math inline">\(p\)</span>; elements <span class="math inline">\(p_t:p\)</span> are zero, and are not used.</li>
</ul>
<p><strong>returns</strong> Array of size <span class="math inline">\(n\)</span> of <span class="math inline">\(p \times 1\)</span> vectors containing a single draw from <span class="math inline">\((\vec{\varepsilon}_{1:n} | \vec{y}_{1:n})\)</span>.</p>
<p>Observation disturbance simulation smoother, as in <code>ssm_simsmo_eps_rng</code>, but allowing for missing values in <span class="math inline">\(\vec{y}_t\)</span>.</p>
<pre class="stan"><code>vector[] ssm_simsmo_eps_miss_rng(vector[] filter,
                      vector[] d, matrix[] Z, matrix[] H,
                      vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                      vector a1, matrix P1, int[] p_t, int[,] y_idx) {
    vector[dims(Z)[2]] draws[size(filter)];
    int n;
    int p;
    int m;
    int q;
    n = size(filter);
    m = dims(Z)[3];
    p = dims(Z)[2];
    q = dims(Q)[2];
    {
      vector[ssm_filter_size(m, p)] filter_plus[n];
      vector[p] y[n];
      vector[ssm_sim_size(m, p, q)] sims[n];
      vector[ssm_smooth_eps_size(p)] eps_hat_plus[n];
      vector[ssm_smooth_eps_size(p)] eps_hat[n];

      // get smoothed values of epsilon
      eps_hat = ssm_smooth_eps(filter, Z, H, T);
      // simulate unconditional disturbances and observations
      sims = ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1);
      for (i in 1:n) {
        y[i] = ssm_sim_get_y(sims[i], m, p, q);
      }
      // filter simulated y&#39;s
      filter_plus = ssm_filter_miss(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx);
      // mean correct epsilon samples
      eps_hat_plus = ssm_smooth_eps(filter_plus, Z, H, T);
      for (i in 1:n) {
        draws[i] = (ssm_sim_get_eps(sims[i], m, p, q)
                    - ssm_smooth_eps_get_mean(eps_hat_plus[i], p)
                    + ssm_smooth_eps_get_mean(eps_hat[i], p));
      }
    }
    return draws;
}

</code></pre>
</div>
</div>
<div id="stationary" class="section level2">
<h2><span class="header-section-number">9.10</span> Stationary</h2>
<div id="pacf_to_acf" class="section level3">
<h3><span class="header-section-number">9.10.1</span> pacf_to_acf</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: A vector of coefficients of a partial autocorrelation function</li>
</ul>
<p><strong>returns</strong> A vector of coefficients of an Autocorrelation function</p>
<p>Partial Autocorrelations to Autocorrelations</p>
<pre class="stan"><code>
// from R function partrans in arima.c
// https://github.com/wch/r-source/blob/e5b21d0397c607883ff25cca379687b86933d730/src/library/stats/src/arima.c#L439
vector pacf_to_acf(vector x) {
  vector[num_elements(x)] x_new;
  vector[num_elements(x)] work;
  real a;
  int p;
  p = num_elements(x);
  work = x;
  x_new = x;
  if (p &gt; 1) {
    for (j in 2:p) {
      a = x_new[j];
      for (k in 1:(j - 1)) {
        work[k] = work[k] - a * x_new[j - k];
      }
      for (k in 1:j) {
        x_new[k] = work[k];
      }
    }
  }
  return x_new;
}

</code></pre>
</div>
<div id="constrain_stationary" class="section level3">
<h3><span class="header-section-number">9.10.2</span> constrain_stationary</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: An unconstrained vector in <span class="math inline">\((-\infty, \infty)\)</span></li>
</ul>
<p><strong>returns</strong> A vector of coefficients for a stationary AR or inverible MA process.</p>
<p>Constrain vector of coefficients to the stationary and intertible region for AR or MA functions.</p>
<p>See <span class="citation">R. H. Jones (<a href="#ref-Jones1980a">1980</a>)</span>, <span class="citation">M. C. Jones (<a href="#ref-Jones1987a">1987</a>)</span>, <span class="citation">Monahan (<a href="#ref-Monahan1984a">1984</a>)</span>, <span class="citation">Ansley and Kohn (<a href="#ref-AnsleyKohn1986a">1986</a>)</span>, and the functions <code>tools.constrain_stationary_univariate</code> and <code>tools.unconstraine_stationary_univariate</code> in <a href="http://www.statsmodels.org/dev/statespace.html#statespace-tools">statsmodels.tsa.statespace</a>.</p>
<ol style="list-style-type: decimal">
<li>Each <span class="math inline">\(\alpha_j \in (-\infty, \infty)\)</span> is transformed to a partial correlation within <span class="math inline">\((-1, 1)\)</span>, with <span class="math inline">\(\rho_j = \tanh(\alpha_j)\)</span>.</li>
<li>Then the partial correlations are converted to autocorrelation coefficients using the Durbin-Levinson recursions: <span class="math display">\[
   \]</span></li>
</ol>
<p>The transformation is reversed to take autocorrelation coefficients to an unconstrained <span class="math inline">\(R^p\)</span> space.</p>
<ol style="list-style-type: decimal">
<li>Autocorrelation coefficients are transformed to partial autocorrelation coefficients, by running the Durbin-Levinson recursions in reverse.</li>
<li>Transform each partial autocorrelation to go from <span class="math inline">\((-1, 1) \to (-\infty, \infty)\)</span> using, <span class="math inline">\(\alpha_j = \atanh(\rho_j)\)</span>.</li>
</ol>
<pre class="stan"><code>
vector constrain_stationary(vector x) {
  vector[num_elements(x)] r;
  int n;
  n = num_elements(x);
  // transform (-Inf, Inf) to (-1, 1)
  for (i in 1:n) {
    r[i] = tanh(x[i]);
  }
  // Transform PACF to ACF
  return pacf_to_acf(r);
}



</code></pre>
</div>
<div id="acf_to_pacf" class="section level3">
<h3><span class="header-section-number">9.10.3</span> acf_to_pacf</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: Coeffcients of an autocorrelation function.</li>
</ul>
<p><strong>returns</strong> A vector of coefficients of the corresponding partial autocorrelation function.</p>
<p>Convert coefficients of an autocorrelation function to partial autocorrelations.</p>
<pre class="stan"><code>
// from R function invpartrans in arima.c
// https://github.com/wch/r-source/blob/e5b21d0397c607883ff25cca379687b86933d730/src/library/stats/src/arima.c#L525
vector acf_to_pacf(vector x) {
  vector[num_elements(x)] x_new;
  vector[num_elements(x)] work;
  real a;
  int p;
  p = num_elements(x);
  work = x;
  x_new = x;
  // Run the Durbin-Levinson recursions backwards
  if (p &gt; 1) {
    for(i in 0:(p - 2)) {
      int j;
      j = p - i;
      a = x_new[j];
      for(k in 1:(j - 1)) {
        work[k]  = (x_new[k] + a * x_new[j - k]) / (1 - pow(a, 2));
      }
      for (k in 1:j) {
        x_new[k] = work[k];
      }
    }
  }
  return x_new;
}

</code></pre>
</div>
<div id="unconstrain_stationary" class="section level3">
<h3><span class="header-section-number">9.10.4</span> unconstrain_stationary</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code>: Coeffcients of an autocorrelation function.</li>
</ul>
<p><strong>returns</strong> Coefficients of the corresponding partial autocorrelation function.</p>
<p>Transform from stationary and invertible space to <span class="math inline">\((-\infty, \infty)\)</span>.</p>
<pre class="stan"><code>
vector unconstrain_stationary(vector x) {
  matrix[num_elements(x), num_elements(x)] y;
  vector[num_elements(x)] r;
  vector[num_elements(x)] z;
  int n;
  n = num_elements(x);
  // Transform ACF to PACF
  r = acf_to_pacf(x);
  // Transform (-1, 1) to (-Inf, Inf)
  for (i in 1:n) {
    z[i] = atanh(r[i]);
  }
  return z;
}



</code></pre>
</div>
<div id="kronecker_prod" class="section level3">
<h3><span class="header-section-number">9.10.5</span> kronecker_prod</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>A</code>: An <span class="math inline">\(m \times n\)</span> matrix</li>
<li><code>B</code>: A <span class="math inline">\(p \times q\)</span> matrix</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(mp \times nq\)</span> matrix.</p>
<p>Kronecker product</p>
<p>The Kronecker product of a <span class="math inline">\(\mat{A}\)</span> and <span class="math inline">\(\mat{B}\)</span> is <span class="math display">\[
\mat{A} \otimes \mat{B} =
\begin{bmatrix}
a_{11} \mat{B} \cdots a_{1n} \mat{B} \
\vdots &amp; \ddots &amp; vdots \
a_{m1} \mat{B} &amp; \cdots &amp; a_{mn} \mat{B}
\end{bmatrix} .
\]</span></p>
<pre class="stan"><code>
matrix kronecker_prod(matrix A, matrix B) {
  matrix[rows(A) * rows(B), cols(A) * cols(B)] C;
  int m;
  int n;
  int p;
  int q;
  m = rows(A);
  n = cols(A);
  p = rows(B);
  q = cols(B);
  for (i in 1:m) {
    for (j in 1:n) {
      int row_start;
      int row_end;
      int col_start;
      int col_end;
      row_start = (i - 1) * p + 1;
      row_end = (i - 1) * p + p;
      col_start = (j - 1) * q + 1;
      col_end = (j - 1) * q + q;
      C[row_start:row_end, col_start:col_end] = A[i, j] * B;
    }
  }
  return C;
}

</code></pre>
</div>
<div id="stationary_cov" class="section level3">
<h3><span class="header-section-number">9.10.6</span> stationary_cov</h3>
<p><strong>Arguments</strong></p>
<ul>
<li><code>T</code>: The <span class="math inline">\(m \times m\)</span> transition matrix</li>
<li><code>RQR</code>: The <span class="math inline">\(m \times m\)</span> system covarariance matrix, <span class="math inline">\(\mat{R} \mat{Q} \mat{R}\T\)</span>.</li>
</ul>
<p><strong>returns</strong> An <span class="math inline">\(m \times m\)</span> matrix with the stationary covariance matrix.</p>
<p>Find the covariance of the stationary distribution of an ARMA model</p>
<p>When a system is stationary, the initial covariance <span class="math inline">\(P_1\)</span> satistfies, <span class="math display">\[
\mat{P}_1 = \mat{T} \mat{P}_1 \mat{T}\T + \mat{R} \mat{Q} \mat{R}\T
\]</span> This can be solved as, <span class="math display">\[
(\mat{T} \otimes \mat{T}) \VEC(\mat{P}_1) = \VEC(\mat{R} \mat{Q} \mat{R}\T)
\]</span> where <span class="math inline">\(\VEC(P_1)\)</span> and <span class="math inline">\(\VEC(R R&#39;)\)</span> are the stacked columns of <span class="math inline">\(\mat{P}_1\)</span> and <span class="math inline">\(\mat{R} \mat{Q} \mat{R}\T\)</span></p>
<p>Note that in the special case of ARIMA models, <span class="math inline">\(\mat{Q} = \sigma^2\)</span>, so this simplifies to, <span class="math display">\[
(\mat{T} \otimes \mat{T}) \VEC(\mat{Q}_0) = \VEC(\mat{R} \mat{R}\T),
\]</span> where <span class="math inline">\(P_1 = \sigma^2 \mat{Q}_0\)</span>.</p>
<p>In a stationary distribution, the initial mean <span class="math inline">\(\vec{a}_1 = \vec{c}\)</span>.</p>
<p>See <span class="citation">Durbin and Koopman (<a href="#ref-DurbinKoopman2012">2012</a>)</span>, Sec 5.6.2.</p>
<pre class="stan"><code>
matrix stationary_cov(matrix T, matrix RQR) {
  matrix[rows(T), cols(T)] P;
  int m;
  m = rows(T);
  // m = 1 is an easy case, so treat it separately
  // since it doesn&#39;t require inverting a matrix
  if (m == 1) {
    P[1, 1] = RQR[1, 1] / (1.0 - pow(T[1, 1], 2));
  } else {
    matrix[rows(T) * rows(T), rows(T) * rows(T)] TT;
    vector[rows(T) * rows(T)] RQR_vec;
    int m2;
    m2 = m * m;
    RQR_vec = to_vector(RQR);
    # I_{m^2} - T \otimes T
    TT = - kronecker_prod(T, T);
    for (i in 1:m2) {
      TT[i, i] = 1.0 + TT[i, i];
    }
    P = to_matrix_colwise(inverse(TT) * RQR_vec, m, m);
  }
  return P;
}
</code></pre>

</div>
</div>
</div>
<h3> Other Software</h3>
<div id="refs" class="references">
<div id="ref-DurbinKoopman2012">
<p>Durbin, J., and S.J. Koopman. 2012. <em>Time Series Analysis by State Space Methods: Second Edition</em>. Oxford Statistical Science Series. OUP Oxford. <a href="http://books.google.com/books?id=fOq39Zh0olQC" class="uri">http://books.google.com/books?id=fOq39Zh0olQC</a>.</p>
</div>
<div id="ref-DurbinKoopman2002">
<p>Durbin, J., and S. J. Koopman. 2002. “A Simple and Efficient Simulation Smoother for State Space Time Series Analysis.” <em>Biometrika</em> 89 (3). Biometrika Trust: 603–15. <a href="http://www.jstor.org/stable/4140605" class="uri">http://www.jstor.org/stable/4140605</a>.</p>
</div>
<div id="ref-Jones1980a">
<p>Jones, Richard H. 1980. “Maximum Likelihood Fitting of ARMA Models to Time Series with Missing Observations.” <em>Technometrics</em> 22 (3). [Taylor &amp; Francis, Ltd., American Statistical Association, American Society for Quality]: 389–95. <a href="http://www.jstor.org/stable/1268324" class="uri">http://www.jstor.org/stable/1268324</a>.</p>
</div>
<div id="ref-Jones1987a">
<p>Jones, M. C. 1987. “Randomly Choosing Parameters from the Stationarity and Invertibility Region of Autoregressive-Moving Average Models.” <em>Journal of the Royal Statistical Society. Series C (Applied Statistics)</em> 36 (2). [Wiley, Royal Statistical Society]: 134–38. <a href="http://www.jstor.org/stable/2347544" class="uri">http://www.jstor.org/stable/2347544</a>.</p>
</div>
<div id="ref-Monahan1984a">
<p>Monahan, John F. 1984. “A Note on Enforcing Stationarity in Autoregressive-Moving Average Models.” <em>Biometrika</em> 71 (2): 403–4. doi:<a href="https://doi.org/10.1093/biomet/71.2.403">10.1093/biomet/71.2.403</a>.</p>
</div>
<div id="ref-AnsleyKohn1986a">
<p>Ansley, Craig F., and Robert Kohn. 1986. “A Note on Reparameterizing a Vector Autoregressive Moving Average Model to Enforce Stationarity.” <em>Journal of Statistical Computation and Simulation</em> 24 (2): 99–106. doi:<a href="https://doi.org/10.1080/00949658608810893">10.1080/00949658608810893</a>.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="placeholder-1.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="other-software.html" class="navigation navigation-next " aria-label="Next page""><i class="fa fa-angle-right"></i></a>

<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/jrnold/ssmodels-in-stan/edit/master/stanfunctions.Rmd",
"text": "Edit"
},
"download": ["ssmodels-in-stan.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
