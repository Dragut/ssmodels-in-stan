\documentclass[]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Jeffrey B. Arnold},
            pdftitle={State Space Models in Stan},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{biblatex}
\addbibresource{packages.bib}
\addbibresource{ssmodels-in-stan.bib}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\ImportTok}[1]{{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{{#1}}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{{#1}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{{#1}}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{{#1}}}}
\newcommand{\BuiltInTok}[1]{{#1}}
\newcommand{\ExtensionTok}[1]{{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
\usepackage{longtable,booktabs}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}

%%% Use protect on footnotes to avoid problems with footnotes in titles
\let\rmarkdownfootnote\footnote%
\def\footnote{\protect\rmarkdownfootnote}

%%% Change title format to be more compact
\usepackage{titling}

% Create subtitle command for use in maketitle
\newcommand{\subtitle}[1]{
  \posttitle{
    \begin{center}\large#1\end{center}
    }
}

\setlength{\droptitle}{-2em}
  \title{State Space Models in Stan}
  \pretitle{\vspace{\droptitle}\centering\huge}
  \posttitle{\par}
  \author{Jeffrey B. Arnold}
  \preauthor{\centering\large\emph}
  \postauthor{\par}
  \predate{\centering\large\emph}
  \postdate{\par}
  \date{2016-07-01}

\usepackage{booktabs}

\DeclareMathOperator{\E}{E}
\DeclareMathOperator{\mean}{mean}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator{\Cov}{Cov}
\DeclareMathOperator{\Cor}{Cor}
\DeclareMathOperator{\Bias}{Bias}
\DeclareMathOperator{\MSE}{MSE}
\DeclareMathOperator{\sd}{sd}
\DeclareMathOperator{\se}{se}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\VEC}{vec}

\newcommand{\mat}[1]{\boldsymbol{#1}}
\renewcommand{\vec}[1]{\boldsymbol{#1}}
\renewcommand{\T}{'}

\newcommand{\distr}[1]{\mathcal{#1}}
\newcommand{\dnorm}{\distr{N}}
\newcommand{\dmvnorm}[1]{\distr{N}_{#1}}
\newcommand{\dt}[1]{\distr{T}_{#1}}

\newcommand{\cia}{\perp\!\!\!\perp}
\DeclareMathOperator*{\plim}{plim}

% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\begin{document}
\maketitle

{
\hypersetup{linkcolor=black}
\setcounter{tocdepth}{1}
\tableofcontents
}
\chapter{Introduction}\label{introduction}

This contains documentation for ``State Space Models in Stan''

\chapter{The Linear State Space
Model}\label{the-linear-state-space-model}

\autocite[Sec 3.1]{DurbinKoopman2012}

The linear Gaussian state space model (SSM)\footnote{This is also called
  a dynamic linear model (DLM).} the the \(n\)-dimensional observation
sequence \(\vec{y}_1, \dots, \vec{y}_n\), \[
\begin{aligned}[t]
\vec{y}_t &= \vec{d}_t + \mat{Z}_t \vec{\alpha}_t + \vec{\varepsilon}_t,  &
\vec{\varepsilon}_t & \sim N(0, \mat{H}_t), \\
\vec{\alpha}_{t + 1} &= \vec{c}_t + \mat{T}_t \vec{\alpha}_t + \mat{R}_t \vec{\eta}_t,  &
\vec{\eta}_t & \sim N(0, \mat{Q}_t), \\
&& \vec{\alpha}_1 &\sim N(\vec{a}_1, \mat{P}_1) .
\end{aligned}
\] for \(t = 1, \dots, n\). The first equation is called the
\emph{observation} or \emph{measurement equation}. The second equation
is called the \emph{state}, \emph{transition}, or \emph{system
equation}. The vector \(\vec{y}_t\) is a \(p \times 1\) vector called
the \emph{observation vector}. The vector \(\alpha{\alpha}_t\) is a
\(m \times 1\) vector called the \emph{state vector}. The matrices are
vectors, \(\mat{Z}_t\),\(\mat{T}_t\), \(\mat{R}_t\), \(\mat{H}_t\),
\(\mat{Q}_t\), \(c_t\), and \(d_t\) are called the \emph{system
matrices}. The system matrices are considered fixed and known in the
filtering and smoothing equations below, but can be parameters
themselves. The \(p \times m\) matrix \(\mat{Z}_t\) links the
observation vector \(\vec{y}_t\) with the state vector
\(\vec{\alpha}_t\). The \(m \times m\) transition matrix \(\mat{T}_t\)
determines the evolution of the state vector, \(\vec{\alpha}_t\). The
\(q \times 1\) vector \(\vec{\eta}_t\) is called the \emph{state
disturbance vector}, and the \(p \times 1\) vector
\(\vec{\varepsilon}_t\) is called the \emph{observation disturbance
vector}. An assumption is that the state and observation disturbance
vectors are uncorrelated,
\(\Cov(\vec{\varepsilon}_t, \vec{\eta}_t) = 0\).

In a general state space model, the normality assumptions of the
densities of \(\vec{\varepsilon}\) and \(\vec{\eta}\) are dropped.

In many cases \(\mat{R}_t\) is the identity matrix. It is possible to
define \(\eta^*_t = \mat{R}_t \vec{\eta}_t\), and
\(\mat{Q}^* = \mat{R}_t \mat{Q}_t' \mat{R}'_t\). However, if
\(\mat{R}_t\) is \(m \times q\) and \(q < m\), and \(\mat{Q}_t\) is
nonsingular, then it is useful to work with the nonsingular
\(\vec{\eta}_t\) rather than a singular \(\vec{\eta}_t^*\).

The initial state vector \(\vec{\alpha}_1\) is assume to be generated
as, \[
\alpha_1 \sim N(\vec{a}_1, \mat{P}_1)
\] independently of the observation and state disturbances
\(\vec{\varepsilon}\) and \(\vec{\eta}\). The values of \(\vec{a}_1\)
and \(\mat{P}_1\) can be considered as given and known in most
stationary processes. When the process is nonstationary, the elements of
\(\vec{a}_1\) need to be treated as unknown and estimated. This is
called \emph{initialization}.

\begin{longtable}[c]{@{}lll@{}}
\caption{Dimensions of matrices and vectors in the SSM}\tabularnewline
\toprule
matrix/vector & dimension & name\tabularnewline
\midrule
\endfirsthead
\toprule
matrix/vector & dimension & name\tabularnewline
\midrule
\endhead
\(\vec{y}_t\) & \(p \times 1\) & observation vector\tabularnewline
\(\vec{\alpha}_t\) & \(m \times 1\) & (unobserved) state
vector\tabularnewline
\(\vec{\varepsilon}_t\) & \(m \times 1\) & observation disturbance
(error)\tabularnewline
\(\vec{\eta}_t\) & \(q \times 1\) & state disturbance
(error)\tabularnewline
\(\vec{a}_1\) & \(m \times 1\) & initial state mean\tabularnewline
\(\vec{c}_t\) & \(m \times 1\) & state intercept\tabularnewline
\(\vec{d}_t\) & \(p \times 1\) & observation intercept\tabularnewline
\(\mat{Z}_t\) & \(p \times m\) & design matrix\tabularnewline
\(\mat{T}_t\) & \(m \times m\) & transition matrix\tabularnewline
\(\mat{H}_t\) & \(p \times p\) & observation covariance
matrix\tabularnewline
\(\mat{R}_t\) & \(m \times q\) & state covariance selection
matrix\tabularnewline
\(\mat{Q}_t\) & \(q \times q\) & state covariance matrix\tabularnewline
\(\mat{P}_1\) & \(m \times m\) & initial state covariance
matrix\tabularnewline
\bottomrule
\end{longtable}

\chapter{Filtering and Smoothing}\label{filtering-and-smoothing}

\section{Filtering}\label{filtering}

From \autocite[Sec 4.3]{DurbinKoopman2012}

Let \(\vec{a}_t = \E(\vec{\alpha}_t | y_{1, \dots, t - 1})\) be the
expected value
\(\vec{P}_t = \Var(\vec{\alpha}_t | y_{1, \dots, t - 1})\) be the
variance of the state in \(t + 1\) given data up to time \(t\). To
calculate \(\vec{\alpha}_{t + 1}\) and \(\mat{P}_{t + 1}\) given the
arrival of new data at time \(t\), \[
\begin{aligned}[t]
\vec{v}_t &= \vec{y}_t - \mat{Z}_t \vec{a}_t - \vec{d}_t, \\
\mat{F}_t &= \mat{Z}_t \mat{P}_t \mat{Z}_t\T + \mat{H}_t, \\
\mat{K}_t &= \mat{T}_t \mat{P}_t \mat{Z}_t\T \mat{F}_t^{-1} \\
\vec{a}_{t + 1} &= \mat{T}_t \vec{a}_t + \mat{K}_t \vec{v}_t + \vec{c}_t \\
\mat{P}_{t + 1} &= \mat{T}_t \mat{P}_t (\mat{T}_t - \mat{K}_t \mat{Z}_t)\T + \mat{R}_t \mat{Q}_t \mat{R}_t\T .
\end{aligned}
\] The vector \(\vec{v}_t\) are the \emph{one-step ahead forecast
errors\$, and the matrix \(\mat{K}_t\) is called the }Kalman gain*.

The filter can also be written to estimate the \emph{filtered states},
where \(\vec{a}_{t|t} = \E(\vec{\alpha}_t | y_{1, \dots, t})\) is the
expected value and
\(\vec{P}_{t|t} = \Var(\vec{\alpha}_t | y_{1, \dots, t})\) is the
variance of the state \(\vec{\alpha}_t\) given information up to
\emph{and including} \(\vec{y}_t\). The filter written this way is, \[
\begin{aligned}[t]
\vec{v}_t &= \vec{y}_t - \mat{Z}_t \vec{a}_t - \vec{d}_t, \\
\mat{F}_t &= \mat{Z}_t \mat{P}_t \mat{Z}_t\T + \mat{H}_t, \\
\vec{a}_{t|t} &= \vec{a}_t + \mat{P}_t \mat{Z}_t\T \mat{F}_t^{-1} v_t , \\
\mat{P}_{t|t} &= \mat{P}_t - \mat{P}_t \mat{Z}_t\T \mat{F}_t^{-1} \mat{Z}_t \mat{P}_t , \\
\vec{a}_{t + 1} &= \mat{T}_{t} \vec{a}_{t|t} + \vec{c}_t, \\
\mat{P}_{t + 1} & = \mat{T}_t \mat{P}_{t|t} \mat{T}_t\T + \mat{R}_t \mat{Q}_t \mat{R}_t\T .
\end{aligned}
\]

\begin{longtable}[c]{@{}ll@{}}
\caption{Dimensions of matrices and vectors in the SSM}\tabularnewline
\toprule
matrix/vector & dimension\tabularnewline
\midrule
\endfirsthead
\toprule
matrix/vector & dimension\tabularnewline
\midrule
\endhead
\(\vec{v}_t\) & \(p \times 1\)\tabularnewline
\(\vec{a}_t\) & \(m \times 1\)\tabularnewline
\(\vec{a}_{t|t}\) & \(m \times 1\)\tabularnewline
\(\mat{F}_t\) & \(p \times p\)\tabularnewline
\(\mat{K}_t\) & \(m \times p\)\tabularnewline
\(\mat{P}_t\) & \(m \times m\)\tabularnewline
\(\mat{P}_{t|T}\) & \(m \times m\)\tabularnewline
\(\vec{x}_t\) & \(m \times 1\)\tabularnewline
\(\mat{L}_t\) & \(m \times m\)\tabularnewline
\bottomrule
\end{longtable}

See \autocite[Sec 4.3.4]{DurbinKoopman2012}: For a time-invariant state
space model, the Kalman recursion for \(\mat{P}_{t + 1}\) converges to a
constant matrix \(\bar{\mat{P}}\), \[
\bar{\mat{P}} = \mat{T} \bar{\mat{P}} \mat{T}\T - \mat{T} \bar{\mat{P}} \mat{Z}\T \bar{\mat{F}}^{-1} \mat{Z} \bar{\mat{P}} \mat{T}\T + \mat{R} \mat{Q} \mat{R}\T ,
\] where \(\bar{\mat{F}} = \mat{Z} \bar{\mat{P}} \mat{Z}\T + \mat{H}\).

See \autocite[Sec 4.3.5]{DurbinKoopman2012}: The \emph{state estimation
error} is, \[
\vec{x}_t = \vec{\alpha}_t - \vec{a}_t,
\] where \(\Var(\vec{x}_t) = \mat{P}_t\). The \(v_t\) are sometimes
called \emph{innovations}, since they are the part of \(\vec{y}_t\) not
predicted from the past. The innovation analog of the state space model
is \[
\begin{aligned}[t]
\vec{v}_t &= \mat{Z}_t \vec{x}_t + \vec{\varepsilon}_t ,  \\
\vec{x}_{t + 1} &= \mat{L} \vec{x}_{t} + \mat{R}_t \vec{\eta}_t - \mat{K}_t \vec{\varepsilon}_t , \\
\mat{K}_t &= \mat{T}_t \mat{P}_t \mat{Z}_t\T \mat{F}_t^{-1} , \\
\mat{L}_t &= \mat{T}_t - \mat{K}_t \mat{Z}_t ,
\mat{P}_{t + 1} &= \mat{T}_t \mat{P}_t \mat{L}_t\T +  \mat{R}_t \mat{Q}_t \mat{R}_T\T  .
\end{aligned}
\] These recursions allow for a simpler derivation of
\(\mat{P}_{t + 1}\), and are useful for the smoothing recursions.
Moreover, the one-step ahead forecast errors are indendendent, which
allows for a simple derivation of the log-likelihood.

Alternative methods \textbf{TODO}

\begin{itemize}
\tightlist
\item
  square-root filtering
\item
  precision filters
\item
  sequential filtering
\end{itemize}

\section{Smoothing}\label{smoothing}

While filtering calculates the conditional densities the states and
disturbances given data prior to or up to the current time, smoothing
calculates the conditional densities states and disturbances given the
entire series of observations, \(\vec{y}_{1:n}\).

\emph{State smoothing} calculates the conditional mean,
\(\hat{\vec{\alpha}}_t = \E(\vec{\alpha}_t | \vec{y}_{1:n})\), and
variance, \(\mat{V}_t = \Var(\vec{\alpha}_t | \vec{y}_{1:n})\), of the
states. Observation disturbance smoothing calculates the conditional
mean,
\(\hat{\vec{\varepsilon}}_t = \E(\vec{\varepsilon}_t | \vec{y}_{1:n})\),
and variance, \(\Var(\vec{\varepsilon}_t | \vec{y}_{1:n})\), of the
state disturbances. Likewise, state disturbance smoothing calculates the
conditional mean,
\(\hat{\vec{\eta}}_t = \E(\vec{\eta}_t | \vec{y}_{1:n})\), and variance,
\(\Var(\vec{\eta}_t | \vec{y}_{1:n})\), of the state disturbances.

\begin{longtable}[c]{@{}ll@{}}
\caption{Dimensions of vectors and matrices used in smoothing
recursions}\tabularnewline
\toprule
Vector/Matrix & Dimension\tabularnewline
\midrule
\endfirsthead
\toprule
Vector/Matrix & Dimension\tabularnewline
\midrule
\endhead
\(\vec{r}_t\) & \(m \times 1\)\tabularnewline
\(\vec{\vec{\alpha}}_t\) & \(m \times 1\)\tabularnewline
\(\vec{u}_t\) & \(p \times 1\)\tabularnewline
\(\hat{\vec{\varepsilon}}_t\) & \(p \times 1\)\tabularnewline
\(\hat{\vec{\eta}}_t\) & \(r \times 1\)\tabularnewline
\(\mat{N}_t\) & \(m \times m\)\tabularnewline
\(\mat{V}_t\) & \(m \times m\)\tabularnewline
\(\mat{D}_t\) & \(p \times p\)\tabularnewline
\bottomrule
\end{longtable}

\subsection{State Smoothing}\label{state-smoothing}

Smoothing calculates conditional density of the states given all
observations, \(p(\vec{\alpha} | \vec{y}_{1:n})\). Let
\(\hat{\vec{\alpha}} = \E(\vec{\alpha}_t | \vec{y}_{1:n})\) be the mean
and \(\mat{V}_t = \Var(\vec{\alpha} | \vec{y}_{1:n})\) be the variance
of this density. The following recursions can be used to calculate these
densities \autocite[Sec 4.4.4]{DurbinKoopman2012}, \[
\begin{aligned}[t]
\vec{r}_{t - 1} &= \mat{Z}_t\T \mat{F}_t^{-1} \vec{v}_t + \mat{L}_t\T \vec{r}_t , &
\mat{N}_{t - 1} &= \mat{Z}_t\T \mat{F}_t^{-1} \mat{Z}_t + \mat{L}_t\T \mat{N}_t \mat{L}_t, \\
\hat{\vec{\alpha}}_t &= \vec{a}_t + \mat{P}_t \vec{r}_{t - 1} , &
\mat{V}_t &= \mat{P}_t - \mat{P}_t \mat{N}_{t - 1} \mat{P}_t ,
\end{aligned}
\] for \(t = n, \dots, 1\), with \(\vec{r}_n = \vec{0}\), and
\(\mat{N}_n = \mat{0}\).

During the filtering pass \(\vec{v}_t\), \(\mat{F}_t\), \(\mat{K}_t\),
and \(\mat{P}_t\) for \(t = 1, \dots, n\) need to be stored.
Alternatively, \(\vec{a}_t\) and \(\mat{P}_t\) only can be stored, and
\(\vec{v}_t\), \(\mat{F}_t\), \(\mat{K}_t\) recalculated on the fly.
However, since the dimensions of \(\vec{v}_t\), \(\mat{F}_t\),
\(\mat{K}_t\) are usually small relative to \(\vec{a}_t\) and
\(\mat{P}_t\) is is usually worth storing them.

\subsection{Disturbance smoothing}\label{disturbance-smoothing}

Disturbance smoothing calculates the density of the state and
observation disturbances (\(\vec{\eta}_t\) and \(\vec{\varepsilon}_t\))
given the full series of observations \(\vec{y}_{1:n}\). Let
\(\hat{\vec{\varepsilon}}_t = \E(\vec{\varepsilon} | \vec{y}_{1:n})\) be
the mean and \(\Var(\vec{\varepsilon}_t | \vec{y}_{1:n})\) be the
variance of the smoothed density of the observation disturbances at time
\(t\), \(p(\vec{\varepsilon}_t | \vec{y}_{1:n})\). Likewise, let
\(\hat{\vec{\eta}} = \E(\vec{\eta}_t | \vec{y}_{1:n})\) be the mean and
\(\Var(\vec{\eta}_t | \vec{y}_{1:n})\) be the variance of the smoothed
density of the state disturbances at time \(t\),
\(p(\vec{\eta}_t | \vec{y}_{1:n})\). The following recursions can be
used to calculate these values \autocite[Eq 4.69]{DurbinKoopman2012}: \[
\begin{aligned}[t]
\hat{\vec{\varepsilon}}_t &= \mat{H}_t (\mat{F}^{-1} \vec{v}_t - \mat{K}_t\T \vec{r}_t) , &
\Var(\vec{\varepsilon}_t | \mat{Y}_n) &= \mat{H}_t - \mat{H}_t (\mat{F}_t^{-1} + \mat{K}_t\T \mat{N}_t \mat{K}_t) \mat{H}_t , \\
\hat{\vec{\eta}}_t &= \mat{Q}_t \mat{R}_t\T \vec{r}_t , &
\Var(\vec{\eta}_t | \mat{Y}_n) &= \mat{Q}_t - \mat{Q}_t \mat{R}_t\T \mat{N}_t \mat{R}_t \mat{Q}_t , \\
\vec{r}_{t - 1} &= \mat{Z}_t\T \mat{F}_t^{-1} \vec{v}_t + \mat{L}_t\T \vec{r}_t , &
\mat{N}_{t - 1} &= \mat{Z}_t\T \mat{F}_t^{-1} \mat{Z}_t + \mat{L}_t\T \mat{N}_t \mat{L}_t
\end{aligned}
\] Alternatively, these equations can be rewritten as \autocite[Sec
4.5.3]{DurbinKoopman2012}: \[
\begin{aligned}[t]
\hat{\vec{\varepsilon}}_t &= \mat{H}_t \vec{u}_t , &
\Var(\vec{\varepsilon}_t | \mat{Y}_n) &= \mat{H}_t - \mat{H}_t \mat{D}_t \mat{H}_t , \\
\hat{\vec{\eta}}_t &= \mat{Q}_t \mat{R}_t\T \vec{r}_t , &
\Var(\vec{\eta}_t | \mat{Y}_n) &= \mat{Q}_t - \mat{Q}_t \mat{R}_t\T \mat{N}_t \mat{R}_t \mat{Q}_t , \\
\vec{u}_t &= \mat{F}^{-1} \vec{v}_t - \mat{K}_t\T \vec{r}_t , &
\mat{D}_t &= \mat{F}_t^{-1} + \mat{K}_t\T \mat{N}_t \mat{K}_t , \\
\vec{r}_{t - 1} &= \mat{Z}_t\T \vec{u}_t + \mat{T}_t\T \vec{r}_t , &
\mat{N}_{t - 1} &= \mat{Z}_t\T \mat{D}_t \mat{Z}_t + \mat{T}_t\T \mat{N}_t \mat{T}_t - \mat{Z}_t\T \mat{K}_t\T \mat{N}_t \mat{T}_t - \mat{T}_t\T \mat{N}_t \mat{K}_t \mat{Z}_t .
\end{aligned}
\] This reformulation can be computationally useful since it relies on
the system matrices \(\mat{Z}_t\) and \(\mat{T}_t\) which are often
sparse. The disturbance smoothing recursions require only \(\vec{v}_t\),
\(\mat{f}_t\), and \(\mat{K}_t\) which are calculated with a forward
pass of the Kalman filter. Unlike the state smoother, the disturbance
smoothers do not require either the mean (\(\vec{a}_t\)) or variance
(\(\mat{P}_t\)) of the predicted state density.

\subsection{Fast state smoothing}\label{fast-state-smoothing}

If the variances of the states do not need to be calculated, then a
faster smoothing algorithm can be used (Koopman 1993). The fast state
smoother is defined as \autocite[Sec 4.6.2]{DurbinKoopman2012}, \[
\begin{aligned}[t]
\hat{\vec{\alpha}}_t &= \mat{T}_t \hat{\vec{\alpha}}_t + \mat{R}_t \mat{Q}_t \mat{R}_t\T \vec{r}_t , && t = 2, \dots, n \\
\hat{\vec{\alpha}}_1 &= \vec{a}_1 + \mat{P}_1 \vec{r}_0 .
\end{aligned}
\] The values of \(\vec{r}_t\) come from the recursions in the
disturbance smoother.

\section{Simulation smoothers}\label{simulation-smoothers}

Simulation smoothing draws samples of the states,
\(p(\vec{\alpha}_1, \dots, \vec{\alpha}_n | \vec{y}_{1:n})\), or
disturbances,
\(p(\vec{\varepsilon}_1, \dots, \vec{\varepsilon}_n | \vec{y}_{1:n})\)
and
\(p(\vec{\eta}_1, \dots, \vec{\eta}_n | \vec{y}_{1:n})\).{[}\^{}simsmo{]}

\subsection{Mean correction simulation
smoother}\label{mean-correction-simulation-smoother}

The mean-correction simulation smoother was introduced in
\textcite{DurbinKoopman2002} . See \textcite{DurbinKoopman2012} (Sec
4.9) for an exposition of it. It requires only the previously described
filters and smoothers, and generating samples from multivariate
distributions.

\subsubsection{Disturbances}\label{disturbances}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Run a filter and disturbance smoother to calculate
  \(\hat{\vec{\varepsilon}}_{1:n}\) and \(\hat{\vec{\eta}}_{1:(n - 1)}\)
\item
  Draw samples from the unconditional distribution of the disturbances,
  \[
  \begin{aligned}[t]
  \vec{\eta}^+_t &\sim N(0, \mat{H}_t) && t = 1, \dots, n - 1 \\
  \vec{\varepsilon}^+_t &\sim N(0, \mat{Q}_t) && t = 1, \dots, n
  \end{aligned}
  \]
\item
  Simulate observations from the system using the simulated
  disturbances, \[
  \begin{aligned}[t]
  \vec{y}^+_t &= \vec{d}_t + \mat{Z}_t \vec{\alpha}_t + \vec{\varepsilon}^+_t, \\
  \vec{\alpha}_{t + 1} &= \vec{c}_t + \mat{T}_t \vec{\alpha}_t + \mat{R}_t \vec{\eta}^+_t, \\
  \end{aligned}
  \] where \(\vec{\alpha}_1 \sim N(\vec{a}_1, \mat{P}_1)\).
\item
  Run a filter and disturbance smoother on the simulated observations
  \(\vec{y}^+\) to calculate
  \(\hat{\vec{\varepsilon}}_t^+ = \E(\vec{\varepsilon}_t | \vec{y}^+_{1:n})\)
  and \(\hat{\vec{\eta}}_t^+ = \E(\vec{\eta}_t | \vec{y}^+_{1:n})\).
\item
  A sample from
  \(p(\hat{\vec{\eta}}_{1:(n - 1)}, \hat{\vec{\varepsilon}}_{1:n} | \vec{y}_{1:n})\)
  is \[
  \begin{aligned}[t]
  \tilde{\vec{\eta}}_t &= \vec{\eta}^+_t - \hat{\vec{\eta}}^+_t + \hat{\vec{\eta}}_t , \\
  \tilde{\vec{\varepsilon}}_t &= \vec{\varepsilon}^+_t - \hat{\vec{\varepsilon}}^+_t + \hat{\vec{\varepsilon}}_t .
  \end{aligned}
  \]
\end{enumerate}

\subsubsection{States}\label{states}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Run a filter and disturbance smoother to calculate the mean of the
  states conditional on the full series of observations,
  \(\hat{\vec{\alpha}}_{1:n} = \E(\vec{\alpha}_{1:n} | \vec{y}_{1:n})\).
\item
  Draw samples from the unconditional distribution of the disturbances,
  \[
  \begin{aligned}[t]
  \vec{\eta}^+_t &\sim N(0, \mat{H}_t) && t = 1, \dots, n - 1 \\
  \vec{\varepsilon}^+_t &\sim N(0, \mat{Q}_t) && t = 1, \dots, n
  \end{aligned}
  \]
\item
  Simulate states and observations from the system using the simulated
  disturbances, \[
  \begin{aligned}[t]
  \vec{y}^+_t &= \vec{d}_t + \mat{Z}_t \vec{\alpha}_t + \vec{\varepsilon}^+_t, \\
  \vec{\alpha}^+_{t + 1} &= \vec{c}_t + \mat{T}_t \vec{\alpha}_t + \mat{R}_t \vec{\eta}^+_t, \\
  \end{aligned}
  \] where \(\vec{\alpha}^+_1 \sim N(\vec{a}_1, \mat{P}_1)\).
\item
  Run a filter and smoother on the simulated observations \(\vec{y}^+\)
  to calculate
  \(\hat{\vec{\alpha}}_t^+ = \E(\vec{\alpha}_t | \vec{y}^+_{1:n})\).
\item
  A sample from \(p(\hat{\vec{\alpha}}_{1:n} | \vec{y}_{1:n})\) is \[
  \begin{aligned}[t]
  \tilde{\vec{\alpha}}_t &= \vec{\alpha}^+_t - \hat{\vec{\alpha}}^+_t + \hat{\vec{\alpha}}_t .
  \end{aligned}
  \]
\end{enumerate}

One convenient feature of this method is that since only the conditional
means of the states are required, the fast state smoother can be used,
since the variances of the states are not required.

\subsection{de Jong-Shephard method}\label{de-jong-shephard-method}

These recursions were developed in \textcite{DeJongShephard1995} .
Although the the mean-correction simulation smoother will work in most
cases, there are a few in which it will not work.

\textbf{TODO}

\subsection{Forward-filter backwards-smoother
(FFBS)}\label{forward-filter-backwards-smoother-ffbs}

This was the simulation method developed in \textcite{CarterKohn1994}
and \textcite{Fruehwirth-Schnatter1994} .

\textbf{TODO}

\section{Missing observations}\label{missing-observations}

When all observations at time \(t\) are missing, the filtering
recursions become \autocite[Sec 4.10]{DurbinKoopman2012}, \[
\begin{aligned}[t]
\vec{a}_{t|t} &= \vec{a}_t , \\
\mat{P}_{t|t} &= \mat{P}_t , \\
\vec{a}_{t + 1} &= \mat{T}_t \vec{a}_t + \vec{c}_t \\
\mat{P}_{t + 1} &= \mat{T}_t \mat{P}_t \mat{T}_t\T + \mat{R}_t \mat{Q}_t \mat{R}_t\T
\end{aligned}
\] This is equivalent to setting \(\mat{Z}_t = \mat{0}\) (implying also
that \(\mat{K}_t = \mat{0}\)) in the filtering equations. For smoothing,
also replace \(\mat{Z}_t = \mat{0}\), \[
\begin{aligned}[t]
\vec{r}_{t - 1} &= \mat{T}_t\T \vec{r}_t , \\
\mat{N}_{t - 1} &= \mat{T}_t\T \mat{N}_t \mat{T}_t,
\end{aligned}
\]

When some, but not all observations are missing, replace the observation
equation by, \[
\begin{aligned}[t]
\vec{y}^*_t &= \mat{Z}^*_t \vec{\alpha}_t + \vec{\varepsilon}_t^*, & \vec{\varepsilon}_t^* &\sim N(\vec{0}, \mat{H}_t^*),
\end{aligned}
\] where, \[
\begin{aligned}[t]
\vec{y}^*_t &= \mat{W}_t \vec{y}_t, \\
\mat{Z}^* &= \mat{W}_t \mat{Z}_t , \\
\vec{\varepsilon}_t &= \mat{W}_t \vec{\varepsilon}_t , \\
\mat{H}^*_t &= \mat{W}_t \mat{H}_t \mat{W}_t\T ,
\end{aligned}
\] and \(\mat{W}_t\) is a selection matrix to select non-missing values.
In smoothing the missing elements are estimated by the appropriate
elements of \(\mat{Z}_t \hat{\vec{alpha}}_t\), where
\(\hat{\vec{\alpha}}_t\) is the smoothed state.

\textbf{Note} If \(y_{t,j}\) is missing, then setting the relevant
entries in the forecast precision matrix, \(F^{-1}_{t,j,.} = \vec{0}\)
and \(F^{-1}_{t,.,j} = \vec{0}\), and Kalman gain matrix,
\(K_{t,.,j} = \vec{0}\), will handle missing values in the smoothers
without having to pass that information to the smoother. However, it may
be computationally more efficient if the values of the locations of the
missing observations are known.

\textbf{Note} For the disturbance and state simulation smoothers, I
think the missing observations need to be indicated and used when doing
the simulations on the state smoother.

\section{Forecasting matrices}\label{forecasting-matrices}

Forecasting future observations are the same as treating the future
observations as missing \autocite[Sec 4.11]{DurbinKoopman2012}, \[
\begin{aligned}[t]
\bar{\vec{y}}_{n + j} &= \mat{Z}_{n + j} \bar{\vec{a}}_{n + j} \\
\bar{\mat{F}}_{n + j} &= \mat{Z}_{n + j} \bar{\mat{P}}_{n + j} \mat{Z}_{n + j}\T + \mat{H}_{n + j} .
\end{aligned}
\]

\chapter{Stan Functions}\label{stan-functions}

State space functionality for Stan is provided as a set of user-defined
functions.

Add the following line to the Stan model file in which depends on these
functions.

\begin{verbatim}
functions {
  #include ssm.stan
  // other functions ...
}
\end{verbatim}

To actually include the functions in the model, you need to use the
function \texttt{stanc\_builder}, instead of \texttt{stan} or
\texttt{stanc}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{model <-}\StringTok{ }\KeywordTok{stanc_builder}\NormalTok{(}\StringTok{"yourmodel.stan"}\NormalTok{, }\DataTypeTok{isystem =} \StringTok{"path/to/ssm/"}\NormalTok{)}
\KeywordTok{stan}\NormalTok{(}\DataTypeTok{model_code =} \NormalTok{model$model_code)}
\end{Highlighting}
\end{Shaded}

\section{Utility Functions}\label{utility-functions}

\subsection{to\_symmetric\_matrix}\label{toux5fsymmetricux5fmatrix}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{x} \textbf{An} \(n \times n\) matrix.
\end{itemize}

\textbf{Return Value:} \texttt{An} \(n \times n\) symmetric matrix:
\(0.5 (x + x')\).

Ensure a matrix is symmetrix.

\begin{verbatim}
matrix to_symmetric_matrix(matrix x) {
  return 0.5 * (x + x ');
}
\end{verbatim}

\subsection{to\_matrix\_colwise}\label{toux5fmatrixux5fcolwise}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{v} An \(n \times m\) vector.
\item
  \texttt{int} \textbf{m} Number of rows in the vector
\item
  \texttt{int} \textbf{n} Number of columns in the vector
\end{itemize}

\textbf{Return Value:} \texttt{matrix} A \(m \times n\) matrix
containting the elements from \texttt{v}

Convert vector to a matrix (column-major).

\begin{verbatim}
matrix to_matrix_colwise(vector v, int m, int n) {
  matrix[m, n] res;
  for (j in 1:n) {
    for (i in 1:m) {
      res[i, j] = v[(j - 1) * m + m];
    }
  }
  return res;
}
\end{verbatim}

\subsection{to\_matrix\_rowwise}\label{toux5fmatrixux5frowwise}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{v} An \(n \times m\) vector.
\item
  \texttt{int} \textbf{m} Number of rows in the matrix.
\item
  \texttt{int} \textbf{n} Number of columns in the matrix.
\end{itemize}

\textbf{Return Value:} \texttt{matrix} A \(m \times n\) matrix
containting the elements from \texttt{v}

Convert vector to a matrix (row-major).

\begin{verbatim}
matrix to_matrix_rowwise(vector v, int m, int n) {
  matrix[m, n] res;
  for (i in 1:n) {
    for (j in 1:m) {
      res[i, j] = v[(i - 1) * n + n];
    }
  }
  return res;
}
\end{verbatim}

\subsection{to\_vector\_colwise}\label{toux5fvectorux5fcolwise}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{matrix} \textbf{x} An \(n \times m\) matrix.
\end{itemize}

\textbf{Return Value:} \texttt{vector} with \(n m\) elements.

Convert a matrix to a vector (column-major)

\begin{verbatim}
vector to_vector_colwise(matrix x) {
  vector[num_elements(x)] res;
  int n;
  int m;
  n = rows(x);
  m = cols(x);
  for (i in 1:n) {
    for (j in 1:m) {
      res[n * (j - 1) + i] = x[i, j];
    }
  }
  return res;
}
\end{verbatim}

\subsection{to\_vector\_rowwise}\label{toux5fvectorux5frowwise}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{matrix} \textbf{x} An \(n \times m\) matrix.
\end{itemize}

\textbf{Return Value:} \texttt{vector} with \(n m\) elements.

Convert a matrix to a vector (row-major)

\begin{verbatim}
vector to_vector_rowwise(matrix x) {
  vector[num_elements(x)] res;
  int n;
  int m;
  n = rows(x);
  m = cols(x);
  for (i in 1:rows(x)) {
    for (j in 1:cols(x)) {
      res[(i - 1) * m + j] = x[i, j];
    }
  }
  return res;
}
\end{verbatim}

\subsection{symmat\_size}\label{symmatux5fsize}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{matrix} \textbf{x} An \(m \times m\) matrix.
\end{itemize}

\textbf{Return Value:} \texttt{int} The number of unique elements

Calculate the number of unique elements in a symmetric matrix

The number of unique elements in an \(m \times m\) matrix is
\((m \times (m + 1)) / 2\).

\begin{verbatim}
int symmat_size(int n) {
  int sz;
  // This calculates it iteratively because Stan gives a warning
  // with integer division.
  sz = 0;
  for (i in 1:n) {
    sz = sz + i;
  }
  return sz;
}
\end{verbatim}

\subsection{find\_symmat\_dim}\label{findux5fsymmatux5fdim}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{int} \textbf{n} The number of unique elements in a symmetric
  matrix.
\end{itemize}

\textbf{Return Value:} \texttt{int} The dimension of the associated
symmetric matrix.

Given vector with \(n\) elements containing the \(m (m + 1) / 2\)
elements of a symmetric matrix, return \(m\).

\begin{verbatim}
int find_symmat_dim(int n) {
  // This could be solved by finding the positive root of $m = m (m + 1)/2 but
  // Stan doesn't support all the functions necessary to do this.
  int i;
  int remainder;
  i = 0;
  while (n > 0) {
    i = i + 1;
    remainder = remainder - i;
  }
  return i;
}
\end{verbatim}

\subsection{vector\_to\_symmat}\label{vectorux5ftoux5fsymmat}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{x} The vector with the unique elements
\item
  \texttt{int} \textbf{n} The dimensions of the returned matrix:
  \(n \times n\).
\end{itemize}

\textbf{Return Value:} \texttt{matrix} An \(n \times n\) symmetric
matrix.

Convert a vector to a symmetric matrix

\begin{verbatim}
matrix vector_to_symmat(vector x, int n) {
  matrix[n, n] m;
  int k;
  k = 1;
  for (j in 1:n) {
    for (i in 1:j) {
      m[i, j] = x[k];
      if (i != j) {
        m[j, i] = m[i, j];
      }
      k = k + 1;
    }
  }
  return m;
}
\end{verbatim}

\subsection{symmat\_to\_vector}\label{symmatux5ftoux5fvector}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{x} An \(n \times n\) matrix.
\end{itemize}

\textbf{Return Value:} \texttt{vector} A \(n (n + 1) / 2\) vector with
the unique elements in \(x\).

Convert an \(n \times n\) symmetric matrix to a length \(n (n + 1) / 2\)
vector containing its unique elements.

\begin{verbatim}
vector symmat_to_vector(matrix x) {
  vector[symmat_size(rows(x))] v;
  int k;
  k = 1;
  // if x is m x n symmetric, then this will return
  // only parts of an m x m matrix.
  for (j in 1:rows(x)) {
    for (i in 1:j) {
      v[k] = x[i, j];
      k = k + 1;
    }
  }
  return v;
}
\end{verbatim}

\section{Filtering}\label{filtering-1}

Functions used in filtering and log-likelihood calculations.

\subsection{ssm\_filter\_update\_a}\label{ssmux5ffilterux5fupdateux5fa}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{a} An \(m \times 1\) vector with the prected
  state, \(\vec{a}_t\).
\item
  \texttt{vector} \textbf{c} An \(m \times 1\) vector with the system
  intercept, \(\vec{c}_t\)
\item
  \texttt{matrix} \textbf{T} An \(m \times m\) matrix with the
  transition matrix, \(\mat{T}_t\).
\item
  \texttt{vector} \textbf{v} A \(p \times 1\) vector with the forecast
  error, \(\vec{v}_t\).
\item
  \texttt{matrix} \textbf{K} An \(m \times p\) matrix with the Kalman
  gain, \(\mat{K}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{vector} A \(m \times 1\) vector with the
predicted state at \(t + 1\), \(\vec{a}_{t + 1}\).

Update the expected value of the predicted state,
\(\vec{a}_{t + 1} = \E(\vec{\alpha}_{t + 1} | \vec{y}_{1:t})\),

The predicted state \(\vec{a}_{t + 1}\) is, \[
\vec{a}_{t + 1} = \mat{T}_t \vec{a}_t + \mat{K}_t \vec{v}_t + \vec{c}_t .
\]

\begin{verbatim}
vector ssm_filter_update_a(vector a, vector c, matrix T, vector v, matrix K) {
  vector[num_elements(a)] a_new;
  a_new = T * a + K * v + c;
  return a_new;
}
\end{verbatim}

\subsection{ssm\_filter\_update\_P}\label{ssmux5ffilterux5fupdateux5fp}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{matrix} \textbf{P} An \(m \times m\) vector with the variance
  of the prected state, \(\mat{P}_t\).
\item
  \texttt{matrix} \textbf{Z} A \(p \times m\) matrix with the design
  matrix, \(\mat{Z}_t\).
\item
  \texttt{matrix} \textbf{T} An \(m \times m\) matrix with the
  transition matrix, \(\mat{T}_t\).
\item
  \texttt{matrix} \textbf{RQR} A \(m \times m\) matrix with the system
  covariance matrix, \(\mat{R}_t \mat{Q}_t \mat{R}_t'\).
\item
  \texttt{matrix} \textbf{K} An \(m \times p\) matrix with the Kalman
  gain, \(\mat{K}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{matrix} An \(m \times 1\) vector with the
predicted state at \(t + 1\), \(\vec{a}_{t + 1}\).

Update the expected value of the predicted state,
\(\mat{P}_{t + 1} = \Var(\alpha_{t + 1} | \vec{y}_{1:t})\),

The predicted state variance \(\mat{P}_{t + 1}\) is, \[
\mat{P}_{t + 1} = \mat{T}_t \mat{P}_t (\mat{T}_t - \mat{K}_t \mat{Z}_t)' + \mat{R}_t \mat{Q}_t \mat{R}_t' .
\]

\begin{verbatim}
matrix ssm_filter_update_P(matrix P, matrix Z, matrix T,
                           matrix RQR, matrix K) {
  matrix[rows(P), cols(P)] P_new;
  P_new = to_symmetric_matrix(T * P * (T - K * Z)' + RQR);
  return P_new;
}
\end{verbatim}

\subsection{ssm\_filter\_update\_v}\label{ssmux5ffilterux5fupdateux5fv}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{matrix} \textbf{P} An \(m \times m\) vector with the variance
  of the prected state, \(\mat{P}_t\).
\item
  \texttt{matrix} \textbf{Z} A \(p \times m\) matrix with the design
  matrix, \(\mat{Z}_t\).
\item
  \texttt{matrix} \textbf{T} An \(m \times m\) matrix with the
  transition matrix, \(\mat{T}_t\).
\item
  \texttt{matrix} \textbf{RQR} An \(m \times m\) matrix with the system
  covariance matrix, \(\mat{R}_t \mat{Q}_t \mat{R}_t'\).
\item
  \texttt{matrix} \textbf{K} An \(m \times p\) matrix with the Kalman
  gain, \(\mat{K}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{vector} An \(m \times 1\) vector with the
predicted state at \(t + 1\), \(\vec{a}_{t + 1}\).

Update the forcast error,
\(\vec{v}_t = \vec{y}_t - \E(\vec{y}_t | \vec{y_{1:(t - 1)}})\)

The forecast error \(\vec{v}_t\) is \[
\vec{v}_t =\vec{y}_t - \mat{Z}_t \vec{a}_t - \vec{d}_t .
\]

\begin{verbatim}
vector ssm_filter_update_v(vector y, vector a, vector d, matrix Z) {
  vector[num_elements(y)] v;
  v = y - Z * a - d;
  return v;
}
\end{verbatim}

\subsection{ssm\_filter\_update\_F}\label{ssmux5ffilterux5fupdateux5ff}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{matrix} \textbf{P} An \(m \times m\) vector with the variance
  of the prected state, \(\mat{P}_t\).
\item
  \texttt{matrix} \textbf{Z} A \(p \times m\) matrix with the design
  matrix, \(\mat{Z}_t\).
\item
  \texttt{matrix} \textbf{H} A \(p \times p\) matrix with the
  observation covariance matrix, \(\mat{H}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{matrix} A \(p \times p\) vector with
\(\mat{F}_t\).

Update the variance of the forcast error,
\(\mat{F}_t = \Var(\vec{y}_t - \E(\vec{y}_t | \vec{y_{1:(t - 1)}}))\)

The variance of the forecast error \(\mat{F}_t\) is \[
\mat{F}_t = \mat{Z}_t \mat{P}_t \mat{Z}_t + \mat{H}_t .
\]

\begin{verbatim}
matrix ssm_filter_update_F(matrix P, matrix Z, matrix H) {
  matrix[rows(H), cols(H)] F;
  F = quad_form(P, Z') + H;
  return F;
}
\end{verbatim}

\subsection{ssm\_filter\_update\_Finv}\label{ssmux5ffilterux5fupdateux5ffinv}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{matrix} \textbf{P} An \(m \times m\) vector with the variance
  of the prected state, \(\mat{P}_t\).
\item
  \texttt{matrix} \textbf{Z} A \(p \times m\) matrix with the design
  matrix, \(\mat{Z}_t\).
\item
  \texttt{matrix} \textbf{H} A \(p \times p\) matrix with the
  observation covariance matrix, \(\mat{H}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{matrix} A \(p \times p\) vector with
\(\mat{F}^{-1}_t\).

Update the precision of the forcast error,
\(\mat{F}^{-1}_t = \Var(\vec{y}_t - \E(\vec{y}_t | \vec{y_{1:(t - 1)}}))^{-1}\)

This is the inverse of \(\mat{F}_t\).

\begin{verbatim}
matrix ssm_filter_update_Finv(matrix P, matrix Z, matrix H) {
  matrix[rows(H), cols(H)] Finv;
  Finv = inverse(ssm_filter_update_F(P, Z, H));
  return Finv;
}
\end{verbatim}

\subsection{ssm\_filter\_update\_K}\label{ssmux5ffilterux5fupdateux5fk}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{matrix} \textbf{P} An \(m \times m\) vector with the variance
  of the prected state, \(P_t\).
\item
  \texttt{matrix} \textbf{Z} A \(p \times m\) matrix with the design
  matrix, \(\mat{Z}_t\).
\item
  \texttt{matrix} \textbf{T} An \(m \times m\) matrix with the
  transition matrix, \(\mat{T}_t\).
\item
  \texttt{matrix} \textbf{Finv} A \(p \times p\) matrix
\end{itemize}

\textbf{Return Value:} \texttt{matrix} An \(m \times p\) matrix with the
Kalman gain, \(\mat{K}_t\).

Update the Kalman gain, \(\mat{K}_t\).

The Kalman gain is \[
\mat{K}_t = \mat{T}_t \mat{P}_t \mat{Z}_t' \mat{F}^{-1}_t .
\]

\begin{verbatim}
matrix ssm_filter_update_K(matrix P, matrix Z, matrix T, matrix Finv) {
  matrix[cols(Z), rows(Z)] K;
  K = T * P * Z' * Finv;
  return K;
}
\end{verbatim}

\subsection{ssm\_filter\_update\_L}\label{ssmux5ffilterux5fupdateux5fl}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{matrix} \textbf{Z} A \(p \times m\) matrix with the design
  matrix, \(\mat{Z}_t\)
\item
  \texttt{matrix} \textbf{T} An \(m \times m\) matrix with the
  transition matrix, \(\mat{T}_t\).
\item
  \texttt{matrix} \textbf{K} An \(m \times p\) matrix with the Kalman
  gain, \(\mat{K}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{matrix} An \(m \times m\) matrix,
\(\mat{L}_t\).

Update \(L_t\)

\[
\mat{L}_t = \mat{T}_t - \mat{K}_t \mat{Z}_t .
\]

\begin{verbatim}
matrix ssm_filter_update_L(matrix Z, matrix T, matrix K) {
  matrix[rows(T), cols(T)] L;
  L = T - K * Z;
  return L;
}
\end{verbatim}

\subsection{ssm\_filter\_update\_ll}\label{ssmux5ffilterux5fupdateux5fll}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{v} A \(p \times 1\) matrix with the forecast
  error, \(\vec{v}_t\).
\item
  \texttt{matrix} \textbf{Finv} A \(p \times p\) matrix with variance of
  the forecast error, \(\mat{F}^{-1}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{real} An \(m \times m\) matrix, \(L_t\).

Calculate the log-likelihood for a period

The log-likehood of a single observation in a state-space model is \[
\ell_t = - \frac{1}{2} p \log(2 \pi) - \frac{1}{2} \left(\log|\mat{F}_t| + \vec{v}_t' \mat{F}^{-1}_t \vec{v}_t  \right)
\]

\begin{verbatim}
real ssm_filter_update_ll(vector v, matrix Finv) {
  real ll;
  int p;
  p = num_elements(v);
  // det(A^{-1}) = 1 / det(A) -> log det(A^{-1}) = - log det(A)
  ll = (- 0.5 *
        (p * log(2 * pi())
         - log_determinant(Finv)
         + quad_form(Finv, v)
       ));
  return ll;
}
\end{verbatim}

\section{Filtering}\label{filtering-2}

\subsection{ssm\_filter\_idx}\label{ssmux5ffilterux5fidx}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{int} \textbf{m} The number of states
\item
  \texttt{int} \textbf{p} The size of the observation vector
  \(\vec{y}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{int{[},{]}} A \(6 \times 3\) integer
array containing the indexes of the return values of the Kalman filter.

Indexes of the return values of the Kalman filter functions:
\texttt{ssm\_filter}.

\texttt{ssm\_filter\_idx} returns a \(6 \times 3\) integer array with
the (length, start index, stop index) of (\(\ell_t\), \(\vec{v}\),
\(\vec{F}^-1\), \(\mat{K}\), \(\vec{a}\), \(\mat{P}\)).

\begin{longtable}[c]{@{}llll@{}}
\toprule
value & length & start & stop\tabularnewline
\midrule
\endhead
\(\ell_t\) & \(1\) & \(1\) & \(1\)\tabularnewline
\(\vec{v}\) & \(p\) & \(2\) & \(1 + p\)\tabularnewline
\(\mat{F}^{-1}\) & \(p (p + 1) / 2\) & \(2 + p\) &
\(1 + p + p (p + 1) / 2\)\tabularnewline
\(\mat{K}\) & \(mp\) & \(2 + p + p (p + 1) / 2\) &
\(1 + p + p (p + 1) / 2 + mp\)\tabularnewline
\(\vec{a}_t\) & \(m\) & \(2 + p + p (p + 1) / 2 + mp\) &
\(1 + p + p (p + 1) / 2 + mp + m\)\tabularnewline
\(\mat{P}^t\) & \(m (m + 1) / 2\) & \(2 + p + p (p + 1) / 2 + mp + m\) &
\(1 + p + p (p + 1) / 2 + mp + m (m + 1) / 2\)\tabularnewline
\bottomrule
\end{longtable}

\begin{verbatim}
int[,] ssm_filter_idx(int m, int p) {
  int sz[6, 3];
  // loglike
  sz[1, 1] = 1;
  // v
  sz[2, 1] = p;
  // Finv
  sz[3, 1] = symmat_size(p);
  // K
  sz[4, 1] = m * p;
  // a
  sz[5, 1] = m;
  // P
  sz[6, 1] = symmat_size(m);
  // Fill in start and stop points
  sz[1, 2] = 1;
  sz[1, 3] = sz[1, 2] + sz[1, 1] - 1;
  for (i in 2:6) {
    sz[i, 2] = sz[i - 1, 3] + 1;
    sz[i, 3] = sz[i, 2] + sz[i, 1] - 1;
  }
  return sz;
}
\end{verbatim}

\subsection{ssm\_filter\_size}\label{ssmux5ffilterux5fsize}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{int} \textbf{m} The number of states
\item
  \texttt{int} \textbf{p} The size of the observation vector
  \(\vec{y}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{int} The number of elements in the
vector.

Number of elements in vector containing filter results

\begin{verbatim}
int ssm_filter_size(int m, int p) {
  int sz;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  sz = idx[6, 3];
  return sz;
}
\end{verbatim}

\subsection{ssm\_filter\_get\_loglik}\label{ssmux5ffilterux5fgetux5floglik}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{A} vector with results from
  \texttt{ssm\_filter}.
\item
  \texttt{int} \textbf{m} The number of states
\item
  \texttt{int} \textbf{p} The size of the observation vector
  \(\vec{y}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{real} The log-likelihood \(\ell_t\)

Get the log-likehood from the results of \texttt{ssm\_filter}.

\begin{verbatim}
real ssm_filter_get_loglik(vector x, int m, int p) {
  real y;
  y = x[1];
  return y;
}
\end{verbatim}

\subsection{ssm\_filter\_get\_v}\label{ssmux5ffilterux5fgetux5fv}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{A} vector with results from
  \texttt{ssm\_filter}.
\item
  \texttt{int} \textbf{m} The number of states
\item
  \texttt{int} \textbf{p} The size of the observation vector
  \(\vec{y}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{vector} A \(p \times 1\) vector with the
forecast error, \(\vec{v}_t\).

Get the forecast error from the results of \texttt{ssm\_filter}.

\begin{verbatim}
vector ssm_filter_get_v(vector x, int m, int p) {
  vector[p] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = segment(x, idx[2, 2], idx[2, 3]);
  return y;
}
\end{verbatim}

\subsection{ssm\_filter\_get\_Finv}\label{ssmux5ffilterux5fgetux5ffinv}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{A} vector with results from
  \texttt{ssm\_filter}.
\item
  \texttt{int} \textbf{m} The number of states
\item
  \texttt{int} \textbf{p} The size of the observation vector
  \(\vec{y}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{matrix} A \(p \times p\) matrix with the
forecast precision, \(\mat{F}^{-1}_t\).

Get the forecast precision from the results of \texttt{ssm\_filter}.

\begin{verbatim}
matrix ssm_filter_get_Finv(vector x, int m, int p) {
  matrix[p, p] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = vector_to_symmat(segment(x, idx[3, 2], idx[3, 3]), p);
  return y;
}
\end{verbatim}

\subsection{ssm\_filter\_get\_K}\label{ssmux5ffilterux5fgetux5fk}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{A} vector with results from
  \texttt{ssm\_filter}.
\item
  \texttt{int} \textbf{m} The number of states
\item
  \texttt{int} \textbf{p} The size of the observation vector
  \(\vec{y}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{matrix} A \(m \times p\) matrix with the
Kalman gain, \(\mat{F}^{-1}_t\).

Get the Kalman gain from the results of \texttt{ssm\_filter}.

\begin{verbatim}
matrix ssm_filter_get_K(vector x, int m, int p) {
  matrix[m, p] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = to_matrix_colwise(segment(x, idx[4, 2], idx[4, 3]), m, p);
  return y;
}
\end{verbatim}

\subsection{ssm\_filter\_get\_a}\label{ssmux5ffilterux5fgetux5fa}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{A} vector with results from
  \texttt{ssm\_filter}.
\item
  \texttt{int} \textbf{m} The number of states
\item
  \texttt{int} \textbf{p} The size of the observation vector
  \(\vec{y}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{vector} An \(m \times 1\) vector with the
expected value of the predicted state,
\(\E(\vec{\alpha}_t | \vec{y}_{1:(t-1)}) = \vec{a}_t\).

Get the expected value of the predicted state from the results of
\texttt{ssm\_filter}.

\begin{verbatim}
vector ssm_filter_get_a(vector x, int m, int p) {
  vector[m] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = segment(x, idx[5, 2], idx[5, 3]);
  return y;
}
\end{verbatim}

\subsection{ssm\_filter\_get\_P}\label{ssmux5ffilterux5fgetux5fp}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{A} vector with results from
  \texttt{ssm\_filter}.
\item
  \texttt{int} \textbf{m} The number of states
\item
  \texttt{int} \textbf{p} The size of the observation vector
  \(\vec{y}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{matrix} An \(m \times m\) matrix with the
variance of the predicted state,
\(\Var(\vec{\alpha}_t | \vec{y}_{1:(t-1)}) = \mat{P}_t\).

Get the variance of the predicted state from the results of
\texttt{ssm\_filter}.

\begin{verbatim}
matrix ssm_filter_get_P(vector x, int m, int p) {
  matrix[m, m] y;
  int idx[6, 3];
  idx = ssm_filter_idx(m, p);
  y = vector_to_symmat(segment(x, idx[6, 2], idx[6, 3]), m);
  return y;
}
\end{verbatim}

\subsection{ssm\_filter}\label{ssmux5ffilter}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector{[}{]}} \textbf{y} Observations, \(\vec{y}_t\). An array
  of size \(n\) of \(p \times 1\) vectors.
\item
  \texttt{vector{[}{]}} \textbf{d} Observation intercept, \(\vec{d}_t\).
  An array of \(p \times 1\) vectors.
\item
  \texttt{matrix{[}{]}} \textbf{Z} Design matrix, \(\mat{Z}_t\). An
  array of \(p \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{H} Observation covariance matrix,
  \(\mat{H}_t\). An array of \(p \times p\) matrices.
\item
  \texttt{vector{[}{]}} \textbf{c} State intercept, \(\vec{c}_t\). An
  array of \(m \times 1\) vectors.
\item
  \texttt{matrix{[}{]}} \textbf{T} Transition matrix, \(\mat{T}_t\). An
  array of \(m \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{R} State covariance selection matrix,
  \(\mat{R} _t\). An array of \(p \times q\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{Q} State covariance matrix,
  \(\mat{Q}_t\). An array of \(q \times q\) matrices.
\item
  \texttt{vector} \textbf{a1} Expected value of the intial state,
  \(a_1 = \E(\alpha_1)\). An \(m \times 1\) matrix.
\item
  \texttt{matrix} \textbf{P1} Variance of the initial state,
  \(P_1 = \Var(\alpha_1)\). An \(m \times m\) matrix.
\end{itemize}

\textbf{Return Value:} \texttt{vector{[}{]}} Array of size \(n\) of
\((1 + p + p (p + 1) / 2 + mp + m + m (m + 1) / 2) \times 1\) vectors in
the format described in \texttt{ssm\_filter\_idx}.

Kalman filter

For \texttt{d}, \texttt{Z}, \texttt{H}, \texttt{c}, \texttt{T},
\texttt{R}, \texttt{Q} the array can have a size of 1, if it is not
time-varying, or a size of \(n\) (for \texttt{d}, \texttt{Z},
\texttt{H}) or \(n - 1\) (for \texttt{c}, \texttt{T}, \texttt{R},
\texttt{Q}) if it is time varying.

\texttt{ssm\_filter} runs a forward filter on the state space model and
calculates,

\begin{itemize}
\tightlist
\item
  log-likelihood for each observation, \(\ell_t\).
\item
  Forecast error,
  \(\vec{v}_t = \vec{y}_t - \E(\vec{y}_t | \vec{y}_{1:(t -1)})\).
\item
  Forecast precision, \(\mat{F}^{-1}_t\).
\item
  Kalman gain, \(\mat{K}_t\).
\item
  Predicted states,
  \(\vec{a}_t = \E(\vec{\alpha}_t | \vec{y}_{1:(t -1)})\).
\item
  Variance of the predicted states,
  \(\mat{P}_t = \Var(\vec{\alpha}_t | \vec{y}_{1:(t -1)})\).
\end{itemize}

The results of Kalman filter for a given are returned as a
\(1 + p + p (p + 1) / 2 + m p + m (m + 1) / 2\) vector for each time
period, where \[
(\ell_t, \vec{v}_t', \VEC(\mat{F}^{-1}_t)', \VEC(\mat{K}_t)', \vec{a}_t', \VEC(\mat{P}_t)' )'.
\]

\begin{verbatim}
vector[] ssm_filter(vector[] y,
                    vector[] d, matrix[] Z, matrix[] H,
                    vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                    vector a1, matrix P1) {

  // returned data
  vector[ssm_filter_size(dims(Z)[3], dims(Z)[2])] res[size(y)];
  int q;
  int n;
  int p;
  int m;

  // sizes
  n = size(y); // number of obs
  p = dims(Z)[2]; // obs size
  m = dims(Z)[3]; // number of states
  q = dims(Q)[2]; // number of state disturbances

  //print("Sizes: n = ", m, ", p = ", n, ", m = ", m, ", q = ", q);
  {
    // system matrices for current iteration
    vector[p] d_t;
    matrix[p, m] Z_t;
    matrix[p, p] H_t;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // result matricees for each iteration
    vector[m] a;
    matrix[m, m] P;
    vector[p] v;
    matrix[p, p] Finv;
    matrix[m, p] K;
    real ll;
    int idx[6, 3];

    idx = ssm_filter_idx(m, p);

    d_t = d[1];
    Z_t = Z[1];
    H_t = H[1];
    c_t = c[1];
    T_t = T[1];
    R_t = R[1];
    Q_t = Q[1];
    RQR = quad_form(Q_t, R_t);
    a = a1;
    P = P1;
    for (t in 1:n) {
      if (t > 1) {
        if (size(d) > 1) {
          d_t = d[t];
        }
        if (size(Z) > 1) {
          Z_t = Z[t];
        }
        if (size(H) > 1) {
          H_t = H[t];
        }
        if (size(c) > 1) {
          c_t = c[t];
        }
        if (size(T) > 1) {
          T_t = T[t];
        }
        if (size(R) > 1) {
          R_t = R[t];
        }
        if (size(Q) > 1) {
          Q_t = Q[t];
        }
        if (size(R) > 1 && size(Q) > 1) {
          RQR = quad_form(Q_t, R_t);
        }
      }
      // updating
      v = ssm_filter_update_v(y[t], a, d_t, Z_t);
      Finv = ssm_filter_update_Finv(P, Z_t, H_t);
      K = ssm_filter_update_K(P, T_t, Z_t, Finv);
      ll = ssm_filter_update_ll(v, Finv);
      // saving
      res[t, 1] = ll;
      res[t, idx[2, 2]:idx[2, 3]] = v;
      res[t, idx[3, 2]:idx[3, 3]] = symmat_to_vector(Finv);
      res[t, idx[4, 2]:idx[4, 3]] = to_vector(K);
      res[t, idx[5, 2]:idx[5, 3]] = a;
      res[t, idx[6, 2]:idx[6, 3]] = symmat_to_vector(P);
      // predict a_{t + 1}, P_{t + 1}
      if (t < n) {
        a = ssm_filter_update_a(a, c_t, T_t, v, K);
        P = ssm_filter_update_P(P, Z_t, T_t, RQR, K);
      }
    }
  }
  return res;
}
\end{verbatim}

\subsection{ssm\_filter\_states}\label{ssmux5ffilterux5fstates}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{int} \textbf{m} Number of states
\end{itemize}

\textbf{Return Value:} \texttt{int} The size of the vector

Length of the vectors returned by \texttt{ssm\_filter\_states}

\begin{verbatim}
int ssm_filter_states_size(int m) {
  int sz;
  sz = m + symmat_size(m);
  return sz;
}
\end{verbatim}

\subsection{ssm\_filter\_states\_get\_a}\label{ssmux5ffilterux5fstatesux5fgetux5fa}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{x} A vector returned by
  \texttt{ssm\_filter\_states}
\item
  \texttt{int} \textbf{m} Number of states
\end{itemize}

\textbf{Return Value:} \texttt{matrix} An \(m \times 1\) vector with the
filtered expected value of the state,
\(\vec{a}_{t|t} = \E(\vec{\alpha}_t | \vec{y}_{1:t})\).

Extract \(a_{t|t}\) from the results of \texttt{ssm\_filter\_states}

\begin{verbatim}
vector ssm_filter_states_get_a(vector x, int m) {
  vector[m] a;
  a = x[ :m];
  return a;
}
\end{verbatim}

\subsection{ssm\_filter\_states\_get\_P}\label{ssmux5ffilterux5fstatesux5fgetux5fp}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{x} A vector returned by
  \texttt{ssm\_filter\_states}
\item
  \texttt{int} \textbf{m} Number of states
\end{itemize}

\textbf{Return Value:} \texttt{matrix} An \(m \times m\) matrix with the
filtered variance of the state,
\(\mat{P}_{t|t} = \Var(\vec{\alpha}_t | \vec{y}_{1:t})\).

Extract \(P_{t|t}\) from the results of \texttt{ssm\_filter\_states}

\begin{verbatim}
matrix ssm_filter_states_get_P(vector x, int m) {
  matrix[m, m] P;
  P = vector_to_symmat(x[(m + 1): ], m);
  return P;
}
\end{verbatim}

\subsection{ssm\_filter\_states}\label{ssmux5ffilterux5fstates-1}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector{[}{]}} \textbf{filter} Results from
  \texttt{ssm\_filter}
\item
  \texttt{matrix{[}{]}} \textbf{Z} Design matrix, \(\mat{Z}_t\). An
  array of \(p \times m\) matrices.
\end{itemize}

\textbf{Return Value:} \texttt{Array} of size \(n\) of vectors.

Calculate filtered expected values and variances of the states

The filtering function \texttt{ssm\_filter} returns the mean and
variance of the predicted states,
\(\vec{a}_t = \E(\vec{\alpha}_t | \vec{y}_{1:(t -1)})\) and
\(\mat{P}_t = \Var(\vec{\alpha}_t | \vec{y}_{1:(t -1)})\).

The vectors returned by \texttt{ssm\_filter\_states} are of length
\(m + m ^ 2\), with \[
\vec{v}_t = (\vec{a}_{t|t}', \VEC(\vec{P}_{t|t})' )'
\] Use the functions \texttt{ssm\_filter\_states\_get\_a} and
\texttt{ssm\_filter\_states\_get\_P} to extract elements from the
results.

For \texttt{Z} the array can have a size of 1, if it is not
time-varying, or a size of \(n - 1\) if it is time varying.

\begin{verbatim}
vector[] ssm_filter_states(vector[] filter, matrix[] Z) {
  vector[ssm_filter_states_size(dims(Z)[3])] res[size(filter)];
  int n;
  int m;
  int p;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  {
    // system matrices for current iteration
    matrix[p, m] Z_t;
    // filter matrices
    vector[m] aa; // filtered values of the state, a_{t|t}
    matrix[m, m] PP; // filtered values of the variance of the state, P_{t|t}
    vector[p] v;
    matrix[p, p] Finv;
    vector[m] a;
    matrix[m, m] P;

    Z_t = Z[1];
    for (t in 1:n) {
      if (t > 1) {
        if (size(Z) > 1) {
          Z_t = Z[t];
        }
      }
      // extract values from the filter
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      a = ssm_filter_get_a(filter[t], m, p);
      P = ssm_filter_get_P(filter[t], m, p);
      // calcualte filtered values
      aa = a + P * Z_t ' * Finv * v;
      PP = to_symmetric_matrix(P - P * quad_form(Finv, Z_t) * P);
      // saving
      res[t, :m] = aa;
      res[t, (m + 1): ] = symmat_to_vector(PP);
    }
  }
  return res;
}
\end{verbatim}

\section{Log-likelihood}\label{log-likelihood}

\subsection{ssm\_lpdf}\label{ssmux5flpdf}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector{[}{]}} \textbf{y} Observations, \(\vec{y}_t\). An array
  of size \(n\) of \(p \times 1\) vectors.
\item
  \texttt{vector{[}{]}} \textbf{d} Observation intercept, \(\vec{d}_t\).
  An array of \(p \times 1\) vectors.
\item
  \texttt{matrix{[}{]}} \textbf{Z} Design matrix, \(\mat{Z}_t\). An
  array of \(p \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{H} Observation covariance matrix,
  \(\mat{H}_t\). An array of \(p \times p\) matrices.
\item
  \texttt{vector{[}{]}} \textbf{c} State intercept, \(\vec{c}_t\). An
  array of \(m \times 1\) vectors.
\item
  \texttt{matrix{[}{]}} \textbf{T} Transition matrix, \(\mat{T}_t\). An
  array of \(m \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{R} State covariance selection matrix,
  \(\mat{R} _t\). An array of \(p \times q\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{Q} State covariance matrix,
  \(\mat{Q}_t\). An array of \(q \times q\) matrices.
\item
  \texttt{vector} \textbf{a1} Expected value of the intial state,
  \(a_1 = \E(\alpha_1)\). An \(m \times 1\) matrix.
\item
  \texttt{matrix} \textbf{P1} Variance of the initial state,
  \(P_1 = \Var(\alpha_1)\). An \(m \times m\) matrix.
\end{itemize}

\textbf{Return Value:} \texttt{real} The log-likelihood,
\(p(\vec{y}_{1:n} | \vec{d}, \mat{Z}, \mat{H}, \vec{c}, \mat{T}, \mat{R}, \mat{Q})\),
marginalized over the latent states.

Log-likelihood of a Linear Gaussian State Space Model

For \texttt{d}, \texttt{Z}, \texttt{H}, \texttt{c}, \texttt{T},
\texttt{R}, \texttt{Q} the array can have a size of 1, if it is not
time-varying, or a size of \(n\) (for \texttt{d}, \texttt{Z},
\texttt{H}) or \(n - 1\) (for \texttt{c}, \texttt{T}, \texttt{R},
\texttt{Q}) if it is time varying.

The log-likelihood of a linear Gaussian state space model is, If the the
system matrices and initial conditions are known, the log likelihood is
\[
\begin{aligned}[t]
\log L(\mat{Y}_n) &= \log p(\vec{y}_1, \dots, \vec{y}_n) = \sum_{t = 1}^n \log p(\vec{y}_t | \mat{Y}_{t - 1}) \\
&= - \frac{np}{2} \log 2 \pi - \frac{1}{2} \sum_{t = 1}^n \left( \log \left| \mat{F}_t \right| + \vec{v}\T \mat{F}_t^{-1} \vec{v}_t \right)
\end{aligned} ,
\] where \(\mat{F}_t\) and \(\mat{V}_t\) come from a forward pass of the
Kalman filter.

\begin{verbatim}
real ssm_lpdf(vector[] y,
               vector[] d, matrix[] Z, matrix[] H,
               vector[] c, matrix[] T, matrix[] R, matrix[] Q,
               vector a1, matrix P1) {
  real ll;
  int n;
  int m;
  int p;
  int q;
  n = size(y); // number of obs
  m = dims(Z)[2];
  p = dims(Z)[3];
  q = dims(Q)[2];
  {
    // system matrices for current iteration
    vector[p] d_t;
    matrix[p, m] Z_t;
    matrix[p, p] H_t;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // result matricees for each iteration
    vector[n] ll_obs;
    vector[m] a;
    matrix[m, m] P;
    vector[p] v;
    matrix[p, p] Finv;
    matrix[m, p] K;

    d_t = d[1];
    Z_t = Z[1];
    H_t = H[1];
    c_t = c[1];
    T_t = T[1];
    R_t = R[1];
    Q_t = Q[1];
    RQR = quad_form(Q_t, R_t);

    a = a1;
    P = P1;
    for (t in 1:n) {
      if (t > 1) {
        if (size(d) > 1) {
          d_t = d[t];
        }
        if (size(Z) > 1) {
          Z_t = Z[t];
        }
        if (size(H) > 1) {
          H_t = H[t];
        }
        if (size(c) > 1) {
          c_t = c[t];
        }
        if (size(T) > 1) {
          T_t = T[t];
        }
        if (size(R) > 1) {
          R_t = R[t];
        }
        if (size(Q) > 1) {
          Q_t = Q[t];
        }
        if (size(R) > 1 && size(Q) > 1) {
          RQR = quad_form(Q_t, R_t);
        }
      }
      v = ssm_filter_update_v(y[t], a, d_t, Z_t);
      Finv = ssm_filter_update_Finv(P, Z_t, H_t);
      K = ssm_filter_update_K(P, Z_t, T_t, Finv);
      ll_obs[t] = ssm_filter_update_ll(v, Finv);
      // don't save a, P for last iteration
      if (t < n) {
        a = ssm_filter_update_a(a, c_t, T_t, v, K);
        P = ssm_filter_update_P(P, Z_t, T_t, RQR, K);
      }
    }
    ll = sum(ll_obs);
  }
  return ll;
}
\end{verbatim}

\section{Time-Invariant Kalman
Filter}\label{time-invariant-kalman-filter}

\subsection{ssm\_check\_matrix\_equal}\label{ssmux5fcheckux5fmatrixux5fequal}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{matrix} \textbf{A} An \(m \times n\) matrix.
\item
  \texttt{matrix} \textbf{B} An \(m \times n\) matrix.
\item
  \texttt{real} \textbf{The} relative tolerance for convergence.
\end{itemize}

\textbf{Return Value:} \texttt{int} If converged, then 1, else 0.

Check if two matrices are approximately equal

The matrices \(A\) and \(B\) are considered approximately equal if \[
\max(A - B) / \max(A) < \epsilon,
\] where \(\epsilon\) is the tolerance.

\begin{verbatim}
int ssm_check_matrix_equal(matrix A, matrix B, real tol) {
  real eps;
  eps = max(to_vector(A - B)) / max(to_vector(A));
  if (eps < tol) {
    return 1;
  } else {
    return 0;
  }
}
\end{verbatim}

\subsection{ssm\_constant\_lpdf}\label{ssmux5fconstantux5flpdf}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector{[}{]}} \textbf{y} Observations, \(\vec{y}_t\). An array
  of size \(n\) of \(p \times 1\) vectors.
\item
  \texttt{vector} \textbf{d} Observation intercept, \(\vec{d}_t\). An
  array of \(p \times 1\) vectors.
\item
  \texttt{matrix} \textbf{Z} Design matrix, \(\mat{Z}_t\). An array of
  \(p \times m\) matrices.
\item
  \texttt{matrix} \textbf{H} Observation covariance matrix,
  \(\mat{H}_t\). An array of \(p \times p\) matrices.
\item
  \texttt{vector} \textbf{c} State intercept, \(\vec{c}_t\). An array of
  \(m \times 1\) vectors.
\item
  \texttt{matrix} \textbf{T} Transition matrix, \(\mat{T}_t\). An array
  of \(m \times m\) matrices.
\item
  \texttt{matrix} \textbf{R} State covariance selection matrix,
  \(\mat{R} _t\). An array of \(p \times q\) matrices.
\item
  \texttt{matrix} \textbf{Q} State covariance matrix, \(\mat{Q}_t\). An
  array of \(q \times q\) matrices.
\item
  \texttt{vector} \textbf{a1} Expected value of the intial state,
  \(a_1 = \E(\alpha_1)\). An \(m \times 1\) matrix.
\item
  \texttt{matrix} \textbf{P1} Variance of the initial state,
  \(P_1 = \Var(\alpha_1)\). An \(m \times m\) matrix.
\end{itemize}

\textbf{Return Value:} \texttt{real} The log-likelihood,
\(p(\vec{y}_{1:n} | \vec{d}, \mat{Z}, \mat{H}, \vec{c}, \mat{T}, \mat{R}, \mat{Q})\),
marginalized over the latent states.

Log-likelihood of a Time-Invariant Linear Gaussian State Space Model

Unlike \texttt{ssm\_filter}, this function requires the system matrices
(\texttt{d}, \texttt{Z}, \texttt{H}, \texttt{c}, \texttt{T}, \texttt{R},
\texttt{Q}) to all be time invariant (constant). When the state space
model is time-invariant, then the Kalman recursion for \(\mat{P}_t\)
converges. This function takes advantage of this feature and stops
updating \(\mat{P}_t\) after it converges to a steady state.

\begin{verbatim}
real ssm_constant_lpdf(vector[] y,
                      vector d, matrix Z, matrix H,
                      vector c, matrix T, matrix R, matrix Q,
                      vector a1, matrix P1) {
  real ll;
  int n;
  int m;
  int p;

  n = size(y); // number of obs
  m = cols(Z);
  p = rows(Z);
  {
    vector[n] ll_obs;
    vector[m] a;
    matrix[m, m] P;
    vector[p] v;
    matrix[p, p] Finv;
    matrix[m, p] K;
    matrix[m, m] RQR;
    // indicator for if the filter has converged
    // This only works for time-invariant state space models
    int converged;
    matrix[m, m] P_old;
    real tol;
    converged = 0;
    tol = 1e-7;

    RQR = quad_form(Q, R);
    a = a1;
    P = P1;
    for (t in 1:n) {
      v = ssm_filter_update_v(y[t], a, d, Z);
      if (converged < 1) {
        Finv = ssm_filter_update_Finv(P, Z, H);
        K = ssm_filter_update_K(P, Z, T, Finv);
      }
      ll_obs[t] = ssm_filter_update_ll(v, Finv);
      // don't save a, P for last iteration
      if (t < n) {
        a = ssm_filter_update_a(a, c, T, v, K);
        // check for convergence
        // should only check for convergence if there are no missing values
        if (converged < 1) {
          P_old = P;
          P = ssm_filter_update_P(P, Z, T, RQR, K);
          converged = ssm_check_matrix_equal(P, P_old, tol);
        }
      }
    }
    ll = sum(ll_obs);
  }
  return ll;
}


\end{verbatim}

\section{Common Smoother Functions}\label{common-smoother-functions}

\subsection{ssm\_smooth\_update\_r}\label{ssmux5fsmoothux5fupdateux5fr}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{r} An \(m \times 1\) vector with
  \(\vec{r}_{t-1}\)
\item
  \texttt{matrix} \textbf{Z} A \(p \times m\) vector with
  \(\mat{Z}_{t}\)
\item
  \texttt{vector} \textbf{v} A \(p \times 1\) vector of the forecast
  errors, \(\vec{v}_t\).
\item
  \texttt{matrix} \textbf{Finv} A \(p \times p\) matrix of the forecast
  precision, \(\mat{F}^{-1}_t\).
\item
  \texttt{matrix} \textbf{L} An \(m \times m\) matrix with
  \(\mat{L}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{matrix} An \(m \times 1\) vector with
\(\vec{r}_t\).

Update \(\vec{r}_t\) in smoothing recursions

In smoothing recursions, the vector \(\vec{r}_t\) is updated with, \[
\vec{r}_{t - 1} = \mat{Z}' \mat{F}^{-1}_t \vec{v}_t + \mat{L}' \vec{r}_{t} .
\]

See \autocite[p.~91]{DurbinKoopman2012}

\begin{verbatim}
vector ssm_smooth_update_r(vector r, matrix Z, vector v, matrix Finv,
                           matrix L) {
  vector[num_elements(r)] r_new;
  r_new = Z ' * Finv * v + L ' * r;
  return r_new;
}
\end{verbatim}

\subsection{ssm\_smooth\_update\_N}\label{ssmux5fsmoothux5fupdateux5fn}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{N} An \(m \times 1\) vector with
  \(\vec{N}_{t-1}\)
\item
  \texttt{matrix} \textbf{Z} A \(p \times m\) vector with
  \(\mat{Z}_{t}\)
\item
  \texttt{matrix} \textbf{Finv} A \(p \times p\) matrix of the forecast
  precision, \(\mat{F}^{-1}_t\).
\item
  \texttt{matrix} \textbf{L} An \(m \times m\) matrix with
  \(\mat{L}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{matrix} An \(m \times m\) matrix with
\(\vec{N}_t\).

Update \(\mat{N}_t\) in smoothing recursions

In smoothing recursions, the matrix \(\vec{N}_t\) is updated with, \[
\mat{N}_{t - 1} = \mat{Z}_t' \mat{F}^{-1}_t \mat{Z}_t + \mat{L}_t' \mat{N}_t \mat{L}_t .
\]

See \autocite[p.~91]{DurbinKoopman2012}

\begin{verbatim}
matrix ssm_smooth_update_N(matrix N, matrix Z, matrix Finv, matrix L) {
  matrix[rows(N), cols(N)] N_new;
  N_new = quad_form(Finv, Z) + quad_form(N, L);
  return N_new;
}

\end{verbatim}

\subsection{ssm\_smooth\_state\_size}\label{ssmux5fsmoothux5fstateux5fsize}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{int} \textbf{m} The number of states.
\end{itemize}

\textbf{Return Value:} \texttt{int} The size of the vectors is
\(m + m (m + 1) / 2\).

The number of elements in vectors returned by
\texttt{ssm\_smooth\_state}

\begin{verbatim}
int ssm_smooth_state_size(int m) {
  int sz;
  sz = m + symmat_size(m);
  return sz;
}
\end{verbatim}

\subsection{ssm\_smooth\_state\_get\_mean}\label{ssmux5fsmoothux5fstateux5fgetux5fmean}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{x} A vector returned by
  \texttt{ssm\_smooth\_state}
\item
  \texttt{int} \textbf{q} The number of state disturbances,
  \(\vec{\eta}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{vector} An \(m \times 1\) vector with
\(\hat{\vec{\eta}}_t\).

Extract \(\hat{\vec{\alpha}}_t\) from vectors returned by
\texttt{ssm\_smooth\_state}

\begin{verbatim}
vector ssm_smooth_state_get_mean(vector x, int m) {
  vector[m] alpha;
  alpha = x[ :m];
  return alpha;
}
\end{verbatim}

\subsection{ssm\_smooth\_state\_get\_var}\label{ssmux5fsmoothux5fstateux5fgetux5fvar}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{x} A vector returned by
  \texttt{ssm\_smooth\_state}
\item
  \texttt{int} \textbf{m} The number of states
\end{itemize}

\textbf{Return Value:} \texttt{matrix} An \(m \times m\) matrix with
\(\mat{V}_t\).

Extract \(mat{V}_t\) from vectors returned by
\texttt{ssm\_smooth\_state}

\begin{verbatim}
matrix ssm_smooth_state_get_var(vector x, int m) {
  matrix[m, m] V;
  V = vector_to_symmat(x[(m + 1): ], m);
  return V;
}

\end{verbatim}

\subsection{ssm\_smooth\_state}\label{ssmux5fsmoothux5fstate}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector{[}{]}} \textbf{filter} Results of \texttt{ssm\_filter}
\item
  \texttt{matrix{[}{]}} \textbf{Z} Design matrix, \(\mat{Z}_t\). An
  array of \(p \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{T} Transition matrix, \(\mat{T}_t\). An
  array of \(m \times m\) matrices.
\end{itemize}

\textbf{Return Value:} \texttt{vector{[}{]}} An array of vectors
constaining \(\hat{\vec{\alpha}}_t\) and
\(\mat{V}_t = \Var(\vec{\alpha}_t | \vec{y}_{1:n})\).

The state smoother

This calculates the mean and variance of the states, \(\vec{\alpha}_t\),
given the entire sequence, \(\vec{y}_{1:n}\).

in the format described below.

For \texttt{Z} and \texttt{T} the array can have a size of 1, if it is
not time-varying, or a size of \(n\) (for \texttt{Z}) or \(n - 1\) (for
\texttt{T}) if it is time varying.

The vectors returned by this function have \(m + m ^ 2\) elements in
this format, \[
(\hat{\vec{\alpha}}_t', \VEC(\mat{V}_t)' )'.
\] Use the \texttt{ssm\_smooth\_state\_get\_mean} and
\texttt{ssm\_smooth\_state\_get\_var} to extract components from the
returned vectors.

\begin{longtable}[c]{@{}llll@{}}
\toprule
value & length & start & end\tabularnewline
\midrule
\endhead
\(\hat{\vec{\alpha}}_t\) & \(m\) & \(1\) & \(m\)\tabularnewline
\(\mat{V}_t\) & \(m (m + 1) / 2\) & \(m + 1\) &
\(m + m (m + 1) / 2\)\tabularnewline
\bottomrule
\end{longtable}

See \textcite{DurbinKoopman2012}, Eq 4.44 and eq 4.69.

\begin{verbatim}
vector[] ssm_smooth_state(vector[] filter, matrix[] Z, matrix[] T) {
  vector[ssm_smooth_state_size(dims(Z)[3])] res[size(filter)];
  int n;
  int m;
  int p;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  {
    // system matrices for current iteration
    matrix[p, m] Z_t;
    matrix[m, m] T_t;
    // smoother results
    vector[m] r;
    matrix[m, m] N;
    matrix[m, m] L;
    vector[m] alpha;
    matrix[m, m] V;
    // filter results
    vector[p] v;
    matrix[m, p] K;
    matrix[p, p] Finv;
    vector[m] a;
    matrix[m, m] P;

    if (size(Z) == 1) {
      Z_t = Z[1];
    }
    if (size(T) == 1) {
      T_t = T[1];
    }
    // initialize smoother
    // r and N go from n, n - 1, ..., 1, 0.
    // r_n and N_n
    r = rep_vector(0.0, m);
    N = rep_matrix(0.0, m, m);
    // move backwards in time: t, ..., 1
    for (i in 0:(n - 1)) {
      int t;
      t = n - i;
      // set time-varying system matrices
      if (size(Z) > 1) {
        Z_t = Z[t];
      }
      if (size(T) > 1) {
        T_t = T[t];
      }
      // get filtered values
      K = ssm_filter_get_K(filter[t], m, p);
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      a = ssm_filter_get_a(filter[t], m, p);
      P = ssm_filter_get_P(filter[t], m, p);
      // updating
      // L_t
      L = ssm_filter_update_L(Z_t, T_t, K);
      // r_{t - 1} and N_{t - 1}
      r = ssm_smooth_update_r(r, Z_t, v, Finv, L);
      N = ssm_smooth_update_N(N, Z_t, Finv, L);
      // hat(alpha)_{t} and V_t which use r and N from (t - 1)
      alpha = a + P * r;
      V = to_symmetric_matrix(P - P * N * P);
      // saving
      res[t, :m] = alpha;
      res[t, (m + 1): ] = symmat_to_vector(V);
    }
  }
  return res;
}

\end{verbatim}

\subsection{ssm\_smooth\_eps\_size}\label{ssmux5fsmoothux5fepsux5fsize}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{int} \textbf{p} The length of the observation vectors,
  \(\vec{y}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{int} The size of the vectors is
\(p + p (p + 1) / 2\).

The size of the vectors returned by \texttt{ssm\_smooth\_eps}

\begin{verbatim}
int ssm_smooth_eps_size(int p) {
  int sz;
  sz = p + symmat_size(p);
  return sz;
}
\end{verbatim}

\subsection{ssm\_smooth\_eps\_get\_mean}\label{ssmux5fsmoothux5fepsux5fgetux5fmean}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{x} \textbf{A} vector from the results of
  \texttt{ssm\_smooth\_eps}.
\item
  \texttt{int} \textbf{p} The length of the observation vectors,
  \(\vec{y}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{vector} A \(p \times 1\) vector with
\(\hat{\vec{\varepsilon}}_t\).

Extract \(\hat{\vec{\varepsilon}}_t\) from vectors returned by
\texttt{ssm\_smooth\_eps}

\begin{verbatim}
vector ssm_smooth_eps_get_mean(vector x, int p) {
  vector[p] eps;
  eps = x[ :p];
  return eps;
}
\end{verbatim}

\subsection{ssm\_smooth\_eps\_get\_var}\label{ssmux5fsmoothux5fepsux5fgetux5fvar}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{x} A vector returned by
  \texttt{ssm\_smooth\_eps}
\item
  \texttt{int} \textbf{p} The length of the observation vectors,
  \(\vec{y}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{matrix} A \(p \times p\) matrix with
\(\Var(\vec{\varepsilon}_t | \vec{y}_{1:n})\)

Extract \(\Var(\varepsilon_t|\vec{y}_{1:n})\) from vectors returned by
\texttt{ssm\_smooth\_eps}

\begin{verbatim}
matrix ssm_smooth_eps_get_var(vector x, int p) {
  matrix[p, p] eps_var;
  eps_var = vector_to_symmat(x[(p + 1): ], p);
  return eps_var;
}
\end{verbatim}

\subsection{ssm\_smooth\_eps}\label{ssmux5fsmoothux5feps}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector{[}{]}} \textbf{filter} Results of \texttt{ssm\_filter}
\item
  \texttt{matrix{[}{]}} \textbf{Z} Design matrix, \(\mat{Z}_t\). An
  array of \(p \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{H} Observation covariance matrix,
  \(\mat{H}_t\). An array of \(p \times p\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{T} Transition matrix, \(\mat{T}_t\). An
  array of \(m \times m\) matrices.
\end{itemize}

\textbf{Return Value:} \texttt{vector{[}{]}} An array of vectors
constaining \(\hat{\vec{\varepsilon}}_t\) and
\(\Var(\vec{\varepsilon}_t | \vec{y}_{1:n})\) in the format described
below.

The observation disturbance smoother

This calculates the mean and variance of the observation disturbances,
\(\vec{\varepsilon}_t\), given the entire sequence, \(\vec{y}_{1:n}\).

For Z\texttt{,}H\texttt{,\ T}, the array can have a size of 1, if it is
not time-varying, or a size of \(n\) (for \texttt{Z}, \texttt{H}) or
\(n - 1\) (for \texttt{T}), if it is time varying.

The vectors returned by this function have \(p + p (p + 1) / 2\)
elements in this format, \[
(\hat{\vec{\varepsilon}}_t', \VEC(\Var(\vec{\varepsilon}_t | \vec{y}_{1:n}))' )'
\]

\begin{longtable}[c]{@{}llll@{}}
\toprule
value & length & start & end\tabularnewline
\midrule
\endhead
\(\hat{\vec{\varepsilon}}_t\) & \(p\) & \(1\) & \(p\)\tabularnewline
\(\Var(\vec{\varepsilon}_t | \vec{y}_{1:n})\) & \(p (p + 1) / 2\) &
\(p + 1\) & \(p + p (p + 1) / 2\)\tabularnewline
\bottomrule
\end{longtable}

See \autocite[Sec 4.5.3 (eq 4.69)]{DurbinKoopman2012}

\begin{verbatim}
vector[] ssm_smooth_eps(vector[] filter, matrix[] Z, matrix[] H, matrix[] T) {
  vector[ssm_smooth_eps_size(dims(Z)[2])] res[size(filter)];
  int n;
  int m;
  int p;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  {
    // smoother values
    vector[m] r;
    matrix[m, m] N;
    matrix[m, m] L;
    vector[p] eps;
    matrix[p, p] var_eps;
    // filter results
    vector[p] v;
    matrix[m, p] K;
    matrix[p, p] Finv;
    // system matrices
    matrix[p, m] Z_t;
    matrix[p, p] H_t;
    matrix[m, m] T_t;

    // set matrices if time-invariant
    if (size(Z) == 1) {
      Z_t = Z[1];
    }
    if (size(H) == 1) {
      H_t = H[1];
    }
    if (size(T) == 1) {
      T_t = T[1];
    }
    // initialize smoother
    // r and N go from n, n - 1, ..., 1, 0.
    // r_n and N_n
    r = rep_vector(0.0, m);
    N = rep_matrix(0.0, m, m);
    for (i in 1:n) {
      int t;
      // move backwards in time
      t = n - i + 1;
      // update time-varying system matrices
      if (size(Z) > 1) {
        Z_t = Z[t];
      }
      if (size(H) > 1) {
        H_t = H[t];
      }
      if (size(T) > 1) {
        T_t = T[t];
      }
      // get values from filter
      K = ssm_filter_get_K(filter[t], m, p);
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      // updating
      L = ssm_filter_update_L(Z_t, T_t, K);
      // r_{t - 1} and N_{t - 1}
      r = ssm_smooth_update_r(r, Z_t, v, Finv, L);
      N = ssm_smooth_update_N(N, Z_t, Finv, L);
      // eps_t and V(eps_t|y)
      eps = H_t * (Finv * v - K ' * r);
      var_eps = to_symmetric_matrix(H_t - H_t * (Finv + quad_form(N, K)) * H_t);
      // saving
      res[t, :p] = eps;
      res[t, (p + 1): ] = symmat_to_vector(var_eps);
    }
  }
  return res;
}
\end{verbatim}

\subsection{ssm\_smooth\_eta}\label{ssmux5fsmoothux5feta}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{int} \textbf{p} The length of the observation vectors,
  \(\vec{y}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{int} The size of the vectors is
\(q + q (q + 1) / 2\).

The size of the vectors returned by \texttt{ssm\_smooth\_eta}

\begin{verbatim}
int ssm_smooth_eta_size(int q) {
  int sz;
  sz = q + symmat_size(q);
  return sz;
}
\end{verbatim}

\subsection{ssm\_smooth\_eta\_get\_mean}\label{ssmux5fsmoothux5fetaux5fgetux5fmean}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{x} A vector returned by
  \texttt{ssm\_smooth\_eta}
\item
  \texttt{int} \textbf{q} The number of state disturbances,
  \(\vec{\eta}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{vector} A \(q \times 1\) vector with
\(\hat{\vec{\eta}}_t\).

Extract \(\hat{\vec{\varepsilon}}_t\) from vectors returned by
\texttt{ssm\_smooth\_eta}

\begin{verbatim}
vector ssm_smooth_eta_get_mean(vector x, int q) {
  vector[q] eta;
  eta = x[ :q];
  return eta;
}
\end{verbatim}

\subsection{ssm\_smooth\_eta\_get\_var}\label{ssmux5fsmoothux5fetaux5fgetux5fvar}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{x} A vector returned by
  \texttt{ssm\_smooth\_eta}
\item
  \texttt{int} \textbf{q} The number of state disturbances,
  \(\vec{\eta}_t\).
\end{itemize}

\textbf{Return Value:} \texttt{matrix} A \(q \times q\) matrix with
\(\Var(\vec{\eta}_t | \vec{y}_{1:n})\).

Extract \(\Var(\eta_t|\vec{y}_{1:n})\) from vectors returned by
\texttt{ssm\_smooth\_eta}

\begin{verbatim}
matrix ssm_smooth_eta_get_var(vector x, int q) {
  matrix[q, q] eta_var;
  eta_var = vector_to_symmat(x[(q + 1): ], q);
  return eta_var;
}
\end{verbatim}

\subsection{ssm\_smooth\_eta}\label{ssmux5fsmoothux5feta-1}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector{[}{]}} \textbf{filter} Results of \texttt{ssm\_filter}
\item
  \texttt{matrix{[}{]}} \textbf{Z} Design matrix, \(\mat{Z}_t\). An
  array of \(p \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{T} Transition matrix, \(\mat{T}_t\). An
  array of \(m \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{R} State covariance selection matrix,
  \(\mat{R} _t\). An array of \(p \times q\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{Q} State covariance matrix,
  \(\mat{Q}_t\). An array of \(q \times q\) matrices.
\end{itemize}

\textbf{Return Value:} \texttt{vector{[}{]}} An array of vectors
constaining \(\hat{\vec{\eta}}_t\) and
\(\Var(\vec{\eta}_t | \vec{y}_{1:n})\) in the format described below.

The state disturbance smoother

This calculates the mean and variance of the observation disturbances,
\(\vec{\eta}_t\), given the entire sequence, \(\vec{y}_{1:n}\).

For \texttt{Z}, \texttt{T}, \texttt{R}, \texttt{Q} the array can have a
size of 1, if it is not time-varying, or a size of \(n\) (for
\texttt{Z}) or \(n - 1\) (for \texttt{T}, \texttt{R}, \texttt{Q}) if it
is time varying.

The vectors returned by this function have \(q + q (q + 1) / 2\)
elements in this format, \[
(\hat{\vec{\eta}}_t', \VEC(\Var(\vec{\eta}_t | \vec{y}_{1:n}))' ).
\] Use the \texttt{ssm\_smooth\_eta\_get\_mean} and
\texttt{ssm\_smooth\_eta\_get\_var} to extract components from the
returned vectors.

\begin{longtable}[c]{@{}llll@{}}
\toprule
value & length & start & end\tabularnewline
\midrule
\endhead
\(\hat{\vec{\eta}}_t\) & \(q\) & \(1\) & \(q\)\tabularnewline
\(\Var(\vec{\eta}_t | \vec{y}_{1:n})\) & \(q (q + 1) / 2\) & \(q + 1\) &
\(q + q (q + 1) / 2\)\tabularnewline
\bottomrule
\end{longtable}

See \autocite[Sec 4.5.3 (eq 4.69)]{DurbinKoopman2012}

\begin{verbatim}
vector[] ssm_smooth_eta(vector[] filter,
                        matrix[] Z, matrix[] T,
                        matrix[] R, matrix[] Q) {
  vector[ssm_smooth_eta_size(dims(Q)[2])] res[size(filter)];
  int n;
  int m;
  int p;
  int q;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  q = dims(Q)[2];
  {
    // smoother matrices
    vector[m] r;
    matrix[m, m] N;
    matrix[m, m] L;
    vector[q] eta;
    matrix[q, q] var_eta;
    // system matrices
    matrix[p, m] Z_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    // filter matrices
    vector[p] v;
    matrix[m, p] K;
    matrix[p, p] Finv;

    // set time-invariant matrices
    if (size(Z) == 1) {
      Z_t = Z[1];
    }
    if (size(T) == 1) {
      T_t = T[1];
    }
    if (size(R) == 1) {
      R_t = R[1];
    }
    if (size(Q) == 1) {
      Q_t = Q[1];
    }
    // initialize smoother
    r = rep_vector(0.0, m);
    N = rep_matrix(0.0, m, m);
    for (i in 0:(n - 1)) {
      int t;
      // move backwards in time
      t = n - i;
      // update time-varying system matrices
      if (size(Z) > 1) {
        Z_t = Z[t];
      }
      if (size(T) > 1) {
        T_t = T[t];
      }
      if (size(R) > 1) {
        R_t = R[t];
      }
      if (size(Q) > 1) {
        Q_t = Q[t];
      }
      // get values from filter
      K = ssm_filter_get_K(filter[t], m, p);
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      // update smoother
      L = ssm_filter_update_L(Z_t, T_t, K);
      r = ssm_smooth_update_r(r, Z_t, v, Finv, L);
      N = ssm_smooth_update_N(N, Z_t, Finv, L);
      eta = Q_t * R_t ' * r;
      var_eta = to_symmetric_matrix(Q_t - Q_t * quad_form(N, R_t) * Q_t);
      // saving
      res[t, :q] = eta;
      res[t, (q + 1): ] = symmat_to_vector(var_eta);
    }
  }
  return res;
}
\end{verbatim}

\subsection{ssm\_smooth\_faststate}\label{ssmux5fsmoothux5ffaststate}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector{[}{]}} \textbf{filter} The results of
  \texttt{ssm\_filter}
\item
  \texttt{matrix{[}{]}} \textbf{Z} Design matrix, \(\mat{Z}_t\). An
  array of \(p \times m\) matrices.
\item
  \texttt{vector{[}{]}} \textbf{c} State intercept, \(\vec{c}_t\). An
  array of \(m \times 1\) vectors.
\item
  \texttt{matrix{[}{]}} \textbf{T} Transition matrix, \(\mat{T}_t\). An
  array of \(m \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{R} State covariance selection matrix,
  \(\mat{R} _t\). An array of \(p \times q\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{Q} State covariance matrix,
  \(\mat{Q}_t\). An array of \(q \times q\) matrices.
\end{itemize}

\textbf{Return Value:} \texttt{vector{[}{]}} An array of size \(n\) of
\(m \times 1\) vectors containing \(\hat{\vec{\alpha}}_t\).

The fast state smoother

The fast state smoother calculates
\(\hat{\vec{\alpha}}_t = \E(\vec{\alpha}_t | \vec{y}_{1:n})\). \[
\hat{\vec{\alpha}}_{t + 1} = \mat{T}_t \hat{\vec{\alpha}}_{t} + \mat{R}_t \mat{Q}_t \mat{R}'_t \vec{r}_t ,
\] where \(r_t\) is calcualted from the state disturbance smoother. The
smoother is initialized at \(t = 1\) with
\(\hat{\vec{\alpha}}_t = \vec{a}_1 + \mat{P}_1 \vec{r}_0\).

Unlike the normal state smoother, it does not calculate the variances of
the smoothed state.

For \texttt{Z}, \texttt{c}, \texttt{T}, \texttt{R}, \texttt{Q} the array
can have a size of 1, if it is not time-varying, or a size of \(n\) (for
\texttt{Z}) or \(n - 1\) (for \texttt{c}, \texttt{T}, \texttt{R},
\texttt{Q}) if it is time varying.

See \autocite[Sec 4.5.3 (eq 4.69)]{DurbinKoopman2012}

\begin{verbatim}
vector[] ssm_smooth_faststate(vector[] filter,
                              vector[] c, matrix[] Z, matrix[] T,
                              matrix[] R, matrix[] Q) {
  vector[dims(Z)[3]] alpha[size(filter)];
  int n;
  int m;
  int p;
  int q;
  n = size(filter);
  m = dims(Z)[3];
  p = dims(Z)[2];
  q = dims(Q)[2];
  {
    // smoother matrices
    vector[m] r[n + 1];
    matrix[m, m] L;
    vector[m] a1;
    matrix[m, m] P1;
    // filter matrices
    vector[p] v;
    matrix[m, p] K;
    matrix[p, p] Finv;
    // system matrices
    matrix[p, m] Z_t;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[p, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // set time-invariant matrices
    if (size(c) == 1) {
      c_t = c[1];
    }
    if (size(Z) == 1) {
      Z_t = Z[1];
    }
    if (size(T) == 1) {
      T_t = T[1];
    }
    if (size(R) == 1) {
      R_t = R[1];
    }
    if (size(Q) == 1) {
      Q_t = Q[1];
    }
    if (size(Q) == 1 && size(R) == 1) {
      RQR = quad_form(Q[1], R[1]');
    }
    // find smoothed state disturbances
    // Since I don't need to calculate the
    // variances of the smoothed disturbances,
    // I reimplement the state distrurbance smoother here
    // removing extraneous parts.
    // r goes from t = n, ..., 1, 0.
    // r_n
    r[n + 1] = rep_vector(0.0, m);
    for (i in 0:(n - 1)) {
      int t;
      // move backwards in time
      t = n - i;
      // update time varying system matrices
      if (size(Z) > 1) {
        Z_t = Z[t];
      }
      if (size(T) > 1) {
        T_t = T[t];
      }
      // get filter values
      K = ssm_filter_get_K(filter[t], m, p);
      v = ssm_filter_get_v(filter[t], m, p);
      Finv = ssm_filter_get_Finv(filter[t], m, p);
      // updating smoother
      L = ssm_filter_update_L(Z_t, T_t, K);
      // r_{t - 1}
      r[t] = ssm_smooth_update_r(r[t + 1], Z_t, v, Finv, L);
    }
    // calculate smoothed states
    a1 = ssm_filter_get_a(filter[1], m, p);
    P1 = ssm_filter_get_P(filter[1], m, p);
    // r[1] = r_0
    alpha[1] = a1 + P1 * r[1];
    // 1:(n - 1) -> \alpha_{2}:\alpha_{n}
    for (t in 1:(n - 1)) {
      if (size(c) > 1) {
        c_t = c[t];
      }
      if (size(T) > 1) {
        T_t = T[t];
      }
      if (size(Q) > 1) {
        Q_t = Q[t];
      }
      if (size(R) > 1) {
        R_t = R[t];
      }
      if (size(Q) > 1 || size(R) > 1) {
        RQR = quad_form(Q_t, R_t');
      }
      // `r[t + 1]` = $r_{t}$
      // alpha_{t + 1} = c_t + T_t * \alpha_t + R_t Q_t R'_t r_t
      alpha[t + 1] = c_t + T_t * alpha[t] + RQR * r[t + 1];
    }
  }
  return alpha;
}



\end{verbatim}

\section{Simulators and Smoothing
Simulators}\label{simulators-and-smoothing-simulators}

\subsection{ssm\_sim\_idx}\label{ssmux5fsimux5fidx}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{int} \textbf{m} The number of states
\item
  \texttt{int} \textbf{p} The length of the observation vector
\item
  \texttt{int} \textbf{q} The number of state disturbances
\end{itemize}

\textbf{Return Value:} \texttt{int{[},{]}} A 4 x 3 array of integers

Indexes of each component of \texttt{ssm\_sim\_rng} results.

The returned array has columns (length, start location, and end
location) for rows: \(\vec{y}_t\), \(\vec{\alpha}_t\),
\(\vec{\varepsilon}_t\), and \(\vec{\eta}_t\) in the results of
\texttt{ssm\_sim\_rng}.

\begin{verbatim}
int[,] ssm_sim_idx(int m, int p, int q) {
  int sz[4, 3];
  // y
  sz[1, 1] = p;
  // a
  sz[2, 1] = m;
  // eps
  sz[3, 1] = p;
  // eta
  sz[4, 1] = q;
  // Fill in start and stop points
  sz[1, 2] = 1;
  sz[1, 3] = sz[1, 2] + sz[1, 1] - 1;
  for (i in 2:4) {
    sz[i, 2] = sz[i - 1, 3] + 1;
    sz[i, 3] = sz[i, 2] + sz[i, 1] - 1;
  }
  return sz;
}
\end{verbatim}

\subsection{ssm\_sim\_size}\label{ssmux5fsimux5fsize}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{int} \textbf{m} The number of states
\item
  \texttt{int} \textbf{p} The length of the observation vector
\item
  \texttt{int} \textbf{q} The number of state disturbances
\end{itemize}

\textbf{Return Value:} \texttt{int} The number of elements

The number of elements in vectors returned by \texttt{ssm\_sim\_rng}
results.

\begin{verbatim}
int ssm_sim_size(int m, int p, int q) {
  int sz;
  sz = ssm_sim_idx(m, p, q)[4, 3];
  return sz;
}
\end{verbatim}

\subsection{ssm\_sim\_get\_y}\label{ssmux5fsimux5fgetux5fy}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{int} \textbf{m} The number of states
\item
  \texttt{int} \textbf{p} The length of the observation vector
\item
  \texttt{int} \textbf{q} The number of state disturbances
\end{itemize}

\textbf{Return Value:} \texttt{vector} vector A \(p \times 1\) vector
with \(\vec{y}_t\).

Extract \(\vec{y}_t\) from vectors returned by \texttt{ssm\_sim\_rng}.

\begin{verbatim}
vector ssm_sim_get_y(vector x, int m, int p, int q) {
  vector[m] y;
  int idx[4, 3];
  idx = ssm_sim_idx(m, p, q);
  y = x[idx[1, 2]:idx[1, 3]];
  return y;
}
\end{verbatim}

\subsection{ssm\_sim\_get\_a}\label{ssmux5fsimux5fgetux5fa}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{int} \textbf{m} The number of states
\item
  \texttt{int} \textbf{p} The length of the observation vector
\item
  \texttt{int} \textbf{q} The number of state disturbances
\end{itemize}

\textbf{Return Value:} \texttt{vector} A \(m \times 1\) vector with
\(\vec{\alpha}_t\).

Extract \(\vec{\alpha}_t\) from vectors returne by
\texttt{ssm\_sim\_rng}.

\begin{verbatim}
vector ssm_sim_get_a(vector x, int m, int p, int q) {
  vector[m] a;
  int idx[4, 3];
  idx = ssm_sim_idx(m, p, q);
  a = x[idx[2, 2]:idx[2, 3]];
  return a;
}
\end{verbatim}

\subsection{ssm\_sim\_get\_eps}\label{ssmux5fsimux5fgetux5feps}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{int} \textbf{m} The number of states
\item
  \texttt{int} \textbf{p} The length of the observation vector
\item
  \texttt{int} \textbf{q} The number of state disturbances
\end{itemize}

\textbf{Return Value:} \texttt{vector} vector A \(p \times 1\) vector
with \(\vec{\varepsilon}_t\).

Extract \(\vec{\varepsilon}_t\) from vectors returne by
\texttt{ssm\_sim\_rng}.

\begin{verbatim}
vector ssm_sim_get_eps(vector x, int m, int p, int q) {
  vector[m] eps;
  int idx[4, 3];
  idx = ssm_sim_idx(m, p, q);
  eps = x[idx[3, 2]:idx[3, 3]];
  return eps;
}
\end{verbatim}

\subsection{ssm\_sim\_get\_eta}\label{ssmux5fsimux5fgetux5feta}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{int} \textbf{m} The number of states
\item
  \texttt{int} \textbf{p} The length of the observation vector
\item
  \texttt{int} \textbf{q} The number of state disturbances
\end{itemize}

\textbf{Return Value:} \texttt{vector} vector A \(q \times 1\) vector
with \(\vec{\eta}_t\).

Extract \(\vec{\eta}_t\) from vectors returne by \texttt{ssm\_sim\_rng}.

\begin{verbatim}
vector ssm_sim_get_eta(vector x, int m, int p, int q) {
  vector[m] eta;
  int idx[4, 3];
  idx = ssm_sim_idx(m, p, q);
  eta = x[idx[4, 2]:idx[4, 3]];
  return eta;
}
\end{verbatim}

\subsection{ssm\_sim\_rng}\label{ssmux5fsimux5frng}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector{[}{]}} \textbf{y} Observations, \(\vec{y}_t\). An array
  of size \(n\) of \(p \times 1\) vectors.
\item
  \texttt{vector{[}{]}} \textbf{d} Observation intercept, \(\vec{d}_t\).
  An array of \(p \times 1\) vectors.
\item
  \texttt{matrix{[}{]}} \textbf{Z} Design matrix, \(\mat{Z}_t\). An
  array of \(p \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{H} Observation covariance matrix,
  \(\mat{H}_t\). An array of \(p \times p\) matrices.
\item
  \texttt{vector{[}{]}} \textbf{c} State intercept, \(\vec{c}_t\). An
  array of \(m \times 1\) vectors.
\item
  \texttt{matrix{[}{]}} \textbf{T} Transition matrix, \(\mat{T}_t\). An
  array of \(m \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{R} State covariance selection matrix,
  \(\mat{R} _t\). An array of \(p \times q\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{Q} State covariance matrix,
  \(\mat{Q}_t\). An array of \(q \times q\) matrices.
\item
  \texttt{vector} \textbf{a1} Expected value of the intial state,
  \(a_1 = \E(\alpha_1)\). An \(m \times 1\) matrix.
\item
  \texttt{matrix} \textbf{P1} Variance of the initial state,
  \(P_1 = \Var(\alpha_1)\). An \(m \times m\) matrix.
\end{itemize}

\textbf{Return Value:} \texttt{Array} of size \(n\) of vectors with Draw
\(\vec{y}_t\), \(\vec{\alpha}_t\), \(\vec{\eta}_t\) and
\(\vec{\varepsilon}_t\). See the description.

Simulate from a Linear Gaussian State Space model.

For \texttt{d}, \texttt{Z}, \texttt{H}, \texttt{c}, \texttt{T},
\texttt{R}, \texttt{Q} the array can have a size of 1, if it is not
time-varying, or a size of \(n\) (for \texttt{d}, \texttt{Z},
\texttt{H}) or \(n - 1\) (for \texttt{c}, \texttt{T}, \texttt{R},
\texttt{Q}) if it is time varying.

Draw \(\vec{y}_t\), \(\vec{\alpha}_t\), \(\vec{\eta}_t\) and
\(\vec{\varepsilon}_t\) from the state space model, \[
\begin{aligned}[t]
\vec{y}_t &= \vec{d}_t + \mat{Z}_t \vec{\alpha}_t + \vec{\varepsilon}_t,  &
\vec{\varepsilon}_t & \sim N(0, \mat{H}_t), \\
\vec{\alpha}_{t + 1} &= \vec{c}_t + \mat{T}_t \vec{\alpha}_t + \mat{R}_t \vec{\eta}_t,  &
\vec{\eta}_t & \sim N(0, \mat{Q}_t), \\
&& \vec{\alpha}_1 &\sim N(\vec{a}_1, \mat{P}_1) .
\end{aligned}
\]

The returned vectors are of length \(2 p + m + q\), in the format, \[
(\vec{y}_t', \vec{\alpha}_t', \vec{\varepsilon}_t', \vec{\eta}_t') .
\] Note that \(\eta_n = \vec{0}_q\). Use the functions
\texttt{ssm\_sim\_get\_y}, \texttt{ssm\_sim\_get\_a},
\texttt{ssm\_sim\_get\_eps}, and \texttt{ssm\_sim\_get\_eta} to extract
values from the vector.

\begin{longtable}[c]{@{}llll@{}}
\toprule
element & length & start & end\tabularnewline
\midrule
\endhead
\(y_t\) & \(p\) & \(1\) & \(p\)\tabularnewline
\(\alpha\)\_t & \(m\) & \(p + 1\) & \(p + m\)\tabularnewline
\(\varepsilon_t\) & \(p\) & \(p + m + 1\) & \(2 p + m\)\tabularnewline
\(\eta_t\) & \(q\) & \(2 p + m + 1\) & \(2 p + m + q\)\tabularnewline
\bottomrule
\end{longtable}

It is preferrable to use \texttt{ssm\_sim\_get\_y},
\texttt{ssm\_sim\_get\_a}, \texttt{ssm\_sim\_get\_eps}, and
\texttt{ssm\_sim\_get\_eta} to extract values from these vectors.

\begin{verbatim}
vector[] ssm_sim_rng(int n,
                    vector[] d, matrix[] Z, matrix[] H,
                    vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                    vector a1, matrix P1) {
  vector[ssm_sim_size(dims(Z)[3], dims(Z)[2], dims(Q)[2])] ret[n];
  int p;
  int m;
  int q;
  p = dims(Z)[2];
  m = dims(Z)[3];
  q = dims(Q)[2];
  {
    // system matrices for current iteration
    vector[p] d_t;
    matrix[p, m] Z_t;
    matrix[p, p] H_t;
    vector[m] c_t;
    matrix[m, m] T_t;
    matrix[m, q] R_t;
    matrix[q, q] Q_t;
    matrix[m, m] RQR;
    // outputs
    vector[p] y;
    vector[p] eps;
    vector[m] a;
    vector[q] eta;
    // constants
    vector[p] zero_p;
    vector[q] zero_q;
    vector[m] zero_m;
    int idx[4, 3];

    d_t = d[1];
    Z_t = Z[1];
    H_t = H[1];
    c_t = c[1];
    T_t = T[1];
    R_t = R[1];
    Q_t = Q[1];

    idx = ssm_sim_idx(m, p, q);
    zero_p = rep_vector(0.0, p);
    zero_q = rep_vector(0.0, q);
    zero_m = rep_vector(0.0, m);
    a = multi_normal_rng(a1, P1);
    for (t in 1:n) {
      // set system matrices
      if (t > 1) {
        if (size(d) > 1) {
          d_t = d[t];
        }
        if (size(Z) > 1) {
          Z_t = Z[t];
        }
        if (size(H) > 1) {
          H_t = H[t];
        }
        // system matrices are n - 1 length
        if (t < n) {
          if (size(c) > 1) {
            c_t = c[t];
          }
          if (size(T) > 1) {
            T_t = T[t];
          }
          if (size(R) > 1) {
            R_t = R[t];
          }
          if (size(Q) > 1) {
            Q_t = Q[t];
          }
        }
      }
      // draw forecast error
      eps = multi_normal_rng(zero_p, H_t);
      // draw observed value
      y = d_t + Z_t * a + eps;
      // since eta_t is for alpha_{t + 1}, we don't
      // draw it for t == n
      if (t == n) {
        eta = zero_q;
      } else {
        eta = multi_normal_rng(zero_q, Q_t);
      }
      // save
      ret[t, idx[1, 2]:idx[1, 3]] = y;
      ret[t, idx[2, 2]:idx[2, 3]] = a;
      ret[t, idx[3, 2]:idx[3, 3]] = eps;
      ret[t, idx[4, 2]:idx[4, 3]] = eta;
      // a_{t + 1}
      if (t < n) {
        a = c_t + T_t * a + R_t * eta;
      }
    }
  }
  return ret;
}
\end{verbatim}

\section{Simulation Smoothers}\label{simulation-smoothers-1}

\subsection{ssm\_simsmo\_state\_rng}\label{ssmux5fsimsmoux5fstateux5frng}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector{[}{]}} \textbf{alpha} An of size \(n\) of
  \(m \times 1\) vectors containing the smoothed expected values of the
  states, \(\E(\vec{\alpha}_{1:n} | \vec{y}_{1:n})\). These are returned
  by \texttt{sim\_smooth\_faststates}. If \texttt{sim\_smooth\_state}
  was used, then the expected values need to first be extracted using
  \texttt{sim\_smooth\_state\_get\_mean}.
\item
  \texttt{vector{[}{]}} \textbf{d} Observation intercept, \(\vec{d}_t\).
  An array of \(p \times 1\) vectors.
\item
  \texttt{matrix{[}{]}} \textbf{Z} Design matrix, \(\mat{Z}_t\). An
  array of \(p \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{H} Observation covariance matrix,
  \(\mat{H}_t\). An array of \(p \times p\) matrices.
\item
  \texttt{vector{[}{]}} \textbf{c} State intercept, \(\vec{c}_t\). An
  array of \(m \times 1\) vectors.
\item
  \texttt{matrix{[}{]}} \textbf{T} Transition matrix, \(\mat{T}_t\). An
  array of \(m \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{R} State covariance selection matrix,
  \(\mat{R} _t\). An array of \(p \times q\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{Q} State covariance matrix,
  \(\mat{Q}_t\). An array of \(q \times q\) matrices.
\item
  \texttt{vector} \textbf{a1} Expected value of the intial state,
  \(a_1 = \E(\alpha_1)\). An \(m \times 1\) matrix.
\item
  \texttt{matrix} \textbf{P1} Variance of the initial state,
  \(P_1 = \Var(\alpha_1)\). An \(m \times m\) matrix.
\end{itemize}

\textbf{Return Value:} \texttt{vector{[}{]}} Array of size \(n\) of
\(m \times 1\) vectors containing a single draw from
\((\vec{\alpha}_{1:n} | \vec{y}_{1:n})\).

State simulation smoother

Draw samples from the posterior distribution of the states,
\(\tilde{\vec{\alpha}}_{1:n} \sim p(\vec{\alpha}_{1:n} | \vec{y}_{1:n})\).

For \texttt{d}, \texttt{Z}, \texttt{H}, \texttt{c}, \texttt{T},
\texttt{R}, \texttt{Q} the array can have a size of 1, if it is not
time-varying, or a size of \(n\) (for \texttt{d}, \texttt{Z},
\texttt{H}) or \(n - 1\) (for \texttt{c}, \texttt{T}, \texttt{R},
\texttt{Q}) if it is time varying.

This draws samples using mean-correction simulation smoother of
\autocite{DurbinKoopman2002}. See \autocite[Sec 4.9]{DurbinKoopman2012}.

\begin{verbatim}
vector[] ssm_simsmo_states_rng(vector[] alpha,
                      vector[] d, matrix[] Z, matrix[] H,
                      vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                      vector a1, matrix P1) {
    vector[dims(Z)[2]] draws[size(alpha)];
    int n;
    int p;
    int m;
    int q;
    n = size(alpha);
    p = dims(Z)[2];
    m = dims(Z)[3];
    q = dims(Q)[2];
    {
      vector[ssm_filter_size(m, p)] filter[n];
      vector[ssm_sim_size(m, p, q)] sims[n];
      vector[p] y[n];
      vector[m] alpha_hat_plus[n];
      // simulate unconditional disturbances and observations
      sims = ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1);
      for (i in 1:n) {
        y[i] = ssm_sim_get_y(sims[i], m, p, q);
      }
      // filter with simulated y's
      filter = ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1);
      // mean correct epsilon samples
      alpha_hat_plus = ssm_smooth_faststate(filter, c, Z, T, R, Q);
      for (i in 1:n) {
        draws[i] = (ssm_sim_get_a(sims[i], m, p, q)
                    - alpha_hat_plus[i]
                    + alpha[i]);
      }
    }
    return draws;
}
\end{verbatim}

\subsection{ssm\_simsmo\_eta\_rng}\label{ssmux5fsimsmoux5fetaux5frng}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector{[}{]}} \textbf{eta} Values returned by
  \texttt{sim\_smooth\_eta}
\item
  \texttt{vector{[}{]}} \textbf{d} Observation intercept, \(\vec{d}_t\).
  An array of \(p \times 1\) vectors.
\item
  \texttt{matrix{[}{]}} \textbf{Z} Design matrix, \(\mat{Z}_t\). An
  array of \(p \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{H} Observation covariance matrix,
  \(\mat{H}_t\). An array of \(p \times p\) matrices.
\item
  \texttt{vector{[}{]}} \textbf{c} State intercept, \(\vec{c}_t\). An
  array of \(m \times 1\) vectors.
\item
  \texttt{matrix{[}{]}} \textbf{T} Transition matrix, \(\mat{T}_t\). An
  array of \(m \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{R} State covariance selection matrix,
  \(\mat{R} _t\). An array of \(p \times q\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{Q} State covariance matrix,
  \(\mat{Q}_t\). An array of \(q \times q\) matrices.
\item
  \texttt{vector} \textbf{a1} Expected value of the intial state,
  \(a_1 = \E(\alpha_1)\). An \(m \times 1\) matrix.
\item
  \texttt{matrix} \textbf{P1} Variance of the initial state,
  \(P_1 = \Var(\alpha_1)\). An \(m \times m\) matrix.
\end{itemize}

\textbf{Return Value:} \texttt{vector{[}{]}} Array of size \(n\) of
\(q \times 1\) vectors containing a single draw from
\((\vec{\eta}_{1:n} | \vec{y}_{1:n})\).

State disturbance simulation smoother

Draw samples from the posterior distribution of the observation
disturbances,
\(\tilde{\vec{\eta}}_{1:n} \sim p(\vec{\eta}_{1:n} | \vec{y}_{1:n})\).

For \texttt{d}, \texttt{Z}, \texttt{H}, \texttt{c}, \texttt{T},
\texttt{R}, \texttt{Q} the array can have a size of 1, if it is not
time-varying, or a size of \(n\) (for \texttt{d}, \texttt{Z},
\texttt{H}) or \(n - 1\) (for \texttt{c}, \texttt{T}, \texttt{R},
\texttt{Q}) if it is time varying.

This draws samples using mean-correction simulation smoother of
\autocite{DurbinKoopman2002}. See \autocite[Sec 4.9]{DurbinKoopman2012}.

\begin{verbatim}
vector[] ssm_simsmo_eta_rng(vector[] eta,
                            vector[] d, matrix[] Z, matrix[] H,
                            vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                            vector a1, matrix P1) {
    vector[dims(Q)[2]] draws[size(eta)];
    int n;
    int p;
    int m;
    int q;
    n = size(eta);
    p = dims(Z)[2];
    m = dims(Z)[3];
    q = dims(Q)[2];
    {
      vector[ssm_filter_size(m, p)] filter[n];
      vector[p] y[n];
      vector[ssm_sim_size(m, p, q)] sims[n];
      vector[ssm_smooth_eta_size(q)] etahat_plus[n];
      // simulate unconditional disturbances and observations
      sims = ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1);
      for (i in 1:n) {
        y[i] = ssm_sim_get_y(sims[i], m, p, q);
      }
      // filter simulated y's
      filter = ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1);
      // mean correct eta samples
      etahat_plus = ssm_smooth_eta(filter, Z, T, R, Q);
      for (i in 1:n) {
        draws[i] = (ssm_sim_get_eta(sims[i], m, p, q)
                                    - ssm_smooth_eta_get_mean(etahat_plus[i], q)
                                    + ssm_smooth_eta_get_mean(eta[i], q));
      }
    }
    return draws;
}
\end{verbatim}

\subsection{ssm\_simsmo\_eps\_rng}\label{ssmux5fsimsmoux5fepsux5frng}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector{[}{]}} \textbf{eps} Values returned by
  \texttt{sim\_smooth\_eps}
\item
  \texttt{vector{[}{]}} \textbf{d} Observation intercept, \(\vec{d}_t\).
  An array of \(p \times 1\) vectors.
\item
  \texttt{matrix{[}{]}} \textbf{Z} Design matrix, \(\mat{Z}_t\). An
  array of \(p \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{H} Observation covariance matrix,
  \(\mat{H}_t\). An array of \(p \times p\) matrices.
\item
  \texttt{vector{[}{]}} \textbf{c} State intercept, \(\vec{c}_t\). An
  array of \(m \times 1\) vectors.
\item
  \texttt{matrix{[}{]}} \textbf{T} Transition matrix, \(\mat{T}_t\). An
  array of \(m \times m\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{R} State covariance selection matrix,
  \(\mat{R} _t\). An array of \(p \times q\) matrices.
\item
  \texttt{matrix{[}{]}} \textbf{Q} State covariance matrix,
  \(\mat{Q}_t\). An array of \(q \times q\) matrices.
\item
  \texttt{vector} \textbf{a1} Expected value of the intial state,
  \(a_1 = \E(\alpha_1)\). An \(m \times 1\) matrix.
\item
  \texttt{matrix} \textbf{P1} Variance of the initial state,
  \(P_1 = \Var(\alpha_1)\). An \(m \times m\) matrix.
\end{itemize}

\textbf{Return Value:} \texttt{vector{[}{]}} Array of size \(n\) of
\(p \times 1\) vectors containing a single draw from
\((\vec{\varepsilon}_{1:n} | \vec{y}_{1:n})\).

Observation disturbance simulation smoother

Draw samples from the posterior distribution of the observation
disturbances,
\(\tilde{\vec{\varepsilon}}_{1:n} \sim p(\vec{\varepsilon}_{1:n} | \vec{y}_{1:n})\).

For \texttt{d}, \texttt{Z}, \texttt{H}, \texttt{c}, \texttt{T},
\texttt{R}, \texttt{Q} the array can have a size of 1, if it is not
time-varying, or a size of \(n\) (for \texttt{d}, \texttt{Z},
\texttt{H}) or \(n - 1\) (for \texttt{c}, \texttt{T}, \texttt{R},
\texttt{Q}) if it is time varying.

This draws samples using mean-correction simulation smoother of
\autocite{DurbinKoopman2002}. See \autocite[Sec 4.9]{DurbinKoopman2012}.

\begin{verbatim}
vector[] ssm_simsmo_eps_rng(vector[] eps,
                      vector[] d, matrix[] Z, matrix[] H,
                      vector[] c, matrix[] T, matrix[] R, matrix[] Q,
                      vector a1, matrix P1) {
    vector[dims(Z)[2]] draws[size(eps)];
    int n;
    int p;
    int m;
    int q;
    n = size(eps);
    p = dims(Z)[2];
    m = dims(Z)[3];
    q = dims(Q)[2];
    {
      vector[ssm_filter_size(m, p)] filter[n];
      vector[p] y[n];
      vector[ssm_sim_size(m, p, q)] sims[n];
      vector[ssm_smooth_eta_size(p)] epshat_plus[n];
      // simulate unconditional disturbances and observations
      sims = ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1);
      for (i in 1:n) {
        y[i] = ssm_sim_get_y(sims[i], m, p, q);
      }
      // filter simulated y's
      filter = ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1);
      // mean correct epsilon samples
      epshat_plus = ssm_smooth_eps(filter, Z, H, T);
      for (i in 1:n) {
        draws[i] = (ssm_sim_get_eps(sims[i], m, p, q)
                    - ssm_smooth_eps_get_mean(epshat_plus[i], p)
                    + ssm_smooth_eps_get_mean(eps[i], p));
      }
    }
    return draws;
}
\end{verbatim}

\section{Stationary}\label{stationary}

\subsection{pacf\_to\_acf}\label{pacfux5ftoux5facf}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{x} A vector of coefficients of a partial
  autocorrelation function
\end{itemize}

\textbf{Return Value:} \texttt{vector} A vector of coefficients of an
Autocorrelation function

Partial Autocorrelations to Autocorrelations

\begin{verbatim}
vector pacf_to_acf(vector x) {
  matrix[num_elements(x), num_elements(x)] y;
  int n;
  n = num_elements(x);
  y = rep_matrix(0.0, n, n);
  for (k in 1:n) {
    for (i in 1:(k - 1)) {
      y[k, i] = y[k - 1, i] + x[k] * y[k - 1, k - i];
    }
    y[k, k] = x[k];
    print(y);
  }
  return -y[n] ';
}
\end{verbatim}

\subsection{constrain\_stationary}\label{constrainux5fstationary}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{x} An unconstrained vector in
  \((-\infty, \infty)\)
\end{itemize}

\textbf{Return Value:} \texttt{vector} A vector of coefficients for a
stationary AR or inverible MA process.

Constrain vector of coefficients to the stationary and intertible region
for AR or MA functions.

See \textcite{Jones1980a}, \textcite{Jones1987a},
\textcite{Monahan1984a}, \textcite{AnsleyKohn1986a}, and the functions
\texttt{tools.constrain\_stationary\_univariate} and
\texttt{tools.unconstraine\_stationary\_univariate} in
\href{http://www.statsmodels.org/dev/statespace.html\#statespace-tools}{statsmodels.tsa.statespace}.

\begin{verbatim}
vector constrain_stationary(vector x) {
  vector[num_elements(x)] r;
  int n;
  n = num_elements(x);
  // transform (-Inf, Inf) to (-1, 1)
  for (i in 1:n) {
    r[i] = x[i] / (sqrt(1.0 + pow(x[i], 2)));
  }
  // Transform PACF to ACF
  return pacf_to_acf(r);
}
\end{verbatim}

\subsection{acf\_to\_pacf}\label{acfux5ftoux5fpacf}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{x} Coeffcients of an autocorrelation function.
\end{itemize}

\textbf{Return Value:} \texttt{vector} A vector of coefficients of the
corresponding partial autocorrelation function.

Convert coefficients of an autocorrelation function to partial
autocorrelations.

\begin{verbatim}
vector acf_to_pacf(vector x) {
  matrix[num_elements(x), num_elements(x)] y;
  vector[num_elements(x)] r;
  int n;
  n = num_elements(x);
  y = rep_matrix(0.0, n, n);
  y[n] = -x ';
  for (j in 0:(n - 1)) {
    int k;
    k = n - j;
    for (i in 1:(k - 1)) {
      y[k - 1, i] = (y[k, i] - y[k, k] * y[k, k - i]) / (1 - pow(y[k, k], 2));
    }
  }
  r = diagonal(y);
  return r;
}
\end{verbatim}

\subsection{unconstrain\_stationary}\label{unconstrainux5fstationary}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{vector} \textbf{x} Coeffcients of an autocorrelation function.
\end{itemize}

\textbf{Return Value:} \texttt{vector} Coefficients of the corresponding
partial autocorrelation function.

Transform from stationary and invertible space to \((-\infty, \infty)\).

\begin{verbatim}
vector unconstrain_stationary(vector x) {
  matrix[num_elements(x), num_elements(x)] y;
  vector[num_elements(x)] r;
  vector[num_elements(x)] z;
  int n;
  n = num_elements(x);
  // Transform ACF to PACF
  r = acf_to_pacf(x);
  // Transform (-1, 1) to (-Inf, Inf)
  for (i in 1:n) {
    z[i] = r[i] / (sqrt(1.0 - pow(r[i], 2)));
  }
  return z;
}
\end{verbatim}

\subsection{kronecker\_prod}\label{kroneckerux5fprod}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{matrix} \textbf{A} An \(m \times n\) matrix
\item
  \texttt{matrix} \textbf{B} A \(p \times q\) matrix
\end{itemize}

\textbf{Return Value:} \texttt{matrix} An \(mp \times nq\) matrix.

Kronecker product

The Kronecker product of a \(A\) and \(B\) is \[
A \otimes B =
\begin{bmatrix}
a_{11} B \cdots a_{1n} B \\
\vdots & \ddots & vdots \\
a_{m1} B & \cdots & a_{mn} B
\end{bmatrix} .
\]

\begin{verbatim}
matrix kronecker_prod(matrix A, matrix B) {
  matrix[rows(A) * rows(B), cols(A) * cols(B)] C;
  int m;
  int n;
  int p;
  int q;
  m = rows(A);
  n = cols(A);
  p = rows(B);
  q = cols(B);
  for (i in 1:m) {
    for (j in 1:n) {
      int row_start;
      int row_end;
      int col_start;
      int col_end;
      row_start = (i - 1) * p + 1;
      row_end = (i - 1) * p + p;
      col_start = (j - 1) * q + 1;
      col_end = (j - 1) * q + 1;
      C[row_start:row_end, col_start:col_end] = A[i, j] * B;
    }
  }
  return C;
}
\end{verbatim}

\subsection{arima\_stationary\_cov}\label{arimaux5fstationaryux5fcov}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{matrix} \textbf{T} The \(m \times m\) transition matrix
\item
  \texttt{matrix} \textbf{R} The \(m \times q\) system disturbance
  selection matrix
\end{itemize}

\textbf{Return Value:} \texttt{matrix} An \(m \times m\) matrix with the
stationary covariance matrix.

Find the covariance of the stationary distribution of an ARMA model

The initial conditions are \(\alpha_1 \sim N(0, \sigma^2 Q_0)\), where
\(Q_0\) is the solution to \[
(T \otimes T) \VEC(Q_0) = \VEC(R R')
\] where \(\VEC(Q_0)\) and \(\VEC(R R')\) are the stacked columns of
\(Q_0\) and \(R R'\)

See \textcite{DurbinKoopman2012}, Sec 5.6.2.

\begin{verbatim}
matrix arima_stationary_cov(matrix T, matrix R) {
  matrix[rows(T), cols(T)] Q0;
  matrix[rows(T) * rows(T), rows(T) * rows(T)] TT;
  vector[rows(T) * rows(T)] RR;
  int m;
  int m2;
  m = rows(T);
  m2 = m * m;
  RR = to_vector(tcrossprod(R));
  TT = kronecker_prod(T, T);
  Q0 = to_matrix_colwise((diag_matrix(rep_vector(1.0, m2)) - TT) \ RR, m, m);
  return Q0;
}
\end{verbatim}

\chapter{Other Software}\label{other-software}

This a brief summary of other available software to estimate state space
models with a focus on R and python.

\section{R packages}\label{r-packages}

\textcite{Tusell2011} reviews R packages for state space models (as of
2011). \textcite{Helske2012} includes an more recent review of R
packages implementing state space models.

\begin{itemize}
\item
  The \textbf{stats} package includes functions for univariate Kalman
  filtering and smoothing (\texttt{KalmanLike}, \texttt{KalmanRun},
  \texttt{KalmanSmooth}, \texttt{KalmanForecast}) which are used by
  \texttt{StructTS} and \texttt{arima}.
\item
  dse
\item
  sspir
\item
  dlm
\item
  KFAS
\item
  dlmodeler - provides a unified interface to multiple packages
\item
  rucm: structural time series
\item
  MARSS - maximum likelihood estimation of a large glass of Guassian
  state space models with an EM-algorithm
\end{itemize}

\section{Other}\label{other}

The \href{https://www.jstatsoft.org/issue/view/v041}{JSS Volume 41}
\autocite{CommandeurKoopmanOoms2011} contains articles on state space
implementations in multiple languages

\begin{itemize}
\tightlist
\item
  STAMP \autocite{Mendelssohn2011a}
\item
  Ox/SsfPack \autocite{Pelagatti2011a}
\item
  R \autocite{PetrisPetrone2011a}
\item
  SsfPack in S+FinMetrics \autocite{Zivot2011a}
\item
  Matlab \autocite{PengAston2011a}
\item
  FORTRAN \autocite{Bell2011a}
\item
  eViews \autocite{Bossche2011a}
\item
  RATS \autocite{Doan2011a}
\item
  Stata \autocite{DrukkerGates2011a}
\item
  gretl \autocite{Lucchetti2011a}
\item
  SAS \autocite{Selukar2011a}
\item
  Ox \autocite{Bos2011a}
\end{itemize}

\subsection{Stata}\label{stata}

Stata's \href{http://www.stata.com/manuals14/ts.pdf}{timeseries}
capabilities includes the command \texttt{ssmodels} to estimate general
state space models, as well as common special cases: \texttt{arima}
(SARIMAX models), \texttt{dfactor} (Dynamic Factor), and \texttt{ucm}
(Unobserved Components Models).

\subsection{Python}\label{python}

The {[}statsmodels{]} module {[}statsmodels.tsa{]} contains functions
and classes for time series analysis including autoregressive (AR),
vector autoregressive (VAR), autoregressive moving avergage models
(ARMA), and functions fo Kalman filtering. Currently the Kalman filter
only handles the special univariate case for ARIMA.

The \textbf{statsmodels} module
\href{http://www.statsmodels.org/dev/statespace.html\#}{statsmodels.tsa.statespace}
contains more general state space code. The examples are very good.

An
\href{http://pages.uoregon.edu/cfulton/posts/state_space_mh.html}{example}
of using \texttt{statsmodels.tsa.statespace} and
\href{http://pymcmc.readthedocs.io/en/latest/}{PyMC} to simulate from
the posterior of a state space model. See
\href{http://pages.uoregon.edu/cfulton/posts/state_space_python.html}{State
Space Modeling in Python}.

\textcite{StricklandBurdettMengersenEtAl2014a} introduce
\href{https://bitbucket.org/christophermarkstrickland/pyssm}{PySSM} to
simulate state space models using PyMCMC (not to be confused with the
more popular PyMC).

\printbibliography

\end{document}
